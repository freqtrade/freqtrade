{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Star Fork Download</p>"},{"location":"#introduction","title":"Introduction","text":"<p>Freqtrade is a free and open source crypto trading bot written in Python. It is designed to support all major exchanges and be controlled via Telegram or webUI. It contains backtesting, plotting and money management tools as well as strategy optimization by machine learning.</p> <p>DISCLAIMER</p> <p>This software is for educational purposes only. Do not risk money which you are afraid to lose. USE THE SOFTWARE AT YOUR OWN RISK. THE AUTHORS AND ALL AFFILIATES ASSUME NO RESPONSIBILITY FOR YOUR TRADING RESULTS.</p> <p>Always start by running a trading bot in Dry-run and do not engage money before you understand how it works and what profit/loss you should expect.</p> <p>We strongly recommend you to have basic coding skills and Python knowledge. Do not hesitate to read the source code and understand the mechanisms of this bot, algorithms and techniques implemented in it.</p> <p></p>"},{"location":"#features","title":"Features","text":"<ul> <li>Develop your Strategy: Write your strategy in python, using pandas. Example strategies to inspire you are available in the strategy repository.</li> <li>Download market data: Download historical data of the exchange and the markets your may want to trade with.</li> <li>Backtest: Test your strategy on downloaded historical data.</li> <li>Optimize: Find the best parameters for your strategy using hyperoptimization which employs machining learning methods. You can optimize buy, sell, take profit (ROI), stop-loss and trailing stop-loss parameters for your strategy.</li> <li>Select markets: Create your static list or use an automatic one based on top traded volumes and/or prices (not available during backtesting). You can also explicitly blacklist markets you don't want to trade.</li> <li>Run: Test your strategy with simulated money (Dry-Run mode) or deploy it with real money (Live-Trade mode).</li> <li>Run using Edge (optional module): The concept is to find the best historical trade expectancy by markets based on variation of the stop-loss and then allow/reject markets to trade. The sizing of the trade is based on a risk of a percentage of your capital.</li> <li>Control/Monitor: Use Telegram or a WebUI (start/stop the bot, show profit/loss, daily summary, current open trades results, etc.).</li> <li>Analyze: Further analysis can be performed on either Backtesting data or Freqtrade trading history (SQL database), including automated standard plots, and methods to load the data into interactive environments.</li> </ul>"},{"location":"#supported-exchange-marketplaces","title":"Supported exchange marketplaces","text":"<p>Please read the exchange specific notes to learn about eventual, special configurations needed for each exchange.</p> <ul> <li> Binance</li> <li> Bitmart</li> <li> BingX</li> <li> Gate.io</li> <li> HTX (Former Huobi)</li> <li> Kraken</li> <li> OKX (Former OKEX)</li> <li> potentially many others through . (We cannot guarantee they will work)</li> </ul>"},{"location":"#supported-futures-exchanges-experimental","title":"Supported Futures Exchanges (experimental)","text":"<ul> <li> Binance</li> <li> Gate.io</li> <li> OKX</li> <li> Bybit</li> </ul> <p>Please make sure to read the exchange specific notes, as well as the trading with leverage documentation before diving in.</p>"},{"location":"#community-tested","title":"Community tested","text":"<p>Exchanges confirmed working by the community:</p> <ul> <li> Bitvavo</li> <li> Kucoin</li> </ul>"},{"location":"#community-showcase","title":"Community showcase","text":"<p>This section will highlight a few projects from members of the community.</p> <p>Note</p> <p>The projects below are for the most part not maintained by the freqtrade , therefore use your own caution before using them.</p> <ul> <li>Example freqtrade strategies</li> <li>FrequentHippo - Grafana dashboard with dry/live runs and backtests (by hippocritical).</li> <li>Online pairlist generator (by Blood4rc).</li> <li>Freqtrade Backtesting Project (by Blood4rc).</li> <li>Freqtrade analysis notebook (by Froggleston).</li> <li>TUI for freqtrade (by Froggleston).</li> <li>Bot Academy (by stash86) - Blog about crypto bot projects.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":""},{"location":"#hardware-requirements","title":"Hardware requirements","text":"<p>To run this bot we recommend you a linux cloud instance with a minimum of:</p> <ul> <li>2GB RAM</li> <li>1GB disk space</li> <li>2vCPU</li> </ul>"},{"location":"#software-requirements","title":"Software requirements","text":"<ul> <li>Docker (Recommended)</li> </ul> <p>Alternatively</p> <ul> <li>Python 3.9+</li> <li>pip (pip3)</li> <li>git</li> <li>TA-Lib</li> <li>virtualenv (Recommended)</li> </ul>"},{"location":"#support","title":"Support","text":""},{"location":"#help-discord","title":"Help / Discord","text":"<p>For any questions not covered by the documentation or for further information about the bot, or to simply engage with like-minded individuals, we encourage you to join the Freqtrade discord server.</p>"},{"location":"#ready-to-try","title":"Ready to try?","text":"<p>Begin by reading the installation guide for docker (recommended), or for installation without docker.</p>"},{"location":"advanced-backtesting/","title":"Advanced Backtesting Analysis","text":""},{"location":"advanced-backtesting/#analyze-the-buyentry-and-sellexit-tags","title":"Analyze the buy/entry and sell/exit tags","text":"<p>It can be helpful to understand how a strategy behaves according to the buy/entry tags used to mark up different buy conditions. You might want to see more complex statistics about each buy and sell condition above those provided by the default backtesting output. You may also want to determine indicator values on the signal candle that resulted in a trade opening.</p> <p>Note</p> <p>The following buy reason analysis is only available for backtesting, not hyperopt.</p> <p>We need to run backtesting with the <code>--export</code> option set to <code>signals</code> to enable the exporting of signals and trades:</p> <pre><code>freqtrade backtesting -c &lt;config.json&gt; --timeframe &lt;tf&gt; --strategy &lt;strategy_name&gt; --timerange=&lt;timerange&gt; --export=signals\n</code></pre> <p>This will tell freqtrade to output a pickled dictionary of strategy, pairs and corresponding DataFrame of the candles that resulted in buy signals. Depending on how many buys your strategy makes, this file may get quite large, so periodically check your <code>user_data/backtest_results</code> folder to delete old exports.</p> <p>Before running your next backtest, make sure you either delete your old backtest results or run backtesting with the <code>--cache none</code> option to make sure no cached results are used.</p> <p>If all goes well, you should now see a <code>backtest-result-{timestamp}_signals.pkl</code> file in the <code>user_data/backtest_results</code> folder.</p> <p>To analyze the entry/exit tags, we now need to use the <code>freqtrade backtesting-analysis</code> command with <code>--analysis-groups</code> option provided with space-separated arguments:</p> <pre><code>freqtrade backtesting-analysis -c &lt;config.json&gt; --analysis-groups 0 1 2 3 4 5\n</code></pre> <p>This command will read from the last backtesting results. The <code>--analysis-groups</code> option is used to specify the various tabular outputs showing the profit of each group or trade, ranging from the simplest (0) to the most detailed per pair, per buy and per sell tag (4):</p> <ul> <li>0: overall winrate and profit summary by enter_tag</li> <li>1: profit summaries grouped by enter_tag</li> <li>2: profit summaries grouped by enter_tag and exit_tag</li> <li>3: profit summaries grouped by pair and enter_tag</li> <li>4: profit summaries grouped by pair, enter_ and exit_tag (this can get quite large)</li> <li>5: profit summaries grouped by exit_tag</li> </ul> <p>More options are available by running with the <code>-h</code> option.</p>"},{"location":"advanced-backtesting/#using-export-filename","title":"Using export-filename","text":"<p>Normally, <code>backtesting-analysis</code> uses the latest backtest results, but if you wanted to go back to a previous backtest output, you need to supply the <code>--export-filename</code> option. You can supply the same parameter to <code>backtest-analysis</code> with the name of the final backtest output file. This allows you to keep historical versions of backtest results and re-analyse them at a later date:</p> <pre><code>freqtrade backtesting -c &lt;config.json&gt; --timeframe &lt;tf&gt; --strategy &lt;strategy_name&gt; --timerange=&lt;timerange&gt; --export=signals --export-filename=/tmp/mystrat_backtest.json\n</code></pre> <p>You should see some output similar to below in the logs with the name of the timestamped filename that was exported:</p> <pre><code>2022-06-14 16:28:32,698 - freqtrade.misc - INFO - dumping json to \"/tmp/mystrat_backtest-2022-06-14_16-28-32.json\"\n</code></pre> <p>You can then use that filename in <code>backtesting-analysis</code>:</p> <pre><code>freqtrade backtesting-analysis -c &lt;config.json&gt; --export-filename=/tmp/mystrat_backtest-2022-06-14_16-28-32.json\n</code></pre>"},{"location":"advanced-backtesting/#tuning-the-buy-tags-and-sell-tags-to-display","title":"Tuning the buy tags and sell tags to display","text":"<p>To show only certain buy and sell tags in the displayed output, use the following two options:</p> <pre><code>--enter-reason-list : Space-separated list of enter signals to analyse. Default: \"all\"\n--exit-reason-list : Space-separated list of exit signals to analyse. Default: \"all\"\n</code></pre> <p>For example:</p> <pre><code>freqtrade backtesting-analysis -c &lt;config.json&gt; --analysis-groups 0 2 --enter-reason-list enter_tag_a enter_tag_b --exit-reason-list roi custom_exit_tag_a stop_loss\n</code></pre>"},{"location":"advanced-backtesting/#outputting-signal-candle-indicators","title":"Outputting signal candle indicators","text":"<p>The real power of <code>freqtrade backtesting-analysis</code> comes from the ability to print out the indicator values present on signal candles to allow fine-grained investigation and tuning of buy signal indicators. To print out a column for a given set of indicators, use the <code>--indicator-list</code> option:</p> <pre><code>freqtrade backtesting-analysis -c &lt;config.json&gt; --analysis-groups 0 2 --enter-reason-list enter_tag_a enter_tag_b --exit-reason-list roi custom_exit_tag_a stop_loss --indicator-list rsi rsi_1h bb_lowerband ema_9 macd macdsignal\n</code></pre> <p>The indicators have to be present in your strategy's main DataFrame (either for your main timeframe or for informative timeframes) otherwise they will simply be ignored in the script output.</p> <p>There are a range of candle and trade-related fields that are included in the analysis so are  automatically accessible by including them on the indicator-list, and these include:</p> <ul> <li>open_date     : trade open datetime</li> <li>close_date    : trade close datetime</li> <li>min_rate      : minimum price seen throughout the position</li> <li>max_rate      : maximum price seen throughout the position</li> <li>open          : signal candle open price</li> <li>close         : signal candle close price</li> <li>high          : signal candle high price</li> <li>low           : signal candle low price</li> <li>volume        : signal candle volume</li> <li>profit_ratio  : trade profit ratio</li> <li>profit_abs    : absolute profit return of the trade </li> </ul>"},{"location":"advanced-backtesting/#filtering-the-trade-output-by-date","title":"Filtering the trade output by date","text":"<p>To show only trades between dates within your backtested timerange, supply the usual <code>timerange</code> option in <code>YYYYMMDD-[YYYYMMDD]</code> format:</p> <pre><code>--timerange : Timerange to filter output trades, start date inclusive, end date exclusive. e.g. 20220101-20221231\n</code></pre> <p>For example, if your backtest timerange was <code>20220101-20221231</code> but you only want to output trades in January:</p> <pre><code>freqtrade backtesting-analysis -c &lt;config.json&gt; --timerange 20220101-20220201\n</code></pre>"},{"location":"advanced-backtesting/#printing-out-rejected-signals","title":"Printing out rejected signals","text":"<p>Use the <code>--rejected-signals</code> option to print out rejected signals.</p> <pre><code>freqtrade backtesting-analysis -c &lt;config.json&gt; --rejected-signals\n</code></pre>"},{"location":"advanced-backtesting/#writing-tables-to-csv","title":"Writing tables to CSV","text":"<p>Some of the tabular outputs can become large, so printing them out to the terminal is not preferable. Use the <code>--analysis-to-csv</code> option to disable printing out of tables to standard out and write them to CSV files.</p> <pre><code>freqtrade backtesting-analysis -c &lt;config.json&gt; --analysis-to-csv\n</code></pre> <p>By default this will write one file per output table you specified in the <code>backtesting-analysis</code> command, e.g.</p> <pre><code>freqtrade backtesting-analysis -c &lt;config.json&gt; --analysis-to-csv --rejected-signals --analysis-groups 0 1\n</code></pre> <p>This will write to <code>user_data/backtest_results</code>:</p> <ul> <li>rejected_signals.csv</li> <li>group_0.csv</li> <li>group_1.csv</li> </ul> <p>To override where the files will be written, also specify the <code>--analysis-csv-path</code> option.</p> <pre><code>freqtrade backtesting-analysis -c &lt;config.json&gt; --analysis-to-csv --analysis-csv-path another/data/path/\n</code></pre>"},{"location":"advanced-hyperopt/","title":"Advanced Hyperopt","text":"<p>This page explains some advanced Hyperopt topics that may require higher coding skills and Python knowledge than creation of an ordinal hyperoptimization class.</p>"},{"location":"advanced-hyperopt/#creating-and-using-a-custom-loss-function","title":"Creating and using a custom loss function","text":"<p>To use a custom loss function class, make sure that the function <code>hyperopt_loss_function</code> is defined in your custom hyperopt loss class. For the sample below, you then need to add the command line parameter <code>--hyperopt-loss SuperDuperHyperOptLoss</code> to your hyperopt call so this function is being used.</p> <p>A sample of this can be found below, which is identical to the Default Hyperopt loss implementation. A full sample can be found in userdata/hyperopts.</p> <pre><code>from datetime import datetime\nfrom typing import Any, Dict\n\nfrom pandas import DataFrame\n\nfrom freqtrade.constants import Config\nfrom freqtrade.optimize.hyperopt import IHyperOptLoss\n\nTARGET_TRADES = 600\nEXPECTED_MAX_PROFIT = 3.0\nMAX_ACCEPTED_TRADE_DURATION = 300\n\nclass SuperDuperHyperOptLoss(IHyperOptLoss):\n    \"\"\"\n    Defines the default loss function for hyperopt\n    \"\"\"\n\n    @staticmethod\n    def hyperopt_loss_function(results: DataFrame, trade_count: int,\n                               min_date: datetime, max_date: datetime,\n                               config: Config, processed: Dict[str, DataFrame],\n                               backtest_stats: Dict[str, Any],\n                               *args, **kwargs) -&gt; float:\n        \"\"\"\n        Objective function, returns smaller number for better results\n        This is the legacy algorithm (used until now in freqtrade).\n        Weights are distributed as follows:\n        * 0.4 to trade duration\n        * 0.25: Avoiding trade loss\n        * 1.0 to total profit, compared to the expected value (`EXPECTED_MAX_PROFIT`) defined above\n        \"\"\"\n        total_profit = results['profit_ratio'].sum()\n        trade_duration = results['trade_duration'].mean()\n\n        trade_loss = 1 - 0.25 * exp(-(trade_count - TARGET_TRADES) ** 2 / 10 ** 5.8)\n        profit_loss = max(0, 1 - total_profit / EXPECTED_MAX_PROFIT)\n        duration_loss = 0.4 * min(trade_duration / MAX_ACCEPTED_TRADE_DURATION, 1)\n        result = trade_loss + profit_loss + duration_loss\n        return result\n</code></pre> <p>Currently, the arguments are:</p> <ul> <li><code>results</code>: DataFrame containing the resulting trades.     The following columns are available in results (corresponds to the output-file of backtesting when used with <code>--export trades</code>): <code>pair, profit_ratio, profit_abs, open_date, open_rate, fee_open, close_date, close_rate, fee_close, amount, trade_duration, is_open, exit_reason, stake_amount, min_rate, max_rate, stop_loss_ratio, stop_loss_abs</code></li> <li><code>trade_count</code>: Amount of trades (identical to <code>len(results)</code>)</li> <li><code>min_date</code>: Start date of the timerange used</li> <li><code>min_date</code>: End date of the timerange used</li> <li><code>config</code>: Config object used (Note: Not all strategy-related parameters will be updated here if they are part of a hyperopt space).</li> <li><code>processed</code>: Dict of Dataframes with the pair as keys containing the data used for backtesting.</li> <li><code>backtest_stats</code>: Backtesting statistics using the same format as the backtesting file \"strategy\" substructure. Available fields can be seen in <code>generate_strategy_stats()</code> in <code>optimize_reports.py</code>.</li> </ul> <p>This function needs to return a floating point number (<code>float</code>). Smaller numbers will be interpreted as better results. The parameters and balancing for this is up to you.</p> <p>Note</p> <p>This function is called once per epoch - so please make sure to have this as optimized as possible to not slow hyperopt down unnecessarily.</p> <p><code>*args</code> and <code>**kwargs</code></p> <p>Please keep the arguments <code>*args</code> and <code>**kwargs</code> in the interface to allow us to extend this interface in the future.</p>"},{"location":"advanced-hyperopt/#overriding-pre-defined-spaces","title":"Overriding pre-defined spaces","text":"<p>To override a pre-defined space (<code>roi_space</code>, <code>generate_roi_table</code>, <code>stoploss_space</code>, <code>trailing_space</code>, <code>max_open_trades_space</code>), define a nested class called Hyperopt and define the required spaces as follows:</p> <pre><code>from freqtrade.optimize.space import Categorical, Dimension, Integer, SKDecimal\n\nclass MyAwesomeStrategy(IStrategy):\n    class HyperOpt:\n        # Define a custom stoploss space.\n        def stoploss_space():\n            return [SKDecimal(-0.05, -0.01, decimals=3, name='stoploss')]\n\n        # Define custom ROI space\n        def roi_space() -&gt; List[Dimension]:\n            return [\n                Integer(10, 120, name='roi_t1'),\n                Integer(10, 60, name='roi_t2'),\n                Integer(10, 40, name='roi_t3'),\n                SKDecimal(0.01, 0.04, decimals=3, name='roi_p1'),\n                SKDecimal(0.01, 0.07, decimals=3, name='roi_p2'),\n                SKDecimal(0.01, 0.20, decimals=3, name='roi_p3'),\n            ]\n\n        def generate_roi_table(params: Dict) -&gt; Dict[int, float]:\n\n            roi_table = {}\n            roi_table[0] = params['roi_p1'] + params['roi_p2'] + params['roi_p3']\n            roi_table[params['roi_t3']] = params['roi_p1'] + params['roi_p2']\n            roi_table[params['roi_t3'] + params['roi_t2']] = params['roi_p1']\n            roi_table[params['roi_t3'] + params['roi_t2'] + params['roi_t1']] = 0\n\n            return roi_table\n\n        def trailing_space() -&gt; List[Dimension]:\n            # All parameters here are mandatory, you can only modify their type or the range.\n            return [\n                # Fixed to true, if optimizing trailing_stop we assume to use trailing stop at all times.\n                Categorical([True], name='trailing_stop'),\n\n                SKDecimal(0.01, 0.35, decimals=3, name='trailing_stop_positive'),\n                # 'trailing_stop_positive_offset' should be greater than 'trailing_stop_positive',\n                # so this intermediate parameter is used as the value of the difference between\n                # them. The value of the 'trailing_stop_positive_offset' is constructed in the\n                # generate_trailing_params() method.\n                # This is similar to the hyperspace dimensions used for constructing the ROI tables.\n                SKDecimal(0.001, 0.1, decimals=3, name='trailing_stop_positive_offset_p1'),\n\n                Categorical([True, False], name='trailing_only_offset_is_reached'),\n        ]\n\n        # Define a custom max_open_trades space\n        def max_open_trades_space(self) -&gt; List[Dimension]:\n            return [\n                Integer(-1, 10, name='max_open_trades'),\n            ]\n</code></pre> <p>Note</p> <p>All overrides are optional and can be mixed/matched as necessary.</p>"},{"location":"advanced-hyperopt/#dynamic-parameters","title":"Dynamic parameters","text":"<p>Parameters can also be defined dynamically, but must be available to the instance once the <code>bot_start()</code> callback has been called.</p> <pre><code>class MyAwesomeStrategy(IStrategy):\n\n    def bot_start(self, **kwargs) -&gt; None:\n        self.buy_adx = IntParameter(20, 30, default=30, optimize=True)\n\n    # ...\n</code></pre> <p>Warning</p> <p>Parameters created this way will not show up in the <code>list-strategies</code> parameter count.</p>"},{"location":"advanced-hyperopt/#overriding-base-estimator","title":"Overriding Base estimator","text":"<p>You can define your own estimator for Hyperopt by implementing <code>generate_estimator()</code> in the Hyperopt subclass.</p> <pre><code>class MyAwesomeStrategy(IStrategy):\n    class HyperOpt:\n        def generate_estimator(dimensions: List['Dimension'], **kwargs):\n            return \"RF\"\n</code></pre> <p>Possible values are either one of \"GP\", \"RF\", \"ET\", \"GBRT\" (Details can be found in the scikit-optimize documentation), or \"an instance of a class that inherits from <code>RegressorMixin</code> (from sklearn) and where the <code>predict</code> method has an optional <code>return_std</code> argument, which returns <code>std(Y | x)</code> along with <code>E[Y | x]</code>\".</p> <p>Some research will be necessary to find additional Regressors.</p> <p>Example for <code>ExtraTreesRegressor</code> (\"ET\") with additional parameters:</p> <pre><code>class MyAwesomeStrategy(IStrategy):\n    class HyperOpt:\n        def generate_estimator(dimensions: List['Dimension'], **kwargs):\n            from skopt.learning import ExtraTreesRegressor\n            # Corresponds to \"ET\" - but allows additional parameters.\n            return ExtraTreesRegressor(n_estimators=100)\n</code></pre> <p>The <code>dimensions</code> parameter is the list of <code>skopt.space.Dimension</code> objects corresponding to the parameters to be optimized. It can be used to create isotropic kernels for the <code>skopt.learning.GaussianProcessRegressor</code> estimator. Here's an example:</p> <pre><code>class MyAwesomeStrategy(IStrategy):\n    class HyperOpt:\n        def generate_estimator(dimensions: List['Dimension'], **kwargs):\n            from skopt.utils import cook_estimator\n            from skopt.learning.gaussian_process.kernels import (Matern, ConstantKernel)\n            kernel_bounds = (0.0001, 10000)\n            kernel = (\n                ConstantKernel(1.0, kernel_bounds) * \n                Matern(length_scale=np.ones(len(dimensions)), length_scale_bounds=[kernel_bounds for d in dimensions], nu=2.5)\n            )\n            kernel += (\n                ConstantKernel(1.0, kernel_bounds) * \n                Matern(length_scale=np.ones(len(dimensions)), length_scale_bounds=[kernel_bounds for d in dimensions], nu=1.5)\n            )\n\n            return cook_estimator(\"GP\", space=dimensions, kernel=kernel, n_restarts_optimizer=2)\n</code></pre> <p>Note</p> <p>While custom estimators can be provided, it's up to you as User to do research on possible parameters and analyze / understand which ones should be used. If you're unsure about this, best use one of the Defaults (<code>\"ET\"</code> has proven to be the most versatile) without further parameters.</p>"},{"location":"advanced-hyperopt/#space-options","title":"Space options","text":"<p>For the additional spaces, scikit-optimize (in combination with Freqtrade) provides the following space types:</p> <ul> <li><code>Categorical</code> - Pick from a list of categories (e.g. <code>Categorical(['a', 'b', 'c'], name=\"cat\")</code>)</li> <li><code>Integer</code> - Pick from a range of whole numbers (e.g. <code>Integer(1, 10, name='rsi')</code>)</li> <li><code>SKDecimal</code> - Pick from a range of decimal numbers with limited precision (e.g. <code>SKDecimal(0.1, 0.5, decimals=3, name='adx')</code>). Available only with freqtrade.</li> <li><code>Real</code> - Pick from a range of decimal numbers with full precision (e.g. <code>Real(0.1, 0.5, name='adx')</code></li> </ul> <p>You can import all of these from <code>freqtrade.optimize.space</code>, although <code>Categorical</code>, <code>Integer</code> and <code>Real</code> are only aliases for their corresponding scikit-optimize Spaces. <code>SKDecimal</code> is provided by freqtrade for faster optimizations.</p> <pre><code>from freqtrade.optimize.space import Categorical, Dimension, Integer, SKDecimal, Real  # noqa\n</code></pre> <p>SKDecimal vs. Real</p> <p>We recommend to use <code>SKDecimal</code> instead of the <code>Real</code> space in almost all cases. While the Real space provides full accuracy (up to ~16 decimal places) - this precision is rarely needed, and leads to unnecessary long hyperopt times.</p> <p>Assuming the definition of a rather small space (<code>SKDecimal(0.10, 0.15, decimals=2, name='xxx')</code>) - SKDecimal will have 5 possibilities (<code>[0.10, 0.11, 0.12, 0.13, 0.14, 0.15]</code>).</p> <p>A corresponding real space <code>Real(0.10, 0.15 name='xxx')</code>  on the other hand has an almost unlimited number of possibilities (<code>[0.10, 0.010000000001, 0.010000000002, ... 0.014999999999, 0.01500000000]</code>).</p>"},{"location":"advanced-setup/","title":"Advanced Post-installation Tasks","text":"<p>This page explains some advanced tasks and configuration options that can be performed after the bot installation and may be uselful in some environments.</p> <p>If you do not know what things mentioned here mean, you probably do not need it.</p>"},{"location":"advanced-setup/#running-multiple-instances-of-freqtrade","title":"Running multiple instances of Freqtrade","text":"<p>This section will show you how to run multiple bots at the same time, on the same machine.</p>"},{"location":"advanced-setup/#things-to-consider","title":"Things to consider","text":"<ul> <li>Use different database files.</li> <li>Use different Telegram bots (requires multiple different configuration files; applies only when Telegram is enabled).</li> <li>Use different ports (applies only when Freqtrade REST API webserver is enabled).</li> </ul>"},{"location":"advanced-setup/#different-database-files","title":"Different database files","text":"<p>In order to keep track of your trades, profits, etc., freqtrade is using a SQLite database where it stores various types of information such as the trades you performed in the past and the current position(s) you are holding at any time. This allows you to keep track of your profits, but most importantly, keep track of ongoing activity if the bot process would be restarted or would be terminated unexpectedly.</p> <p>Freqtrade will, by default, use separate database files for dry-run and live bots (this assumes no database-url is given in either configuration nor via command line argument). For live trading mode, the default database will be <code>tradesv3.sqlite</code> and for dry-run it will be <code>tradesv3.dryrun.sqlite</code>.</p> <p>The optional argument to the trade command used to specify the path of these files is <code>--db-url</code>, which requires a valid SQLAlchemy url. So when you are starting a bot with only the config and strategy arguments in dry-run mode, the following 2 commands would have the same outcome.</p> <pre><code>freqtrade trade -c MyConfig.json -s MyStrategy\n# is equivalent to\nfreqtrade trade -c MyConfig.json -s MyStrategy --db-url sqlite:///tradesv3.dryrun.sqlite\n</code></pre> <p>It means that if you are running the trade command in two different terminals, for example to test your strategy both for trades in USDT and in another instance for trades in BTC, you will have to run them with different databases.</p> <p>If you specify the URL of a database which does not exist, freqtrade will create one with the name you specified. So to test your custom strategy with BTC and USDT stake currencies, you could use the following commands (in 2 separate terminals):</p> <pre><code># Terminal 1:\nfreqtrade trade -c MyConfigBTC.json -s MyCustomStrategy --db-url sqlite:///user_data/tradesBTC.dryrun.sqlite\n# Terminal 2:\nfreqtrade trade -c MyConfigUSDT.json -s MyCustomStrategy --db-url sqlite:///user_data/tradesUSDT.dryrun.sqlite\n</code></pre> <p>Conversely, if you wish to do the same thing in production mode, you will also have to create at least one new database (in addition to the default one) and specify the path to the \"live\" databases, for example:</p> <pre><code># Terminal 1:\nfreqtrade trade -c MyConfigBTC.json -s MyCustomStrategy --db-url sqlite:///user_data/tradesBTC.live.sqlite\n# Terminal 2:\nfreqtrade trade -c MyConfigUSDT.json -s MyCustomStrategy --db-url sqlite:///user_data/tradesUSDT.live.sqlite\n</code></pre> <p>For more information regarding usage of the sqlite databases, for example to manually enter or remove trades, please refer to the SQL Cheatsheet.</p>"},{"location":"advanced-setup/#multiple-instances-using-docker","title":"Multiple instances using docker","text":"<p>To run multiple instances of freqtrade using docker you will need to edit the docker-compose.yml file and add all the instances you want as separate services. Remember, you can separate your configuration into multiple files, so it's a good idea to think about making them modular, then if you need to edit something common to all bots, you can do that in a single config file.  <pre><code>---\nversion: '3'\nservices:\n  freqtrade1:\n    image: freqtradeorg/freqtrade:stable\n    # image: freqtradeorg/freqtrade:develop\n    # Use plotting image\n    # image: freqtradeorg/freqtrade:develop_plot\n    # Build step - only needed when additional dependencies are needed\n    # build:\n    #   context: .\n    #   dockerfile: \"./docker/Dockerfile.custom\"\n    restart: always\n    container_name: freqtrade1\n    volumes:\n      - \"./user_data:/freqtrade/user_data\"\n    # Expose api on port 8080 (localhost only)\n    # Please read the https://www.freqtrade.io/en/latest/rest-api/ documentation\n    # before enabling this.\n     ports:\n     - \"127.0.0.1:8080:8080\"\n    # Default command used when running `docker compose up`\n    command: &gt;\n      trade\n      --logfile /freqtrade/user_data/logs/freqtrade1.log\n      --db-url sqlite:////freqtrade/user_data/tradesv3_freqtrade1.sqlite\n      --config /freqtrade/user_data/config.json\n      --config /freqtrade/user_data/config.freqtrade1.json\n      --strategy SampleStrategy\n\n  freqtrade2:\n    image: freqtradeorg/freqtrade:stable\n    # image: freqtradeorg/freqtrade:develop\n    # Use plotting image\n    # image: freqtradeorg/freqtrade:develop_plot\n    # Build step - only needed when additional dependencies are needed\n    # build:\n    #   context: .\n    #   dockerfile: \"./docker/Dockerfile.custom\"\n    restart: always\n    container_name: freqtrade2\n    volumes:\n      - \"./user_data:/freqtrade/user_data\"\n    # Expose api on port 8080 (localhost only)\n    # Please read the https://www.freqtrade.io/en/latest/rest-api/ documentation\n    # before enabling this.\n    ports:\n      - \"127.0.0.1:8081:8080\"\n    # Default command used when running `docker compose up`\n    command: &gt;\n      trade\n      --logfile /freqtrade/user_data/logs/freqtrade2.log\n      --db-url sqlite:////freqtrade/user_data/tradesv3_freqtrade2.sqlite\n      --config /freqtrade/user_data/config.json\n      --config /freqtrade/user_data/config.freqtrade2.json\n      --strategy SampleStrategy\n</code></pre> You can use whatever naming convention you want, freqtrade1 and 2 are arbitrary. Note, that you will need to use different database files, port mappings and telegram configurations for each instance, as mentioned above. </p>"},{"location":"advanced-setup/#configure-the-bot-running-as-a-systemd-service","title":"Configure the bot running as a systemd service","text":"<p>Copy the <code>freqtrade.service</code> file to your systemd user directory (usually <code>~/.config/systemd/user</code>) and update <code>WorkingDirectory</code> and <code>ExecStart</code> to match your setup.</p> <p>Note</p> <p>Certain systems (like Raspbian) don't load service unit files from the user directory. In this case, copy <code>freqtrade.service</code> into <code>/etc/systemd/user/</code> (requires superuser permissions).</p> <p>After that you can start the daemon with:</p> <pre><code>systemctl --user start freqtrade\n</code></pre> <p>For this to be persistent (run when user is logged out) you'll need to enable <code>linger</code> for your freqtrade user.</p> <pre><code>sudo loginctl enable-linger \"$USER\"\n</code></pre> <p>If you run the bot as a service, you can use systemd service manager as a software watchdog monitoring freqtrade bot  state and restarting it in the case of failures. If the <code>internals.sd_notify</code> parameter is set to true in the  configuration or the <code>--sd-notify</code> command line option is used, the bot will send keep-alive ping messages to systemd  using the sd_notify (systemd notifications) protocol and will also tell systemd its current state (Running or Stopped)  when it changes. </p> <p>The <code>freqtrade.service.watchdog</code> file contains an example of the service unit configuration file which uses systemd  as the watchdog.</p> <p>Note</p> <p>The sd_notify communication between the bot and the systemd service manager will not work if the bot runs in a Docker container.</p>"},{"location":"advanced-setup/#advanced-logging","title":"Advanced Logging","text":"<p>On many Linux systems the bot can be configured to send its log messages to <code>syslog</code> or <code>journald</code> system services. Logging to a remote <code>syslog</code> server is also available on Windows. The special values for the <code>--logfile</code> command line option can be used for this.</p>"},{"location":"advanced-setup/#logging-to-syslog","title":"Logging to syslog","text":"<p>To send Freqtrade log messages to a local or remote <code>syslog</code> service use the <code>--logfile</code> command line option with the value in the following format:</p> <ul> <li><code>--logfile syslog:&lt;syslog_address&gt;</code> -- send log messages to <code>syslog</code> service using the <code>&lt;syslog_address&gt;</code> as the syslog address.</li> </ul> <p>The syslog address can be either a Unix domain socket (socket filename) or a UDP socket specification, consisting of IP address and UDP port, separated by the <code>:</code> character.</p> <p>So, the following are the examples of possible usages:</p> <ul> <li><code>--logfile syslog:/dev/log</code> -- log to syslog (rsyslog) using the <code>/dev/log</code> socket, suitable for most systems.</li> <li><code>--logfile syslog</code> -- same as above, the shortcut for <code>/dev/log</code>.</li> <li><code>--logfile syslog:/var/run/syslog</code> -- log to syslog (rsyslog) using the <code>/var/run/syslog</code> socket. Use this on MacOS.</li> <li><code>--logfile syslog:localhost:514</code> -- log to local syslog using UDP socket, if it listens on port 514.</li> <li><code>--logfile syslog:&lt;ip&gt;:514</code> -- log to remote syslog at IP address and port 514. This may be used on Windows for remote logging to an external syslog server.</li> </ul> <p>Log messages are send to <code>syslog</code> with the <code>user</code> facility. So you can see them with the following commands:</p> <ul> <li><code>tail -f /var/log/user</code>, or </li> <li>install a comprehensive graphical viewer (for instance, 'Log File Viewer' for Ubuntu).</li> </ul> <p>On many systems <code>syslog</code> (<code>rsyslog</code>) fetches data from <code>journald</code> (and vice versa), so both <code>--logfile syslog</code> or <code>--logfile journald</code> can be used and the messages be viewed with both <code>journalctl</code> and a syslog viewer utility. You can combine this in any way which suites you better.</p> <p>For <code>rsyslog</code> the messages from the bot can be redirected into a separate dedicated log file. To achieve this, add</p> <pre><code>if $programname startswith \"freqtrade\" then -/var/log/freqtrade.log\n</code></pre> <p>to one of the rsyslog configuration files, for example at the end of the <code>/etc/rsyslog.d/50-default.conf</code>.</p> <p>For <code>syslog</code> (<code>rsyslog</code>), the reduction mode can be switched on. This will reduce the number of repeating messages. For instance, multiple bot Heartbeat messages will be reduced to a single message when nothing else happens with the bot. To achieve this, set in <code>/etc/rsyslog.conf</code>:</p> <pre><code># Filter duplicated messages\n$RepeatedMsgReduction on\n</code></pre>"},{"location":"advanced-setup/#logging-to-journald","title":"Logging to journald","text":"<p>This needs the <code>cysystemd</code> python package installed as dependency (<code>pip install cysystemd</code>), which is not available on Windows. Hence, the whole journald logging functionality is not available for a bot running on Windows.</p> <p>To send Freqtrade log messages to <code>journald</code> system service use the <code>--logfile</code> command line option with the value in the following format:</p> <ul> <li><code>--logfile journald</code> -- send log messages to <code>journald</code>.</li> </ul> <p>Log messages are send to <code>journald</code> with the <code>user</code> facility. So you can see them with the following commands:</p> <ul> <li><code>journalctl -f</code> -- shows Freqtrade log messages sent to <code>journald</code> along with other log messages fetched by <code>journald</code>.</li> <li><code>journalctl -f -u freqtrade.service</code> -- this command can be used when the bot is run as a <code>systemd</code> service.</li> </ul> <p>There are many other options in the <code>journalctl</code> utility to filter the messages, see manual pages for this utility.</p> <p>On many systems <code>syslog</code> (<code>rsyslog</code>) fetches data from <code>journald</code> (and vice versa), so both <code>--logfile syslog</code> or <code>--logfile journald</code> can be used and the messages be viewed with both <code>journalctl</code> and a syslog viewer utility. You can combine this in any way which suites you better.</p>"},{"location":"backtesting/","title":"Backtesting","text":"<p>This page explains how to validate your strategy performance by using Backtesting.</p> <p>Backtesting requires historic data to be available. To learn how to get data for the pairs and exchange you're interested in, head over to the Data Downloading section of the documentation.</p>"},{"location":"backtesting/#backtesting-command-reference","title":"Backtesting command reference","text":"<pre><code>usage: freqtrade backtesting [-h] [-v] [--logfile FILE] [-V] [-c PATH]\n                             [-d PATH] [--userdir PATH] [-s NAME]\n                             [--strategy-path PATH] [-i TIMEFRAME]\n                             [--timerange TIMERANGE]\n                             [--data-format-ohlcv {json,jsongz,hdf5}]\n                             [--max-open-trades INT]\n                             [--stake-amount STAKE_AMOUNT] [--fee FLOAT]\n                             [-p PAIRS [PAIRS ...]] [--eps] [--dmmp]\n                             [--enable-protections]\n                             [--dry-run-wallet DRY_RUN_WALLET]\n                             [--timeframe-detail TIMEFRAME_DETAIL]\n                             [--strategy-list STRATEGY_LIST [STRATEGY_LIST ...]]\n                             [--export {none,trades,signals}]\n                             [--export-filename PATH]\n                             [--breakdown {day,week,month} [{day,week,month} ...]]\n                             [--cache {none,day,week,month}]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -i TIMEFRAME, --timeframe TIMEFRAME\n                        Specify timeframe (`1m`, `5m`, `30m`, `1h`, `1d`).\n  --timerange TIMERANGE\n                        Specify what timerange of data to use.\n  --data-format-ohlcv {json,jsongz,hdf5,feather,parquet}\n                        Storage format for downloaded candle (OHLCV) data.\n                        (default: `feather`).\n  --max-open-trades INT\n                        Override the value of the `max_open_trades`\n                        configuration setting.\n  --stake-amount STAKE_AMOUNT\n                        Override the value of the `stake_amount` configuration\n                        setting.\n  --fee FLOAT           Specify fee ratio. Will be applied twice (on trade\n                        entry and exit).\n  -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...]\n                        Limit command to these pairs. Pairs are space-\n                        separated.\n  --eps, --enable-position-stacking\n                        Allow buying the same pair multiple times (position\n                        stacking).\n  --dmmp, --disable-max-market-positions\n                        Disable applying `max_open_trades` during backtest\n                        (same as setting `max_open_trades` to a very high\n                        number).\n  --enable-protections, --enableprotections\n                        Enable protections for backtesting.Will slow\n                        backtesting down by a considerable amount, but will\n                        include configured protections\n  --dry-run-wallet DRY_RUN_WALLET, --starting-balance DRY_RUN_WALLET\n                        Starting balance, used for backtesting / hyperopt and\n                        dry-runs.\n  --timeframe-detail TIMEFRAME_DETAIL\n                        Specify detail timeframe for backtesting (`1m`, `5m`,\n                        `30m`, `1h`, `1d`).\n  --strategy-list STRATEGY_LIST [STRATEGY_LIST ...]\n                        Provide a space-separated list of strategies to\n                        backtest. Please note that timeframe needs to be set\n                        either in config or via command line. When using this\n                        together with `--export trades`, the strategy-name is\n                        injected into the filename (so `backtest-data.json`\n                        becomes `backtest-data-SampleStrategy.json`\n  --export {none,trades,signals}\n                        Export backtest results (default: trades).\n  --export-filename PATH, --backtest-filename PATH\n                        Use this filename for backtest results.Requires\n                        `--export` to be set as well. Example: `--export-filen\n                        ame=user_data/backtest_results/backtest_today.json`\n  --breakdown {day,week,month} [{day,week,month} ...]\n                        Show backtesting breakdown per [day, week, month].\n  --cache {none,day,week,month}\n                        Load a cached backtest result no older than specified\n                        age (default: day).\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n\nStrategy arguments:\n  -s NAME, --strategy NAME\n                        Specify strategy class name which will be used by the\n                        bot.\n  --strategy-path PATH  Specify additional strategy lookup path.\n</code></pre>"},{"location":"backtesting/#test-your-strategy-with-backtesting","title":"Test your strategy with Backtesting","text":"<p>Now you have good Entry and exit strategies and some historic data, you want to test it against real data. This is what we call backtesting.</p> <p>Backtesting will use the crypto-currencies (pairs) from your config file and load historical candle (OHLCV) data from <code>user_data/data/&lt;exchange&gt;</code> by default. If no data is available for the exchange / pair / timeframe combination, backtesting will ask you to download them first using <code>freqtrade download-data</code>. For details on downloading, please refer to the Data Downloading section in the documentation.</p> <p>The result of backtesting will confirm if your bot has better odds of making a profit than a loss.</p> <p>All profit calculations include fees, and freqtrade will use the exchange's default fees for the calculation.</p> <p>Using dynamic pairlists for backtesting</p> <p>Using dynamic pairlists is possible (not all of the handlers are allowed to be used in backtest mode), however it relies on the current market conditions - which will not reflect the historic status of the pairlist. Also, when using pairlists other than StaticPairlist, reproducibility of backtesting-results cannot be guaranteed. Please read the pairlists documentation for more information.</p> <p>To achieve reproducible results, best generate a pairlist via the <code>test-pairlist</code> command and use that as static pairlist.</p> <p>Note</p> <p>By default, Freqtrade will export backtesting results to <code>user_data/backtest_results</code>. The exported trades can be used for further analysis or can be used by the plotting sub-command (<code>freqtrade plot-dataframe</code>) in the scripts directory.</p>"},{"location":"backtesting/#starting-balance","title":"Starting balance","text":"<p>Backtesting will require a starting balance, which can be provided as <code>--dry-run-wallet &lt;balance&gt;</code> or <code>--starting-balance &lt;balance&gt;</code> command line argument, or via <code>dry_run_wallet</code> configuration setting. This amount must be higher than <code>stake_amount</code>, otherwise the bot will not be able to simulate any trade.</p>"},{"location":"backtesting/#dynamic-stake-amount","title":"Dynamic stake amount","text":"<p>Backtesting supports dynamic stake amount by configuring <code>stake_amount</code> as <code>\"unlimited\"</code>, which will split the starting balance into <code>max_open_trades</code> pieces. Profits from early trades will result in subsequent higher stake amounts, resulting in compounding of profits over the backtesting period.</p>"},{"location":"backtesting/#example-backtesting-commands","title":"Example backtesting commands","text":"<p>With 5 min candle (OHLCV) data (per default)</p> <pre><code>freqtrade backtesting --strategy AwesomeStrategy\n</code></pre> <p>Where <code>--strategy AwesomeStrategy</code> / <code>-s AwesomeStrategy</code> refers to the class name of the strategy, which is within a python file in the <code>user_data/strategies</code> directory.</p> <p>With 1 min candle (OHLCV) data</p> <pre><code>freqtrade backtesting --strategy AwesomeStrategy --timeframe 1m\n</code></pre> <p>Providing a custom starting balance of 1000 (in stake currency)</p> <pre><code>freqtrade backtesting --strategy AwesomeStrategy --dry-run-wallet 1000\n</code></pre> <p>Using a different on-disk historical candle (OHLCV) data source</p> <p>Assume you downloaded the history data from the Binance exchange and kept it in the <code>user_data/data/binance-20180101</code> directory.  You can then use this data for backtesting as follows:</p> <pre><code>freqtrade backtesting --strategy AwesomeStrategy --datadir user_data/data/binance-20180101 \n</code></pre> <p>Comparing multiple Strategies</p> <pre><code>freqtrade backtesting --strategy-list SampleStrategy1 AwesomeStrategy --timeframe 5m\n</code></pre> <p>Where <code>SampleStrategy1</code> and <code>AwesomeStrategy</code> refer to class names of strategies.</p> <p>Prevent exporting trades to file</p> <pre><code>freqtrade backtesting --strategy backtesting --export none --config config.json \n</code></pre> <p>Only use this if you're sure you'll not want to plot or analyze your results further.</p> <p>Exporting trades to file specifying a custom filename</p> <pre><code>freqtrade backtesting --strategy backtesting --export trades --export-filename=backtest_samplestrategy.json\n</code></pre> <p>Please also read about the strategy startup period.</p> <p>Supplying custom fee value</p> <p>Sometimes your account has certain fee rebates (fee reductions starting with a certain account size or monthly volume), which are not visible to ccxt. To account for this in backtesting, you can use the <code>--fee</code> command line option to supply this value to backtesting. This fee must be a ratio, and will be applied twice (once for trade entry, and once for trade exit).</p> <p>For example, if the commission fee per order is 0.1% (i.e., 0.001 written as ratio), then you would run backtesting as the following:</p> <pre><code>freqtrade backtesting --fee 0.001\n</code></pre> <p>Note</p> <p>Only supply this option (or the corresponding configuration parameter) if you want to experiment with different fee values. By default, Backtesting fetches the default fee from the exchange pair/market info.</p> <p>Running backtest with smaller test-set by using timerange</p> <p>Use the <code>--timerange</code> argument to change how much of the test-set you want to use.</p> <p>For example, running backtesting with the <code>--timerange=20190501-</code> option will use all available data starting with May 1<sup>st</sup>, 2019 from your input data.</p> <pre><code>freqtrade backtesting --timerange=20190501-\n</code></pre> <p>You can also specify particular date ranges.</p> <p>The full timerange specification:</p> <ul> <li>Use data until 2018/01/31: <code>--timerange=-20180131</code></li> <li>Use data since 2018/01/31: <code>--timerange=20180131-</code></li> <li>Use data since 2018/01/31 till 2018/03/01 : <code>--timerange=20180131-20180301</code></li> <li>Use data between POSIX / epoch timestamps 1527595200 1527618600: <code>--timerange=1527595200-1527618600</code></li> </ul>"},{"location":"backtesting/#understand-the-backtesting-result","title":"Understand the backtesting result","text":"<p>The most important in the backtesting is to understand the result.</p> <p>A backtesting result will look like that:</p> <pre><code>================================================ BACKTESTING REPORT =================================================\n| Pair     | Trades |   Avg Profit % |   Tot Profit BTC |   Tot Profit % | Avg Duration |  Wins Draws Loss   Win%  |\n|----------+--------+----------------+------------------+----------------+--------------+--------------------------|\n| ADA/BTC  |     35 |          -0.11 |      -0.00019428 |          -1.94 | 4:35:00      |    14     0    21   40.0 |\n| ARK/BTC  |     11 |          -0.41 |      -0.00022647 |          -2.26 | 2:03:00      |     3     0     8   27.3 |\n| BTS/BTC  |     32 |           0.31 |       0.00048938 |           4.89 | 5:05:00      |    18     0    14   56.2 |\n| DASH/BTC |     13 |          -0.08 |      -0.00005343 |          -0.53 | 4:39:00      |     6     0     7   46.2 |\n| ENG/BTC  |     18 |           1.36 |       0.00122807 |          12.27 | 2:50:00      |     8     0    10   44.4 |\n| EOS/BTC  |     36 |           0.08 |       0.00015304 |           1.53 | 3:34:00      |    16     0    20   44.4 |\n| ETC/BTC  |     26 |           0.37 |       0.00047576 |           4.75 | 6:14:00      |    11     0    15   42.3 |\n| ETH/BTC  |     33 |           0.30 |       0.00049856 |           4.98 | 7:31:00      |    16     0    17   48.5 |\n| IOTA/BTC |     32 |           0.03 |       0.00005444 |           0.54 | 3:12:00      |    14     0    18   43.8 |\n| LSK/BTC  |     15 |           1.75 |       0.00131413 |          13.13 | 2:58:00      |     6     0     9   40.0 |\n| LTC/BTC  |     32 |          -0.04 |      -0.00006886 |          -0.69 | 4:49:00      |    11     0    21   34.4 |\n| NANO/BTC |     17 |           1.26 |       0.00107058 |          10.70 | 1:55:00      |    10     0     7   58.5 |\n| NEO/BTC  |     23 |           0.82 |       0.00094936 |           9.48 | 2:59:00      |    10     0    13   43.5 |\n| REQ/BTC  |      9 |           1.17 |       0.00052734 |           5.27 | 3:47:00      |     4     0     5   44.4 |\n| XLM/BTC  |     16 |           1.22 |       0.00097800 |           9.77 | 3:15:00      |     7     0     9   43.8 |\n| XMR/BTC  |     23 |          -0.18 |      -0.00020696 |          -2.07 | 5:30:00      |    12     0    11   52.2 |\n| XRP/BTC  |     35 |           0.66 |       0.00114897 |          11.48 | 3:49:00      |    12     0    23   34.3 |\n| ZEC/BTC  |     22 |          -0.46 |      -0.00050971 |          -5.09 | 2:22:00      |     7     0    15   31.8 |\n| TOTAL    |    429 |           0.36 |       0.00762792 |          76.20 | 4:12:00      |   186     0   243   43.4 |\n============================================= LEFT OPEN TRADES REPORT =============================================\n| Pair     |  Trades |   Avg Profit % |   Tot Profit BTC |   Tot Profit % | Avg Duration   |  Win Draw Loss Win% |\n|----------+---------+----------------+------------------+----------------+----------------+---------------------|\n| ADA/BTC  |       1 |           0.89 |       0.00004434 |           0.44 | 6:00:00        |    1    0    0  100 |\n| LTC/BTC  |       1 |           0.68 |       0.00003421 |           0.34 | 2:00:00        |    1    0    0  100 |\n| TOTAL    |       2 |           0.78 |       0.00007855 |           0.78 | 4:00:00        |    2    0    0  100 |\n==================== EXIT REASON STATS ====================\n| Exit Reason        |   Exits |  Wins |  Draws |  Losses |\n|--------------------+---------+-------+--------+---------|\n| trailing_stop_loss |     205 |   150 |      0 |      55 |\n| stop_loss          |     166 |     0 |      0 |     166 |\n| exit_signal        |      56 |    36 |      0 |      20 |\n| force_exit         |       2 |     0 |      0 |       2 |\n\n================== SUMMARY METRICS ==================\n| Metric                      | Value               |\n|-----------------------------+---------------------|\n| Backtesting from            | 2019-01-01 00:00:00 |\n| Backtesting to              | 2019-05-01 00:00:00 |\n| Max open trades             | 3                   |\n|                             |                     |\n| Total/Daily Avg Trades      | 429 / 3.575         |\n| Starting balance            | 0.01000000 BTC      |\n| Final balance               | 0.01762792 BTC      |\n| Absolute profit             | 0.00762792 BTC      |\n| Total profit %              | 76.2%               |\n| CAGR %                      | 460.87%             |\n| Sortino                     | 1.88                |\n| Sharpe                      | 2.97                |\n| Calmar                      | 6.29                |\n| Profit factor               | 1.11                |\n| Expectancy (Ratio)          | -0.15 (-0.05)       |\n| Avg. stake amount           | 0.001      BTC      |\n| Total trade volume          | 0.429      BTC      |\n|                             |                     |\n| Long / Short                | 352 / 77            |\n| Total profit Long %         | 1250.58%            |\n| Total profit Short %        | -15.02%             |\n| Absolute profit Long        | 0.00838792 BTC      |\n| Absolute profit Short       | -0.00076 BTC        |\n|                             |                     |\n| Best Pair                   | LSK/BTC 26.26%      |\n| Worst Pair                  | ZEC/BTC -10.18%     |\n| Best Trade                  | LSK/BTC 4.25%       |\n| Worst Trade                 | ZEC/BTC -10.25%     |\n| Best day                    | 0.00076 BTC         |\n| Worst day                   | -0.00036 BTC        |\n| Days win/draw/lose          | 12 / 82 / 25        |\n| Avg. Duration Winners       | 4:23:00             |\n| Avg. Duration Loser         | 6:55:00             |\n| Max Consecutive Wins / Loss | 3 / 4               |\n| Rejected Entry signals      | 3089                |\n| Entry/Exit Timeouts         | 0 / 0               |\n| Canceled Trade Entries      | 34                  |\n| Canceled Entry Orders       | 123                 |\n| Replaced Entry Orders       | 89                  |\n|                             |                     |\n| Min balance                 | 0.00945123 BTC      |\n| Max balance                 | 0.01846651 BTC      |\n| Max % of account underwater | 25.19%              |\n| Absolute Drawdown (Account) | 13.33%              |\n| Drawdown                    | 0.0015 BTC          |\n| Drawdown high               | 0.0013 BTC          |\n| Drawdown low                | -0.0002 BTC         |\n| Drawdown Start              | 2019-02-15 14:10:00 |\n| Drawdown End                | 2019-04-11 18:15:00 |\n| Market change               | -5.88%              |\n=====================================================\n</code></pre>"},{"location":"backtesting/#backtesting-report-table","title":"Backtesting report table","text":"<p>The 1<sup>st</sup> table contains all trades the bot made, including \"left open trades\".</p> <p>The last line will give you the overall performance of your strategy, here:</p> <pre><code>| TOTAL    |    429 |           0.36 |         152.41 |       0.00762792 |          76.20 | 4:12:00      |   186     0   243   43.4 |\n</code></pre> <p>The bot has made <code>429</code> trades for an average duration of <code>4:12:00</code>, with a performance of <code>76.20%</code> (profit), that means it has earned a total of <code>0.00762792 BTC</code> starting with a capital of 0.01 BTC.</p> <p>The column <code>Avg Profit %</code> shows the average profit for all trades made. The column <code>Tot Profit %</code> shows instead the total profit % in relation to the starting balance. In the above results, we have a starting balance of 0.01 BTC and an absolute profit of 0.00762792 BTC - so the <code>Tot Profit %</code> will be <code>(0.00762792 / 0.01) * 100 ~= 76.2%</code>.</p> <p>Your strategy performance is influenced by your entry strategy, your exit strategy, and also by the <code>minimal_roi</code> and <code>stop_loss</code> you have set.</p> <p>For example, if your <code>minimal_roi</code> is only <code>\"0\":  0.01</code> you cannot expect the bot to make more profit than 1% (because it will exit every time a trade reaches 1%).</p> <pre><code>\"minimal_roi\": {\n    \"0\":  0.01\n},\n</code></pre> <p>On the other hand, if you set a too high <code>minimal_roi</code> like <code>\"0\":  0.55</code> (55%), there is almost no chance that the bot will ever reach this profit. Hence, keep in mind that your performance is an integral mix of all different elements of the strategy, your configuration, and the crypto-currency pairs you have set up.</p>"},{"location":"backtesting/#exit-reasons-table","title":"Exit reasons table","text":"<p>The 2<sup>nd</sup> table contains a recap of exit reasons. This table can tell you which area needs some additional work (e.g. all or many of the <code>exit_signal</code> trades are losses, so you should work on improving the exit signal, or consider disabling it).</p>"},{"location":"backtesting/#left-open-trades-table","title":"Left open trades table","text":"<p>The 3<sup>rd</sup> table contains all trades the bot had to <code>force_exit</code> at the end of the backtesting period to present you the full picture. This is necessary to simulate realistic behavior, since the backtest period has to end at some point, while realistically, you could leave the bot running forever. These trades are also included in the first table, but are also shown separately in this table for clarity.</p>"},{"location":"backtesting/#summary-metrics","title":"Summary metrics","text":"<p>The last element of the backtest report is the summary metrics table. It contains some useful key metrics about performance of your strategy on backtesting data.</p> <pre><code>================== SUMMARY METRICS ==================\n| Metric                      | Value               |\n|-----------------------------+---------------------|\n| Backtesting from            | 2019-01-01 00:00:00 |\n| Backtesting to              | 2019-05-01 00:00:00 |\n| Max open trades             | 3                   |\n|                             |                     |\n| Total/Daily Avg Trades      | 429 / 3.575         |\n| Starting balance            | 0.01000000 BTC      |\n| Final balance               | 0.01762792 BTC      |\n| Absolute profit             | 0.00762792 BTC      |\n| Total profit %              | 76.2%               |\n| CAGR %                      | 460.87%             |\n| Sortino                     | 1.88                |\n| Sharpe                      | 2.97                |\n| Calmar                      | 6.29                |\n| Profit factor               | 1.11                |\n| Expectancy (Ratio)          | -0.15 (-0.05)       |\n| Avg. stake amount           | 0.001      BTC      |\n| Total trade volume          | 0.429      BTC      |\n|                             |                     |\n| Long / Short                | 352 / 77            |\n| Total profit Long %         | 1250.58%            |\n| Total profit Short %        | -15.02%             |\n| Absolute profit Long        | 0.00838792 BTC      |\n| Absolute profit Short       | -0.00076 BTC        |\n|                             |                     |\n| Best Pair                   | LSK/BTC 26.26%      |\n| Worst Pair                  | ZEC/BTC -10.18%     |\n| Best Trade                  | LSK/BTC 4.25%       |\n| Worst Trade                 | ZEC/BTC -10.25%     |\n| Best day                    | 0.00076 BTC         |\n| Worst day                   | -0.00036 BTC        |\n| Days win/draw/lose          | 12 / 82 / 25        |\n| Avg. Duration Winners       | 4:23:00             |\n| Avg. Duration Loser         | 6:55:00             |\n| Max Consecutive Wins / Loss | 3 / 4               |\n| Rejected Entry signals      | 3089                |\n| Entry/Exit Timeouts         | 0 / 0               |\n| Canceled Trade Entries      | 34                  |\n| Canceled Entry Orders       | 123                 |\n| Replaced Entry Orders       | 89                  |\n|                             |                     |\n| Min balance                 | 0.00945123 BTC      |\n| Max balance                 | 0.01846651 BTC      |\n| Max % of account underwater | 25.19%              |\n| Absolute Drawdown (Account) | 13.33%              |\n| Drawdown                    | 0.0015 BTC          |\n| Drawdown high               | 0.0013 BTC          |\n| Drawdown low                | -0.0002 BTC         |\n| Drawdown Start              | 2019-02-15 14:10:00 |\n| Drawdown End                | 2019-04-11 18:15:00 |\n| Market change               | -5.88%              |\n=====================================================\n</code></pre> <ul> <li><code>Backtesting from</code> / <code>Backtesting to</code>: Backtesting range (usually defined with the <code>--timerange</code> option).</li> <li><code>Max open trades</code>: Setting of <code>max_open_trades</code> (or <code>--max-open-trades</code>) - or number of pairs in the pairlist (whatever is lower).</li> <li><code>Total/Daily Avg Trades</code>: Identical to the total trades of the backtest output table / Total trades divided by the backtesting duration in days (this will give you information about how many trades to expect from the strategy).</li> <li><code>Starting balance</code>: Start balance - as given by dry-run-wallet (config or command line).</li> <li><code>Final balance</code>: Final balance - starting balance + absolute profit.</li> <li><code>Absolute profit</code>: Profit made in stake currency.</li> <li><code>Total profit %</code>: Total profit. Aligned to the <code>TOTAL</code> row's <code>Tot Profit %</code> from the first table. Calculated as <code>(End capital \u2212 Starting capital) / Starting capital</code>.</li> <li><code>CAGR %</code>: Compound annual growth rate.</li> <li><code>Sortino</code>: Annualized Sortino ratio.</li> <li><code>Sharpe</code>: Annualized Sharpe ratio.</li> <li><code>Calmar</code>: Annualized Calmar ratio.</li> <li><code>Profit factor</code>: profit / loss.</li> <li><code>Avg. stake amount</code>: Average stake amount, either <code>stake_amount</code> or the average when using dynamic stake amount.</li> <li><code>Total trade volume</code>: Volume generated on the exchange to reach the above profit.</li> <li><code>Best Pair</code> / <code>Worst Pair</code>: Best and worst performing pair, and it's corresponding <code>Tot Profit %</code>.</li> <li><code>Best Trade</code> / <code>Worst Trade</code>: Biggest single winning trade and biggest single losing trade.</li> <li><code>Best day</code> / <code>Worst day</code>: Best and worst day based on daily profit.</li> <li><code>Days win/draw/lose</code>: Winning / Losing days (draws are usually days without closed trade).</li> <li><code>Avg. Duration Winners</code> / <code>Avg. Duration Loser</code>: Average durations for winning and losing trades.</li> <li><code>Max Consecutive Wins / Loss</code>: Maximum consecutive wins/losses in a row.</li> <li><code>Rejected Entry signals</code>: Trade entry signals that could not be acted upon due to <code>max_open_trades</code> being reached.</li> <li><code>Entry/Exit Timeouts</code>: Entry/exit orders which did not fill (only applicable if custom pricing is used).</li> <li><code>Canceled Trade Entries</code>: Number of trades that have been canceled by user request via <code>adjust_entry_price</code>.</li> <li><code>Canceled Entry Orders</code>: Number of entry orders that have been canceled by user request via <code>adjust_entry_price</code>.</li> <li><code>Replaced Entry Orders</code>: Number of entry orders that have been replaced by user request via <code>adjust_entry_price</code>.</li> <li><code>Min balance</code> / <code>Max balance</code>: Lowest and Highest Wallet balance during the backtest period.</li> <li><code>Max % of account underwater</code>: Maximum percentage your account has decreased from the top since the simulation started. Calculated as the maximum of <code>(Max Balance - Current Balance) / (Max Balance)</code>.</li> <li><code>Absolute Drawdown (Account)</code>: Maximum Account Drawdown experienced. Calculated as <code>(Absolute Drawdown) / (DrawdownHigh + startingBalance)</code>.</li> <li><code>Drawdown</code>: Maximum, absolute drawdown experienced. Difference between Drawdown High and Subsequent Low point.</li> <li><code>Drawdown high</code> / <code>Drawdown low</code>: Profit at the beginning and end of the largest drawdown period. A negative low value means initial capital lost.</li> <li><code>Drawdown Start</code> / <code>Drawdown End</code>: Start and end datetime for this largest drawdown (can also be visualized via the <code>plot-dataframe</code> sub-command).</li> <li><code>Market change</code>: Change of the market during the backtest period. Calculated as average of all pairs changes from the first to the last candle using the \"close\" column.</li> <li><code>Long / Short</code>: Split long/short values (Only shown when short trades were made).</li> <li><code>Total profit Long %</code> / <code>Absolute profit Long</code>: Profit long trades only (Only shown when short trades were made).</li> <li><code>Total profit Short %</code> / <code>Absolute profit Short</code>: Profit short trades only (Only shown when short trades were made).</li> </ul>"},{"location":"backtesting/#daily-weekly-monthly-breakdown","title":"Daily / Weekly / Monthly breakdown","text":"<p>You can get an overview over daily / weekly or monthly results by using the <code>--breakdown &lt;&gt;</code> switch.</p> <p>To visualize daily and weekly breakdowns, you can use the following:</p> <pre><code>freqtrade backtesting --strategy MyAwesomeStrategy --breakdown day week\n</code></pre> <pre><code>======================== DAY BREAKDOWN =========================\n|        Day |   Tot Profit USDT |   Wins |   Draws |   Losses |\n|------------+-------------------+--------+---------+----------|\n| 03/07/2021 |           200.0   |      2 |       0 |        0 |\n| 04/07/2021 |           -50.31  |      0 |       0 |        2 |\n| 05/07/2021 |           220.611 |      3 |       2 |        0 |\n| 06/07/2021 |           150.974 |      3 |       0 |        2 |\n| 07/07/2021 |           -70.193 |      1 |       0 |        2 |\n| 08/07/2021 |           212.413 |      2 |       0 |        3 |\n</code></pre> <p>The output will show a table containing the realized absolute Profit (in stake currency) for the given timeperiod, as well as wins, draws and losses that materialized (closed) on this day. Below that there will be a second table for the summarized values of weeks indicated by the date of the closing Sunday. The same would apply to a monthly breakdown indicated by the last day of the month.</p>"},{"location":"backtesting/#backtest-result-caching","title":"Backtest result caching","text":"<p>To save time, by default backtest will reuse a cached result from within the last day when the backtested strategy and config match that of a previous backtest. To force a new backtest despite existing result for an identical run specify <code>--cache none</code> parameter.</p> <p>Warning</p> <p>Caching is automatically disabled for open-ended timeranges (<code>--timerange 20210101-</code>), as freqtrade cannot ensure reliably that the underlying data didn't change. It can also use cached results where it shouldn't if the original backtest had missing data at the end, which was fixed by downloading more data. In this instance, please use <code>--cache none</code> once to force a fresh backtest.</p>"},{"location":"backtesting/#further-backtest-result-analysis","title":"Further backtest-result analysis","text":"<p>To further analyze your backtest results, freqtrade will export the trades to file by default. You can then load the trades to perform further analysis as shown in the data analysis backtesting section.</p>"},{"location":"backtesting/#assumptions-made-by-backtesting","title":"Assumptions made by backtesting","text":"<p>Since backtesting lacks some detailed information about what happens within a candle, it needs to take a few assumptions:</p> <ul> <li>Exchange trading limits are respected</li> <li>Entries happen at open-price</li> <li>All orders are filled at the requested price (no slippage) as long as the price is within the candle's high/low range</li> <li>Exit-signal exits happen at open-price of the consecutive candle</li> <li>Exits don't free their trade slot for a new trade until the next candle</li> <li>Exit-signal is favored over Stoploss, because exit-signals are assumed to trigger on candle's open</li> <li>ROI<ul> <li>Exits are compared to high - but the ROI value is used (e.g. ROI = 2%, high=5% - so the exit will be at 2%)</li> <li>Exits are never \"below the candle\", so a ROI of 2% may result in a exit at 2.4% if low was at 2.4% profit</li> <li>ROI entries which came into effect on the triggering candle (e.g. <code>120: 0.02</code> for 1h candles, from <code>60: 0.05</code>) will use the candle's open as exit rate</li> <li>Force-exits caused by <code>&lt;N&gt;=-1</code> ROI entries use low as exit value, unless N falls on the candle open (e.g. <code>120: -1</code> for 1h candles)</li> </ul> </li> <li>Stoploss exits happen exactly at stoploss price, even if low was lower, but the loss will be <code>2 * fees</code> higher than the stoploss price</li> <li>Stoploss is evaluated before ROI within one candle. So you can often see more trades with the <code>stoploss</code> exit reason comparing to the results obtained with the same strategy in the Dry Run/Live Trade modes</li> <li>Low happens before high for stoploss, protecting capital first</li> <li>Trailing stoploss<ul> <li>Trailing Stoploss is only adjusted if it's below the candle's low (otherwise it would be triggered)</li> <li>On trade entry candles that trigger trailing stoploss, the \"minimum offset\" (<code>stop_positive_offset</code>) is assumed (instead of high) - and the stop is calculated from this point. This rule is NOT applicable to custom-stoploss scenarios, since there's no information about the stoploss logic available.</li> <li>High happens first - adjusting stoploss</li> <li>Low uses the adjusted stoploss (so exits with large high-low difference are backtested correctly)</li> <li>ROI applies before trailing-stop, ensuring profits are \"top-capped\" at ROI if both ROI and trailing stop applies</li> </ul> </li> <li>Exit-reason does not explain if a trade was positive or negative, just what triggered the exit (this can look odd if negative ROI values are used)</li> <li>Evaluation sequence (if multiple signals happen on the same candle)<ul> <li>Exit-signal</li> <li>Stoploss</li> <li>ROI</li> <li>Trailing stoploss</li> </ul> </li> </ul> <p>Taking these assumptions, backtesting tries to mirror real trading as closely as possible. However, backtesting will never replace running a strategy in dry-run mode. Also, keep in mind that past results don't guarantee future success.</p> <p>In addition to the above assumptions, strategy authors should carefully read the Common Mistakes section, to avoid using data in backtesting which is not available in real market conditions.</p>"},{"location":"backtesting/#trading-limits-in-backtesting","title":"Trading limits in backtesting","text":"<p>Exchanges have certain trading limits, like minimum (and maximum) base currency, or minimum/maximum stake (quote) currency. These limits are usually listed in the exchange documentation as \"trading rules\" or similar and can be quite different between different pairs.</p> <p>Backtesting (as well as live and dry-run) does honor these limits, and will ensure that a stoploss can be placed below this value - so the value will be slightly higher than what the exchange specifies. Freqtrade has however no information about historic limits.</p> <p>This can lead to situations where trading-limits are inflated by using a historic price, resulting in minimum amounts &gt; 50$.</p> <p>For example:</p> <p>BTC minimum tradable amount is 0.001. BTC trades at 22.000$ today (0.001 BTC is related to this) - but the backtesting period includes prices as high as 50.000$. Today's minimum would be <code>0.001 * 22_000</code> - or 22$. However the limit could also be 50$ - based on <code>0.001 * 50_000</code> in some historic setting.</p>"},{"location":"backtesting/#trading-precision-limits","title":"Trading precision limits","text":"<p>Most exchanges pose precision limits on both price and amounts, so you cannot buy 1.0020401 of a pair, or at a price of 1.24567123123. Instead, these prices and amounts will be rounded or truncated (based on the exchange definition) to the defined trading precision. The above values may for example be rounded to an amount of 1.002, and a price of 1.24567.</p> <p>These precision values are based on current exchange limits (as described in the above section), as historic precision limits are not available.</p>"},{"location":"backtesting/#improved-backtest-accuracy","title":"Improved backtest accuracy","text":"<p>One big limitation of backtesting is it's inability to know how prices moved intra-candle (was high before close, or vice-versa?). So assuming you run backtesting with a 1h timeframe, there will be 4 prices for that candle (Open, High, Low, Close).</p> <p>While backtesting does take some assumptions (read above) about this - this can never be perfect, and will always be biased in one way or the other. To mitigate this, freqtrade can use a lower (faster) timeframe to simulate intra-candle movements.</p> <p>To utilize this, you can append <code>--timeframe-detail 5m</code> to your regular backtesting command.</p> <pre><code>freqtrade backtesting --strategy AwesomeStrategy --timeframe 1h --timeframe-detail 5m\n</code></pre> <p>This will load 1h data as well as 5m data for the timeframe. The strategy will be analyzed with the 1h timeframe, and Entry orders will only be placed at the main timeframe, however Order fills and exit signals will be evaluated at the 5m candle, simulating intra-candle movements.</p> <p>All callback functions (<code>custom_exit()</code>, <code>custom_stoploss()</code>, ... ) will be running for each 5m candle once the trade is opened (so 12 times in the above example of 1h timeframe, and 5m detailed timeframe).</p> <p><code>--timeframe-detail</code> must be smaller than the original timeframe, otherwise backtesting will fail to start.</p> <p>Obviously this will require more memory (5m data is bigger than 1h data), and will also impact runtime (depending on the amount of trades and trade durations). Also, data must be available / downloaded already.</p> <p>Tip</p> <p>You can use this function as the last part of strategy development, to ensure your strategy is not exploiting one of the backtesting assumptions. Strategies that perform similarly well with this mode have a good chance to perform well in dry/live modes too (although only forward-testing (dry-mode) can really confirm a strategy).</p>"},{"location":"backtesting/#backtesting-multiple-strategies","title":"Backtesting multiple strategies","text":"<p>To compare multiple strategies, a list of Strategies can be provided to backtesting.</p> <p>This is limited to 1 timeframe value per run. However, data is only loaded once from disk so if you have multiple strategies you'd like to compare, this will give a nice runtime boost.</p> <p>All listed Strategies need to be in the same directory, unless also <code>--recursive-strategy-search</code> is specified, where sub-directories within the strategy directory are also considered.</p> <pre><code>freqtrade backtesting --timerange 20180401-20180410 --timeframe 5m --strategy-list Strategy001 Strategy002 --export trades\n</code></pre> <p>This will save the results to <code>user_data/backtest_results/backtest-result-&lt;datetime&gt;.json</code>, including results for both <code>Strategy001</code> and <code>Strategy002</code>. There will be an additional table comparing win/losses of the different strategies (identical to the \"Total\" row in the first table). Detailed output for all strategies one after the other will be available, so make sure to scroll up to see the details per strategy.</p> <pre><code>================================================== STRATEGY SUMMARY ===================================================================\n| Strategy    |  Trades |   Avg Profit % |   Tot Profit BTC |   Tot Profit % | Avg Duration   |  Wins |  Draws | Losses | Drawdown % |\n|-------------+---------+----------------+------------------+----------------+----------------+-------+--------+--------+------------|\n| Strategy1   |     429 |           0.36 |       0.00762792 |          76.20 | 4:12:00        |   186 |      0 |    243 |       45.2 |\n| Strategy2   |    1487 |          -0.13 |      -0.00988917 |         -98.79 | 4:43:00        |   662 |      0 |    825 |     241.68 |\n</code></pre>"},{"location":"backtesting/#next-step","title":"Next step","text":"<p>Great, your strategy is profitable. What if the bot can give your the optimal parameters to use for your strategy? Your next step is to learn how to find optimal parameters with Hyperopt</p>"},{"location":"bot-basics/","title":"Freqtrade basics","text":"<p>This page provides you some basic concepts on how Freqtrade works and operates.</p>"},{"location":"bot-basics/#freqtrade-terminology","title":"Freqtrade terminology","text":"<ul> <li>Strategy: Your trading strategy, telling the bot what to do.</li> <li>Trade: Open position.</li> <li>Open Order: Order which is currently placed on the exchange, and is not yet complete.</li> <li>Pair: Tradable pair, usually in the format of Base/Quote (e.g. <code>XRP/USDT</code> for spot, <code>XRP/USDT:USDT</code> for futures).</li> <li>Timeframe: Candle length to use (e.g. <code>\"5m\"</code>, <code>\"1h\"</code>, ...).</li> <li>Indicators: Technical indicators (SMA, EMA, RSI, ...).</li> <li>Limit order: Limit orders which execute at the defined limit price or better.</li> <li>Market order: Guaranteed to fill, may move price depending on the order size.</li> <li>Current Profit: Currently pending (unrealized) profit for this trade. This is mainly used throughout the bot and UI.</li> <li>Realized Profit: Already realized profit. Only relevant in combination with partial exits - which also explains the calculation logic for this.</li> <li>Total Profit: Combined realized and unrealized profit. The relative number (%) is calculated against the total investment in this trade.</li> </ul>"},{"location":"bot-basics/#fee-handling","title":"Fee handling","text":"<p>All profit calculations of Freqtrade include fees. For Backtesting / Hyperopt / Dry-run modes, the exchange default fee is used (lowest tier on the exchange). For live operations, fees are used as applied by the exchange (this includes BNB rebates etc.).</p>"},{"location":"bot-basics/#pair-naming","title":"Pair naming","text":"<p>Freqtrade follows the ccxt naming convention for currencies. Using the wrong naming convention in the wrong market will usually result in the bot not recognizing the pair, usually resulting in errors like \"this pair is not available\".</p>"},{"location":"bot-basics/#spot-pair-naming","title":"Spot pair naming","text":"<p>For spot pairs, naming will be <code>base/quote</code> (e.g. <code>ETH/USDT</code>).</p>"},{"location":"bot-basics/#futures-pair-naming","title":"Futures pair naming","text":"<p>For futures pairs, naming will be <code>base/quote:settle</code> (e.g. <code>ETH/USDT:USDT</code>).</p>"},{"location":"bot-basics/#bot-execution-logic","title":"Bot execution logic","text":"<p>Starting freqtrade in dry-run or live mode (using <code>freqtrade trade</code>) will start the bot and start the bot iteration loop. This will also run the <code>bot_start()</code> callback.</p> <p>By default, the bot loop runs every few seconds (<code>internals.process_throttle_secs</code>) and performs the following actions:</p> <ul> <li>Fetch open trades from persistence.</li> <li>Calculate current list of tradable pairs.</li> <li>Download OHLCV data for the pairlist including all informative pairs   This step is only executed once per Candle to avoid unnecessary network traffic.</li> <li>Call <code>bot_loop_start()</code> strategy callback.</li> <li>Analyze strategy per pair.<ul> <li>Call <code>populate_indicators()</code></li> <li>Call <code>populate_entry_trend()</code></li> <li>Call <code>populate_exit_trend()</code></li> </ul> </li> <li>Update trades open order state from exchange.<ul> <li>Call <code>order_filled()</code> strategy callback for filled orders.</li> <li>Check timeouts for open orders.<ul> <li>Calls <code>check_entry_timeout()</code> strategy callback for open entry orders.</li> <li>Calls <code>check_exit_timeout()</code> strategy callback for open exit orders.</li> <li>Calls <code>adjust_entry_price()</code> strategy callback for open entry orders.</li> </ul> </li> </ul> </li> <li>Verifies existing positions and eventually places exit orders.<ul> <li>Considers stoploss, ROI and exit-signal, <code>custom_exit()</code> and <code>custom_stoploss()</code>.</li> <li>Determine exit-price based on <code>exit_pricing</code> configuration setting or by using the <code>custom_exit_price()</code> callback.</li> <li>Before a exit order is placed, <code>confirm_trade_exit()</code> strategy callback is called.</li> </ul> </li> <li>Check position adjustments for open trades if enabled by calling <code>adjust_trade_position()</code> and place additional order if required.</li> <li>Check if trade-slots are still available (if <code>max_open_trades</code> is reached).</li> <li>Verifies entry signal trying to enter new positions.<ul> <li>Determine entry-price based on <code>entry_pricing</code> configuration setting, or by using the <code>custom_entry_price()</code> callback.</li> <li>In Margin and Futures mode, <code>leverage()</code> strategy callback is called to determine the desired leverage.</li> <li>Determine stake size by calling the <code>custom_stake_amount()</code> callback.</li> <li>Before an entry order is placed, <code>confirm_trade_entry()</code> strategy callback is called.</li> </ul> </li> </ul> <p>This loop will be repeated again and again until the bot is stopped.</p>"},{"location":"bot-basics/#backtesting-hyperopt-execution-logic","title":"Backtesting / Hyperopt execution logic","text":"<p>backtesting or hyperopt do only part of the above logic, since most of the trading operations are fully simulated.</p> <ul> <li>Load historic data for configured pairlist.</li> <li>Calls <code>bot_start()</code> once.</li> <li>Calculate indicators (calls <code>populate_indicators()</code> once per pair).</li> <li>Calculate entry / exit signals (calls <code>populate_entry_trend()</code> and <code>populate_exit_trend()</code> once per pair).</li> <li>Loops per candle simulating entry and exit points.<ul> <li>Calls <code>bot_loop_start()</code> strategy callback.</li> <li>Check for Order timeouts, either via the <code>unfilledtimeout</code> configuration, or via <code>check_entry_timeout()</code> / <code>check_exit_timeout()</code> strategy callbacks.</li> <li>Calls <code>adjust_entry_price()</code> strategy callback for open entry orders.</li> <li>Check for trade entry signals (<code>enter_long</code> / <code>enter_short</code> columns).</li> <li>Confirm trade entry / exits (calls <code>confirm_trade_entry()</code> and <code>confirm_trade_exit()</code> if implemented in the strategy).</li> <li>Call <code>custom_entry_price()</code> (if implemented in the strategy) to determine entry price (Prices are moved to be within the opening candle).</li> <li>In Margin and Futures mode, <code>leverage()</code> strategy callback is called to determine the desired leverage.</li> <li>Determine stake size by calling the <code>custom_stake_amount()</code> callback.</li> <li>Check position adjustments for open trades if enabled and call <code>adjust_trade_position()</code> to determine if an additional order is requested.</li> <li>Call <code>order_filled()</code> strategy callback for filled entry orders.</li> <li>Call <code>custom_stoploss()</code> and <code>custom_exit()</code> to find custom exit points.</li> <li>For exits based on exit-signal, custom-exit and partial exits: Call <code>custom_exit_price()</code> to determine exit price (Prices are moved to be within the closing candle).</li> <li>Call <code>order_filled()</code> strategy callback for filled exit orders.</li> </ul> </li> <li>Generate backtest report output</li> </ul> <p>Note</p> <p>Both Backtesting and Hyperopt include exchange default Fees in the calculation. Custom fees can be passed to backtesting / hyperopt by specifying the <code>--fee</code> argument.</p> <p>Callback call frequency</p> <p>Backtesting will call each callback at max. once per candle (<code>--timeframe-detail</code> modifies this behavior to once per detailed candle). Most callbacks will be called once per iteration in live (usually every ~5s) - which can cause backtesting mismatches.</p>"},{"location":"bot-usage/","title":"Start the bot","text":"<p>This page explains the different parameters of the bot and how to run it.</p> <p>Note</p> <p>If you've used <code>setup.sh</code>, don't forget to activate your virtual environment (<code>source .venv/bin/activate</code>) before running freqtrade commands.</p> <p>Up-to-date clock</p> <p>The clock on the system running the bot must be accurate, synchronized to a NTP server frequently enough to avoid problems with communication to the exchanges.</p>"},{"location":"bot-usage/#bot-commands","title":"Bot commands","text":"<pre><code>usage: freqtrade [-h] [-V]\n                 {trade,create-userdir,new-config,new-strategy,download-data,convert-data,convert-trade-data,list-data,backtesting,edge,hyperopt,hyperopt-list,hyperopt-show,list-exchanges,list-hyperopts,list-markets,list-pairs,list-strategies,list-timeframes,show-trades,test-pairlist,install-ui,plot-dataframe,plot-profit,webserver}\n                 ...\n\nFree, open source crypto trading bot\n\npositional arguments:\n  {trade,create-userdir,new-config,new-strategy,download-data,convert-data,convert-trade-data,list-data,backtesting,edge,hyperopt,hyperopt-list,hyperopt-show,list-exchanges,list-hyperopts,list-markets,list-pairs,list-strategies,list-timeframes,show-trades,test-pairlist,install-ui,plot-dataframe,plot-profit,webserver}\n    trade               Trade module.\n    create-userdir      Create user-data directory.\n    new-config          Create new config\n    new-strategy        Create new strategy\n    download-data       Download backtesting data.\n    convert-data        Convert candle (OHLCV) data from one format to\n                        another.\n    convert-trade-data  Convert trade data from one format to another.\n    list-data           List downloaded data.\n    backtesting         Backtesting module.\n    edge                Edge module.\n    hyperopt            Hyperopt module.\n    hyperopt-list       List Hyperopt results\n    hyperopt-show       Show details of Hyperopt results\n    list-exchanges      Print available exchanges.\n    list-hyperopts      Print available hyperopt classes.\n    list-markets        Print markets on exchange.\n    list-pairs          Print pairs on exchange.\n    list-strategies     Print available strategies.\n    list-timeframes     Print available timeframes for the exchange.\n    show-trades         Show trades.\n    test-pairlist       Test your pairlist configuration.\n    install-ui          Install FreqUI\n    plot-dataframe      Plot candles with indicators.\n    plot-profit         Generate plot showing profits.\n    webserver           Webserver module.\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -V, --version         show program's version number and exit\n</code></pre>"},{"location":"bot-usage/#bot-trading-commands","title":"Bot trading commands","text":"<pre><code>usage: freqtrade trade [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH]\n                       [--userdir PATH] [-s NAME] [--strategy-path PATH]\n                       [--db-url PATH] [--sd-notify] [--dry-run]\n                       [--dry-run-wallet DRY_RUN_WALLET]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --db-url PATH         Override trades database URL, this is useful in custom\n                        deployments (default: `sqlite:///tradesv3.sqlite` for\n                        Live Run mode, `sqlite:///tradesv3.dryrun.sqlite` for\n                        Dry Run).\n  --sd-notify           Notify systemd service manager.\n  --dry-run             Enforce dry-run for trading (removes Exchange secrets\n                        and simulates trades).\n  --dry-run-wallet DRY_RUN_WALLET, --starting-balance DRY_RUN_WALLET\n                        Starting balance, used for backtesting / hyperopt and\n                        dry-runs.\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n\nStrategy arguments:\n  -s NAME, --strategy NAME\n                        Specify strategy class name which will be used by the\n                        bot.\n  --strategy-path PATH  Specify additional strategy lookup path.\n</code></pre>"},{"location":"bot-usage/#how-to-specify-which-configuration-file-be-used","title":"How to specify which configuration file be used?","text":"<p>The bot allows you to select which configuration file you want to use by means of the <code>-c/--config</code> command line option:</p> <pre><code>freqtrade trade -c path/far/far/away/config.json\n</code></pre> <p>Per default, the bot loads the <code>config.json</code> configuration file from the current working directory.</p>"},{"location":"bot-usage/#how-to-use-multiple-configuration-files","title":"How to use multiple configuration files?","text":"<p>The bot allows you to use multiple configuration files by specifying multiple <code>-c/--config</code> options in the command line. Configuration parameters defined in the latter configuration files override parameters with the same name defined in the previous configuration files specified in the command line earlier.</p> <p>For example, you can make a separate configuration file with your key and secret for the Exchange you use for trading, specify default configuration file with empty key and secret values while running in the Dry Mode (which does not actually require them):</p> <pre><code>freqtrade trade -c ./config.json\n</code></pre> <p>and specify both configuration files when running in the normal Live Trade Mode:</p> <pre><code>freqtrade trade -c ./config.json -c path/to/secrets/keys.config.json\n</code></pre> <p>This could help you hide your private Exchange key and Exchange secret on you local machine by setting appropriate file permissions for the file which contains actual secrets and, additionally, prevent unintended disclosure of sensitive private data when you publish examples of your configuration in the project issues or in the Internet.</p> <p>See more details on this technique with examples in the documentation page on configuration.</p>"},{"location":"bot-usage/#where-to-store-custom-data","title":"Where to store custom data","text":"<p>Freqtrade allows the creation of a user-data directory using <code>freqtrade create-userdir --userdir someDirectory</code>. This directory will look as follows:</p> <pre><code>user_data/\n\u251c\u2500\u2500 backtest_results\n\u251c\u2500\u2500 data\n\u251c\u2500\u2500 hyperopts\n\u251c\u2500\u2500 hyperopt_results\n\u251c\u2500\u2500 plot\n\u2514\u2500\u2500 strategies\n</code></pre> <p>You can add the entry \"user_data_dir\" setting to your configuration, to always point your bot to this directory. Alternatively, pass in <code>--userdir</code> to every command. The bot will fail to start if the directory does not exist, but will create necessary subdirectories.</p> <p>This directory should contain your custom strategies, custom hyperopts and hyperopt loss functions, backtesting historical data (downloaded using either backtesting command or the download script) and plot outputs.</p> <p>It is recommended to use version control to keep track of changes to your strategies.</p>"},{"location":"bot-usage/#how-to-use-strategy","title":"How to use --strategy?","text":"<p>This parameter will allow you to load your custom strategy class. To test the bot installation, you can use the <code>SampleStrategy</code> installed by the <code>create-userdir</code> subcommand (usually <code>user_data/strategy/sample_strategy.py</code>).</p> <p>The bot will search your strategy file within <code>user_data/strategies</code>. To use other directories, please read the next section about <code>--strategy-path</code>.</p> <p>To load a strategy, simply pass the class name (e.g.: <code>CustomStrategy</code>) in this parameter.</p> <p>Example: In <code>user_data/strategies</code> you have a file <code>my_awesome_strategy.py</code> which has a strategy class called <code>AwesomeStrategy</code> to load it:</p> <pre><code>freqtrade trade --strategy AwesomeStrategy\n</code></pre> <p>If the bot does not find your strategy file, it will display in an error message the reason (File not found, or errors in your code).</p> <p>Learn more about strategy file in Strategy Customization.</p>"},{"location":"bot-usage/#how-to-use-strategy-path","title":"How to use --strategy-path?","text":"<p>This parameter allows you to add an additional strategy lookup path, which gets checked before the default locations (The passed path must be a directory!):</p> <pre><code>freqtrade trade --strategy AwesomeStrategy --strategy-path /some/directory\n</code></pre>"},{"location":"bot-usage/#how-to-install-a-strategy","title":"How to install a strategy?","text":"<p>This is very simple. Copy paste your strategy file into the directory <code>user_data/strategies</code> or use <code>--strategy-path</code>. And voila, the bot is ready to use it.</p>"},{"location":"bot-usage/#how-to-use-db-url","title":"How to use --db-url?","text":"<p>When you run the bot in Dry-run mode, per default no transactions are stored in a database. If you want to store your bot actions in a DB using <code>--db-url</code>. This can also be used to specify a custom database in production mode. Example command:</p> <pre><code>freqtrade trade -c config.json --db-url sqlite:///tradesv3.dry_run.sqlite\n</code></pre>"},{"location":"bot-usage/#next-step","title":"Next step","text":"<p>The optimal strategy of the bot will change with time depending of the market trends. The next step is to Strategy Customization.</p>"},{"location":"configuration/","title":"Configure the bot","text":"<p>Freqtrade has many configurable features and possibilities. By default, these settings are configured via the configuration file (see below).</p>"},{"location":"configuration/#the-freqtrade-configuration-file","title":"The Freqtrade configuration file","text":"<p>The bot uses a set of configuration parameters during its operation that all together conform to the bot configuration. It normally reads its configuration from a file (Freqtrade configuration file).</p> <p>Per default, the bot loads the configuration from the <code>config.json</code> file, located in the current working directory.</p> <p>You can specify a different configuration file used by the bot with the <code>-c/--config</code> command-line option.</p> <p>If you used the Quick start method for installing the bot, the installation script should have already created the default configuration file (<code>config.json</code>) for you.</p> <p>If the default configuration file is not created we recommend to use <code>freqtrade new-config --config user_data/config.json</code> to generate a basic configuration file.</p> <p>The Freqtrade configuration file is to be written in JSON format.</p> <p>Additionally to the standard JSON syntax, you may use one-line <code>// ...</code> and multi-line <code>/* ... */</code> comments in your configuration files and trailing commas in the lists of parameters.</p> <p>Do not worry if you are not familiar with JSON format -- simply open the configuration file with an editor of your choice, make some changes to the parameters you need, save your changes and, finally, restart the bot or, if it was previously stopped, run it again with the changes you made to the configuration. The bot validates the syntax of the configuration file at startup and will warn you if you made any errors editing it, pointing out problematic lines.</p>"},{"location":"configuration/#environment-variables","title":"Environment variables","text":"<p>Set options in the Freqtrade configuration via environment variables. This takes priority over the corresponding value in configuration or strategy.</p> <p>Environment variables must be prefixed with  <code>FREQTRADE__</code> to be loaded to the freqtrade configuration.</p> <p><code>__</code> serves as level separator, so the format used should correspond to <code>FREQTRADE__{section}__{key}</code>. As such - an environment variable defined as  <code>export FREQTRADE__STAKE_AMOUNT=200</code> would result in <code>{stake_amount: 200}</code>.</p> <p>A more complex example might be <code>export FREQTRADE__EXCHANGE__KEY=&lt;yourExchangeKey&gt;</code> to keep your exchange key secret. This will move the value to the <code>exchange.key</code> section of the configuration. Using this scheme, all configuration settings will also be available as environment variables.</p> <p>Please note that Environment variables will overwrite corresponding settings in your configuration, but command line Arguments will always win.</p> <p>Common example:</p> <pre><code>FREQTRADE__TELEGRAM__CHAT_ID=&lt;telegramchatid&gt;\nFREQTRADE__TELEGRAM__TOKEN=&lt;telegramToken&gt;\nFREQTRADE__EXCHANGE__KEY=&lt;yourExchangeKey&gt;\nFREQTRADE__EXCHANGE__SECRET=&lt;yourExchangeSecret&gt;\n</code></pre> <p>Note</p> <p>Environment variables detected are logged at startup - so if you can't find why a value is not what you think it should be based on the configuration, make sure it's not loaded from an environment variable.</p> <p>Validate combined result</p> <p>You can use the show-config subcommand to see the final, combined configuration.</p> Loading sequence <p>Environment variables are loaded after the initial configuration. As such, you cannot provide the path to the configuration through environment variables. Please use <code>--config path/to/config.json</code> for that. This also applies to user_dir to some degree. while the user directory can be set through environment variables - the configuration will not be loaded from that location.</p>"},{"location":"configuration/#multiple-configuration-files","title":"Multiple configuration files","text":"<p>Multiple configuration files can be specified and used by the bot or the bot can read its configuration parameters from the process standard input stream.</p> <p>You can specify additional configuration files in <code>add_config_files</code>. Files specified in this parameter will be loaded and merged with the initial config file. The files are resolved relative to the initial configuration file. This is similar to using multiple <code>--config</code> parameters, but simpler in usage as you don't have to specify all files for all commands.</p> <p>Validate combined result</p> <p>You can use the show-config subcommand to see the final, combined configuration.</p> <p>Use multiple configuration files to keep secrets secret</p> <p>You can use a 2<sup>nd</sup> configuration file containing your secrets. That way you can share your \"primary\" configuration file, while still keeping your API keys for yourself. The 2<sup>nd</sup> file should only specify what you intend to override. If a key is in more than one of the configurations, then the \"last specified configuration\" wins (in the above example, <code>config-private.json</code>).</p> <p>For one-off commands, you can also use the below syntax by specifying multiple \"--config\" parameters.</p> <pre><code>freqtrade trade --config user_data/config1.json --config user_data/config-private.json &lt;...&gt;\n</code></pre> <p>The below is equivalent to the example above - but having 2 configuration files in the configuration, for easier reuse.</p> user_data/config.json<pre><code>\"add_config_files\": [\n    \"config1.json\",\n    \"config-private.json\"\n]\n</code></pre> <pre><code>freqtrade trade --config user_data/config.json &lt;...&gt;\n</code></pre> config collision handling <p>If the same configuration setting takes place in both <code>config.json</code> and <code>config-import.json</code>, then the parent configuration wins. In the below case, <code>max_open_trades</code> would be 3 after the merging - as the reusable \"import\" configuration has this key overwritten.</p> user_data/config.json<pre><code>{\n    \"max_open_trades\": 3,\n    \"stake_currency\": \"USDT\",\n    \"add_config_files\": [\n        \"config-import.json\"\n    ]\n}\n</code></pre> user_data/config-import.json<pre><code>{\n    \"max_open_trades\": 10,\n    \"stake_amount\": \"unlimited\",\n}\n</code></pre> <p>Resulting combined configuration:</p> Result<pre><code>{\n    \"max_open_trades\": 3,\n    \"stake_currency\": \"USDT\",\n    \"stake_amount\": \"unlimited\"\n}\n</code></pre> <p>If multiple files are in the <code>add_config_files</code> section, then they will be assumed to be at identical levels, having the last occurrence override the earlier config (unless a parent already defined such a key).</p>"},{"location":"configuration/#configuration-parameters","title":"Configuration parameters","text":"<p>The table below will list all configuration parameters available.</p> <p>Freqtrade can also load many options via command line (CLI) arguments (check out the commands <code>--help</code> output for details).</p>"},{"location":"configuration/#configuration-option-prevalence","title":"Configuration option prevalence","text":"<p>The prevalence for all Options is as follows:</p> <ul> <li>CLI arguments override any other option</li> <li>Environment Variables</li> <li>Configuration files are used in sequence (the last file wins) and override Strategy configurations.</li> <li>Strategy configurations are only used if they are not set via configuration or command-line arguments. These options are marked with Strategy Override in the below table.</li> </ul>"},{"location":"configuration/#parameters-table","title":"Parameters table","text":"<p>Mandatory parameters are marked as Required, which means that they are required to be set in one of the possible ways.</p> Parameter Description <code>max_open_trades</code> Required. Number of open trades your bot is allowed to have. Only one open trade per pair is possible, so the length of your pairlist is another limitation that can apply. If -1 then it is ignored (i.e. potentially unlimited open trades, limited by the pairlist). More information below. Strategy Override. Datatype: Positive integer or -1. <code>stake_currency</code> Required. Crypto-currency used for trading.  Datatype: String <code>stake_amount</code> Required. Amount of crypto-currency your bot will use for each trade. Set it to <code>\"unlimited\"</code> to allow the bot to use all available balance. More information below.  Datatype: Positive float or <code>\"unlimited\"</code>. <code>tradable_balance_ratio</code> Ratio of the total account balance the bot is allowed to trade. More information below. Defaults to <code>0.99</code> 99%). Datatype: Positive float between <code>0.1</code> and <code>1.0</code>. <code>available_capital</code> Available starting capital for the bot. Useful when running multiple bots on the same exchange account. More information below.  Datatype: Positive float. <code>amend_last_stake_amount</code> Use reduced last stake amount if necessary. More information below. Defaults to <code>false</code>. Datatype: Boolean <code>last_stake_amount_min_ratio</code> Defines minimum stake amount that has to be left and executed. Applies only to the last stake amount when it's amended to a reduced value (i.e. if <code>amend_last_stake_amount</code> is set to <code>true</code>). More information below. Defaults to <code>0.5</code>. Datatype: Float (as ratio) <code>amount_reserve_percent</code> Reserve some amount in min pair stake amount. The bot will reserve <code>amount_reserve_percent</code> + stoploss value when calculating min pair stake amount in order to avoid possible trade refusals. Defaults to <code>0.05</code> (5%). Datatype: Positive Float as ratio. <code>timeframe</code> The timeframe to use (e.g <code>1m</code>, <code>5m</code>, <code>15m</code>, <code>30m</code>, <code>1h</code> ...). Usually missing in configuration, and specified in the strategy. Strategy Override.  Datatype: String <code>fiat_display_currency</code> Fiat currency used to show your profits. More information below.  Datatype: String <code>dry_run</code> Required. Define if the bot must be in Dry Run or production mode. Defaults to <code>true</code>. Datatype: Boolean <code>dry_run_wallet</code> Define the starting amount in stake currency for the simulated wallet used by the bot running in Dry Run mode.Defaults to <code>1000</code>. Datatype: Float <code>cancel_open_orders_on_exit</code> Cancel open orders when the <code>/stop</code> RPC command is issued, <code>Ctrl+C</code> is pressed or the bot dies unexpectedly. When set to <code>true</code>, this allows you to use <code>/stop</code> to cancel unfilled and partially filled orders in the event of a market crash. It does not impact open positions. Defaults to <code>false</code>. Datatype: Boolean <code>process_only_new_candles</code> Enable processing of indicators only when new candles arrive. If false each loop populates the indicators, this will mean the same candle is processed many times creating system load but can be useful of your strategy depends on tick data not only candle. Strategy Override. Defaults to <code>true</code>. Datatype: Boolean <code>minimal_roi</code> Required. Set the threshold as ratio the bot will use to exit a trade. More information below. Strategy Override.  Datatype: Dict <code>stoploss</code> Required. Value as ratio of the stoploss used by the bot. More details in the stoploss documentation. Strategy Override.   Datatype: Float (as ratio) <code>trailing_stop</code> Enables trailing stoploss (based on <code>stoploss</code> in either configuration or strategy file). More details in the stoploss documentation. Strategy Override.  Datatype: Boolean <code>trailing_stop_positive</code> Changes stoploss once profit has been reached. More details in the stoploss documentation. Strategy Override.  Datatype: Float <code>trailing_stop_positive_offset</code> Offset on when to apply <code>trailing_stop_positive</code>. Percentage value which should be positive. More details in the stoploss documentation. Strategy Override. Defaults to <code>0.0</code> (no offset). Datatype: Float <code>trailing_only_offset_is_reached</code> Only apply trailing stoploss when the offset is reached. stoploss documentation. Strategy Override. Defaults to <code>false</code>. Datatype: Boolean <code>fee</code> Fee used during backtesting / dry-runs. Should normally not be configured, which has freqtrade fall back to the exchange default fee. Set as ratio (e.g. 0.001 = 0.1%). Fee is applied twice for each trade, once when buying, once when selling.  Datatype: Float (as ratio) <code>futures_funding_rate</code> User-specified funding rate to be used when historical funding rates are not available from the exchange. This does not overwrite real historical rates. It is recommended that this be set to 0 unless you are testing a specific coin and you understand how the funding rate will affect freqtrade's profit calculations. More information here Defaults to <code>None</code>. Datatype: Float <code>trading_mode</code> Specifies if you want to trade regularly, trade with leverage, or trade contracts whose prices are derived from matching cryptocurrency prices. leverage documentation. Defaults to <code>\"spot\"</code>. Datatype: String <code>margin_mode</code> When trading with leverage, this determines if the collateral owned by the trader will be shared or isolated to each trading pair leverage documentation.  Datatype: String <code>liquidation_buffer</code> A ratio specifying how large of a safety net to place between the liquidation price and the stoploss to prevent a position from reaching the liquidation price leverage documentation. Defaults to <code>0.05</code>. Datatype: Float Unfilled timeout <code>unfilledtimeout.entry</code> Required. How long (in minutes or seconds) the bot will wait for an unfilled entry order to complete, after which the order will be cancelled and repeated at current (new) price, as long as there is a signal. Strategy Override. Datatype: Integer <code>unfilledtimeout.exit</code> Required. How long (in minutes or seconds) the bot will wait for an unfilled exit order to complete, after which the order will be cancelled and repeated at current (new) price, as long as there is a signal. Strategy Override. Datatype: Integer <code>unfilledtimeout.unit</code> Unit to use in unfilledtimeout setting. Note: If you set unfilledtimeout.unit to \"seconds\", \"internals.process_throttle_secs\" must be inferior or equal to timeout Strategy Override.  Defaults to <code>\"minutes\"</code>. Datatype: String <code>unfilledtimeout.exit_timeout_count</code> How many times can exit orders time out. Once this number of timeouts is reached, an emergency exit is triggered. 0 to disable and allow unlimited order cancels. Strategy Override.Defaults to <code>0</code>. Datatype: Integer Pricing <code>entry_pricing.price_side</code> Select the side of the spread the bot should look at to get the entry rate. More information below. Defaults to <code>\"same\"</code>. Datatype: String (either <code>ask</code>, <code>bid</code>, <code>same</code> or <code>other</code>). <code>entry_pricing.price_last_balance</code> Required. Interpolate the bidding price. More information below. <code>entry_pricing.use_order_book</code> Enable entering using the rates in Order Book Entry.  Defaults to <code>true</code>. Datatype: Boolean <code>entry_pricing.order_book_top</code> Bot will use the top N rate in Order Book \"price_side\" to enter a trade. I.e. a value of 2 will allow the bot to pick the 2<sup>nd</sup> entry in Order Book Entry. Defaults to <code>1</code>. Datatype: Positive Integer <code>entry_pricing. check_depth_of_market.enabled</code> Do not enter if the difference of buy orders and sell orders is met in Order Book. Check market depth. Defaults to <code>false</code>. Datatype: Boolean <code>entry_pricing. check_depth_of_market.bids_to_ask_delta</code> The difference ratio of buy orders and sell orders found in Order Book. A value below 1 means sell order size is greater, while value greater than 1 means buy order size is higher. Check market depth Defaults to <code>0</code>. Datatype: Float (as ratio) <code>exit_pricing.price_side</code> Select the side of the spread the bot should look at to get the exit rate. More information below. Defaults to <code>\"same\"</code>. Datatype: String (either <code>ask</code>, <code>bid</code>, <code>same</code> or <code>other</code>). <code>exit_pricing.price_last_balance</code> Interpolate the exiting price. More information below. <code>exit_pricing.use_order_book</code> Enable exiting of open trades using Order Book Exit.  Defaults to <code>true</code>. Datatype: Boolean <code>exit_pricing.order_book_top</code> Bot will use the top N rate in Order Book \"price_side\" to exit. I.e. a value of 2 will allow the bot to pick the 2<sup>nd</sup> ask rate in Order Book ExitDefaults to <code>1</code>. Datatype: Positive Integer <code>custom_price_max_distance_ratio</code> Configure maximum distance ratio between current and custom entry or exit price. Defaults to <code>0.02</code> 2%). Datatype: Positive float TODO <code>use_exit_signal</code> Use exit signals produced by the strategy in addition to the <code>minimal_roi</code>. Setting this to false disables the usage of <code>\"exit_long\"</code> and <code>\"exit_short\"</code> columns. Has no influence on other exit methods (Stoploss, ROI, callbacks). Strategy Override. Defaults to <code>true</code>. Datatype: Boolean <code>exit_profit_only</code> Wait until the bot reaches <code>exit_profit_offset</code> before taking an exit decision. Strategy Override. Defaults to <code>false</code>. Datatype: Boolean <code>exit_profit_offset</code> Exit-signal is only active above this value. Only active in combination with <code>exit_profit_only=True</code>. Strategy Override. Defaults to <code>0.0</code>. Datatype: Float (as ratio) <code>ignore_roi_if_entry_signal</code> Do not exit if the entry signal is still active. This setting takes preference over <code>minimal_roi</code> and <code>use_exit_signal</code>. Strategy Override. Defaults to <code>false</code>. Datatype: Boolean <code>ignore_buying_expired_candle_after</code> Specifies the number of seconds until a buy signal is no longer used.  Datatype: Integer <code>order_types</code> Configure order-types depending on the action (<code>\"entry\"</code>, <code>\"exit\"</code>, <code>\"stoploss\"</code>, <code>\"stoploss_on_exchange\"</code>). More information below. Strategy Override. Datatype: Dict <code>order_time_in_force</code> Configure time in force for entry and exit orders. More information below. Strategy Override.  Datatype: Dict <code>position_adjustment_enable</code> Enables the strategy to use position adjustments (additional buys or sells). More information here.  Strategy Override. Defaults to <code>false</code>. Datatype: Boolean <code>max_entry_position_adjustment</code> Maximum additional order(s) for each open trade on top of the first entry Order. Set it to <code>-1</code> for unlimited additional orders. More information here.  Strategy Override. Defaults to <code>-1</code>. Datatype: Positive Integer or -1 Exchange <code>exchange.name</code> Required. Name of the exchange class to use.  Datatype: String <code>exchange.key</code> API key to use for the exchange. Only required when you are in production mode.Keep it in secret, do not disclose publicly. Datatype: String <code>exchange.secret</code> API secret to use for the exchange. Only required when you are in production mode.Keep it in secret, do not disclose publicly. Datatype: String <code>exchange.password</code> API password to use for the exchange. Only required when you are in production mode and for exchanges that use password for API requests.Keep it in secret, do not disclose publicly. Datatype: String <code>exchange.uid</code> API uid to use for the exchange. Only required when you are in production mode and for exchanges that use uid for API requests.Keep it in secret, do not disclose publicly. Datatype: String <code>exchange.pair_whitelist</code> List of pairs to use by the bot for trading and to check for potential trades during backtesting. Supports regex pairs as <code>.*/BTC</code>. Not used by VolumePairList. More information.  Datatype: List <code>exchange.pair_blacklist</code> List of pairs the bot must absolutely avoid for trading and backtesting. More information.  Datatype: List <code>exchange.ccxt_config</code> Additional CCXT parameters passed to both ccxt instances (sync and async). This is usually the correct place for additional ccxt configurations. Parameters may differ from exchange to exchange and are documented in the ccxt documentation. Please avoid adding exchange secrets here (use the dedicated fields instead), as they may be contained in logs.  Datatype: Dict <code>exchange.ccxt_sync_config</code> Additional CCXT parameters passed to the regular (sync) ccxt instance. Parameters may differ from exchange to exchange and are documented in the ccxt documentation Datatype: Dict <code>exchange.ccxt_async_config</code> Additional CCXT parameters passed to the async ccxt instance. Parameters may differ from exchange to exchange  and are documented in the ccxt documentation Datatype: Dict <code>exchange.markets_refresh_interval</code> The interval in minutes in which markets are reloaded. Defaults to <code>60</code> minutes. Datatype: Positive Integer <code>exchange.skip_pair_validation</code> Skip pairlist validation on startup.Defaults to <code>false</code> Datatype: Boolean <code>exchange.skip_open_order_update</code> Skips open order updates on startup should the exchange cause problems. Only relevant in live conditions.Defaults to <code>false</code> Datatype: Boolean <code>exchange.unknown_fee_rate</code> Fallback value to use when calculating trading fees. This can be useful for exchanges which have fees in non-tradable currencies. The value provided here will be multiplied with the \"fee cost\".Defaults to <code>None</code> Datatype:* float <code>exchange.log_responses</code> Log relevant exchange responses. For debug mode only - use with care.Defaults to <code>false</code> Datatype: Boolean <code>experimental.block_bad_exchanges</code> Block exchanges known to not work with freqtrade. Leave on default unless you want to test if that exchange works now. Defaults to <code>true</code>. Datatype: Boolean Plugins <code>edge.*</code> Please refer to edge configuration document for detailed explanation of all possible configuration options. <code>pairlists</code> Define one or more pairlists to be used. More information. Defaults to <code>StaticPairList</code>. Datatype: List of Dicts <code>protections</code> Define one or more protections to be used. More information.  Datatype: List of Dicts Telegram <code>telegram.enabled</code> Enable the usage of Telegram.  Datatype: Boolean <code>telegram.token</code> Your Telegram bot token. Only required if <code>telegram.enabled</code> is <code>true</code>. Keep it in secret, do not disclose publicly. Datatype: String <code>telegram.chat_id</code> Your personal Telegram account id. Only required if <code>telegram.enabled</code> is <code>true</code>. Keep it in secret, do not disclose publicly. Datatype: String <code>telegram.balance_dust_level</code> Dust-level (in stake currency) - currencies with a balance below this will not be shown by <code>/balance</code>.  Datatype: float <code>telegram.reload</code> Allow \"reload\" buttons on telegram messages. Defaults to <code>true</code>. Datatype:* boolean <code>telegram.notification_settings.*</code> Detailed notification settings. Refer to the telegram documentation for details. Datatype: dictionary <code>telegram.allow_custom_messages</code> Enable the sending of Telegram messages from strategies via the dataprovider.send_msg() function.  Datatype: Boolean Webhook <code>webhook.enabled</code> Enable usage of Webhook notifications  Datatype: Boolean <code>webhook.url</code> URL for the webhook. Only required if <code>webhook.enabled</code> is <code>true</code>. See the webhook documentation for more details.  Datatype: String <code>webhook.entry</code> Payload to send on entry. Only required if <code>webhook.enabled</code> is <code>true</code>. See the webhook documentation for more details.  Datatype: String <code>webhook.entry_cancel</code> Payload to send on entry order cancel. Only required if <code>webhook.enabled</code> is <code>true</code>. See the webhook documentation for more details.  Datatype: String <code>webhook.entry_fill</code> Payload to send on entry order filled. Only required if <code>webhook.enabled</code> is <code>true</code>. See the webhook documentation for more details.  Datatype: String <code>webhook.exit</code> Payload to send on exit. Only required if <code>webhook.enabled</code> is <code>true</code>. See the webhook documentation for more details.  Datatype: String <code>webhook.exit_cancel</code> Payload to send on exit order cancel. Only required if <code>webhook.enabled</code> is <code>true</code>. See the webhook documentation for more details.  Datatype: String <code>webhook.exit_fill</code> Payload to send on exit order filled. Only required if <code>webhook.enabled</code> is <code>true</code>. See the webhook documentation for more details.  Datatype: String <code>webhook.status</code> Payload to send on status calls. Only required if <code>webhook.enabled</code> is <code>true</code>. See the webhook documentation for more details.  Datatype: String <code>webhook.allow_custom_messages</code> Enable the sending of Webhook messages from strategies via the dataprovider.send_msg() function.  Datatype: Boolean Rest API / FreqUI / Producer-Consumer <code>api_server.enabled</code> Enable usage of API Server. See the API Server documentation for more details.  Datatype: Boolean <code>api_server.listen_ip_address</code> Bind IP address. See the API Server documentation for more details.  Datatype: IPv4 <code>api_server.listen_port</code> Bind Port. See the API Server documentation for more details. Datatype: Integer between 1024 and 65535 <code>api_server.verbosity</code> Logging verbosity. <code>info</code> will print all RPC Calls, while \"error\" will only display errors. Datatype: Enum, either <code>info</code> or <code>error</code>. Defaults to <code>info</code>. <code>api_server.username</code> Username for API server. See the API Server documentation for more details. Keep it in secret, do not disclose publicly. Datatype: String <code>api_server.password</code> Password for API server. See the API Server documentation for more details. Keep it in secret, do not disclose publicly. Datatype: String <code>api_server.ws_token</code> API token for the Message WebSocket. See the API Server documentation for more details.  Keep it in secret, do not disclose publicly. Datatype: String <code>bot_name</code> Name of the bot. Passed via API to a client - can be shown to distinguish / name bots. Defaults to <code>freqtrade</code> Datatype: String <code>external_message_consumer</code> Enable Producer/Consumer mode for more details.  Datatype: Dict Other <code>initial_state</code> Defines the initial application state. If set to stopped, then the bot has to be explicitly started via <code>/start</code> RPC command. Defaults to <code>stopped</code>. Datatype: Enum, either <code>stopped</code> or <code>running</code> <code>force_entry_enable</code> Enables the RPC Commands to force a Trade entry. More information below.  Datatype: Boolean <code>disable_dataframe_checks</code> Disable checking the OHLCV dataframe returned from the strategy methods for correctness. Only use when intentionally changing the dataframe and understand what you are doing. Strategy Override. Defaults to <code>False</code>.  Datatype: Boolean <code>internals.process_throttle_secs</code> Set the process throttle, or minimum loop duration for one bot iteration loop. Value in second. Defaults to <code>5</code> seconds. Datatype: Positive Integer <code>internals.heartbeat_interval</code> Print heartbeat message every N seconds. Set to 0 to disable heartbeat messages. Defaults to <code>60</code> seconds. Datatype: Positive Integer or 0 <code>internals.sd_notify</code> Enables use of the sd_notify protocol to tell systemd service manager about changes in the bot state and issue keep-alive pings. See here for more details.  Datatype: Boolean <code>strategy</code> Required Defines Strategy class to use. Recommended to be set via <code>--strategy NAME</code>.  Datatype: ClassName <code>strategy_path</code> Adds an additional strategy lookup path (must be a directory).  Datatype: String <code>recursive_strategy_search</code> Set to <code>true</code> to recursively search sub-directories inside <code>user_data/strategies</code> for a strategy.  Datatype: Boolean <code>user_data_dir</code> Directory containing user data.  Defaults to <code>./user_data/</code>.  Datatype: String <code>db_url</code> Declares database URL to use. NOTE: This defaults to <code>sqlite:///tradesv3.dryrun.sqlite</code> if <code>dry_run</code> is <code>true</code>, and to <code>sqlite:///tradesv3.sqlite</code> for production instances.  Datatype: String, SQLAlchemy connect string <code>logfile</code> Specifies logfile name. Uses a rolling strategy for log file rotation for 10 files with the 1MB limit per file.  Datatype: String <code>add_config_files</code> Additional config files. These files will be loaded and merged with the current config file. The files are resolved relative to the initial file. Defaults to <code>[]</code>.  Datatype: List of strings <code>dataformat_ohlcv</code> Data format to use to store historical candle (OHLCV) data.  Defaults to <code>feather</code>.  Datatype: String <code>dataformat_trades</code> Data format to use to store historical trades data.  Defaults to <code>feather</code>.  Datatype: String <code>reduce_df_footprint</code> Recast all numeric columns to float32/int32, with the objective of reducing ram/disk usage (and decreasing train/inference timing in FreqAI). (Currently only affects FreqAI use-cases)  Datatype: Boolean.  Default: <code>False</code>."},{"location":"configuration/#parameters-in-the-strategy","title":"Parameters in the strategy","text":"<p>The following parameters can be set in the configuration file or strategy. Values set in the configuration file always overwrite values set in the strategy.</p> <ul> <li><code>minimal_roi</code></li> <li><code>timeframe</code></li> <li><code>stoploss</code></li> <li><code>max_open_trades</code></li> <li><code>trailing_stop</code></li> <li><code>trailing_stop_positive</code></li> <li><code>trailing_stop_positive_offset</code></li> <li><code>trailing_only_offset_is_reached</code></li> <li><code>use_custom_stoploss</code></li> <li><code>process_only_new_candles</code></li> <li><code>order_types</code></li> <li><code>order_time_in_force</code></li> <li><code>unfilledtimeout</code></li> <li><code>disable_dataframe_checks</code></li> <li><code>use_exit_signal</code></li> <li><code>exit_profit_only</code></li> <li><code>exit_profit_offset</code></li> <li><code>ignore_roi_if_entry_signal</code></li> <li><code>ignore_buying_expired_candle_after</code></li> <li><code>position_adjustment_enable</code></li> <li><code>max_entry_position_adjustment</code></li> </ul>"},{"location":"configuration/#configuring-amount-per-trade","title":"Configuring amount per trade","text":"<p>There are several methods to configure how much of the stake currency the bot will use to enter a trade. All methods respect the available balance configuration as explained below.</p>"},{"location":"configuration/#minimum-trade-stake","title":"Minimum trade stake","text":"<p>The minimum stake amount will depend on exchange and pair and is usually listed in the exchange support pages.</p> <p>Assuming the minimum tradable amount for XRP/USD is 20 XRP (given by the exchange), and the price is 0.6\\(, the minimum stake amount to buy this pair is <code>20 * 0.6 ~= 12</code>. This exchange has also a limit on USD - where all orders must be &gt; 10\\) - which however does not apply in this case.</p> <p>To guarantee safe execution, freqtrade will not allow buying with a stake-amount of 10.1$, instead, it'll make sure that there's enough space to place a stoploss below the pair (+ an offset, defined by <code>amount_reserve_percent</code>, which defaults to 5%).</p> <p>With a reserve of 5%, the minimum stake amount would be ~12.6$ (<code>12 * (1 + 0.05)</code>). If we take into account a stoploss of 10% on top of that - we'd end up with a value of ~14$ (<code>12.6 / (1 - 0.1)</code>).</p> <p>To limit this calculation in case of large stoploss values, the calculated minimum stake-limit will never be more than 50% above the real limit.</p> <p>Warning</p> <p>Since the limits on exchanges are usually stable and are not updated often, some pairs can show pretty high minimum limits, simply because the price increased a lot since the last limit adjustment by the exchange. Freqtrade adjusts the stake-amount to this value, unless it's &gt; 30% more than the calculated/desired stake-amount - in which case the trade is rejected.</p>"},{"location":"configuration/#tradable-balance","title":"Tradable balance","text":"<p>By default, the bot assumes that the <code>complete amount - 1%</code> is at it's disposal, and when using dynamic stake amount, it will split the complete balance into <code>max_open_trades</code> buckets per trade. Freqtrade will reserve 1% for eventual fees when entering a trade and will therefore not touch that by default.</p> <p>You can configure the \"untouched\" amount by using the <code>tradable_balance_ratio</code> setting.</p> <p>For example, if you have 10 ETH available in your wallet on the exchange and <code>tradable_balance_ratio=0.5</code> (which is 50%), then the bot will use a maximum amount of 5 ETH for trading and considers this as an available balance. The rest of the wallet is untouched by the trades.</p> <p>Danger</p> <p>This setting should not be used when running multiple bots on the same account. Please look at Available Capital to the bot instead.</p> <p>Warning</p> <p>The <code>tradable_balance_ratio</code> setting applies to the current balance (free balance + tied up in trades). Therefore, assuming the starting balance of 1000, a configuration with <code>tradable_balance_ratio=0.99</code> will not guarantee that 10 currency units will always remain available on the exchange. For example, the free amount may reduce to 5 units if the total balance is reduced to 500 (either by a losing streak or by withdrawing balance).</p>"},{"location":"configuration/#assign-available-capital","title":"Assign available Capital","text":"<p>To fully utilize compounding profits when using multiple bots on the same exchange account, you'll want to limit each bot to a certain starting balance. This can be accomplished by setting <code>available_capital</code> to the desired starting balance.</p> <p>Assuming your account has 10000 USDT and you want to run 2 different strategies on this exchange. You'd set <code>available_capital=5000</code> - granting each bot an initial capital of 5000 USDT. The bot will then split this starting balance equally into <code>max_open_trades</code> buckets. Profitable trades will result in increased stake-sizes for this bot - without affecting the stake-sizes of the other bot.</p> <p>Adjusting <code>available_capital</code> requires reloading the configuration to take effect. Adjusting the <code>available_capital</code> adds the difference between the previous <code>available_capital</code> and the new <code>available_capital</code>. Decreasing the available capital when trades are open doesn't exit the trades. The difference is returned to the wallet when the trades conclude. The outcome of this differs depending on the price movement between the adjustment and exiting the trades.</p> <p>Incompatible with <code>tradable_balance_ratio</code></p> <p>Setting this option will replace any configuration of <code>tradable_balance_ratio</code>.</p>"},{"location":"configuration/#amend-last-stake-amount","title":"Amend last stake amount","text":"<p>Assuming we have the tradable balance of 1000 USDT, <code>stake_amount=400</code>, and <code>max_open_trades=3</code>. The bot would open 2 trades and will be unable to fill the last trading slot, since the requested 400 USDT are no longer available since 800 USDT are already tied in other trades.</p> <p>To overcome this, the option <code>amend_last_stake_amount</code> can be set to <code>True</code>, which will enable the bot to reduce stake_amount to the available balance to fill the last trade slot.</p> <p>In the example above this would mean:</p> <ul> <li>Trade1: 400 USDT</li> <li>Trade2: 400 USDT</li> <li>Trade3: 200 USDT</li> </ul> <p>Note</p> <p>This option only applies with Static stake amount - since Dynamic stake amount divides the balances evenly.</p> <p>Note</p> <p>The minimum last stake amount can be configured using <code>last_stake_amount_min_ratio</code> - which defaults to 0.5 (50%). This means that the minimum stake amount that's ever used is <code>stake_amount * 0.5</code>. This avoids very low stake amounts, that are close to the minimum tradable amount for the pair and can be refused by the exchange.</p>"},{"location":"configuration/#static-stake-amount","title":"Static stake amount","text":"<p>The <code>stake_amount</code> configuration statically configures the amount of stake-currency your bot will use for each trade.</p> <p>The minimal configuration value is 0.0001, however, please check your exchange's trading minimums for the stake currency you're using to avoid problems.</p> <p>This setting works in combination with <code>max_open_trades</code>. The maximum capital engaged in trades is <code>stake_amount * max_open_trades</code>. For example, the bot will at most use (0.05 BTC x 3) = 0.15 BTC, assuming a configuration of <code>max_open_trades=3</code> and <code>stake_amount=0.05</code>.</p> <p>Note</p> <p>This setting respects the available balance configuration.</p>"},{"location":"configuration/#dynamic-stake-amount","title":"Dynamic stake amount","text":"<p>Alternatively, you can use a dynamic stake amount, which will use the available balance on the exchange, and divide that equally by the number of allowed trades (<code>max_open_trades</code>).</p> <p>To configure this, set <code>stake_amount=\"unlimited\"</code>. We also recommend to set <code>tradable_balance_ratio=0.99</code> (99%) - to keep a minimum balance for eventual fees.</p> <p>In this case a trade amount is calculated as:</p> <pre><code>currency_balance / (max_open_trades - current_open_trades)\n</code></pre> <p>To allow the bot to trade all the available <code>stake_currency</code> in your account (minus <code>tradable_balance_ratio</code>) set</p> <pre><code>\"stake_amount\" : \"unlimited\",\n\"tradable_balance_ratio\": 0.99,\n</code></pre> <p>Compounding profits</p> <p>This configuration will allow increasing/decreasing stakes depending on the performance of the bot (lower stake if the bot is losing, higher stakes if the bot has a winning record since higher balances are available), and will result in profit compounding.</p> <p>When using Dry-Run Mode</p> <p>When using <code>\"stake_amount\" : \"unlimited\",</code> in combination with Dry-Run, Backtesting or Hyperopt, the balance will be simulated starting with a stake of <code>dry_run_wallet</code> which will evolve. It is therefore important to set <code>dry_run_wallet</code> to a sensible value (like 0.05 or 0.01 for BTC and 1000 or 100 for USDT, for example), otherwise, it may simulate trades with 100 BTC (or more) or 0.05 USDT (or less) at once - which may not correspond to your real available balance or is less than the exchange minimal limit for the order amount for the stake currency.</p>"},{"location":"configuration/#dynamic-stake-amount-with-position-adjustment","title":"Dynamic stake amount with position adjustment","text":"<p>When you want to use position adjustment with unlimited stakes, you must also implement <code>custom_stake_amount</code> to a return a value depending on your strategy. Typical value would be in the range of 25% - 50% of the proposed stakes, but depends highly on your strategy and how much you wish to leave into the wallet as position adjustment buffer.</p> <p>For example if your position adjustment assumes it can do 2 additional buys with the same stake amounts then your buffer should be 66.6667% of the initially proposed unlimited stake amount.</p> <p>Or another example if your position adjustment assumes it can do 1 additional buy with 3x the original stake amount then <code>custom_stake_amount</code> should return 25% of proposed stake amount and leave 75% for possible later position adjustments.</p>"},{"location":"configuration/#prices-used-for-orders","title":"Prices used for orders","text":"<p>Prices for regular orders can be controlled via the parameter structures <code>entry_pricing</code> for trade entries and <code>exit_pricing</code> for trade exits. Prices are always retrieved right before an order is placed, either by querying the exchange tickers or by using the orderbook data.</p> <p>Note</p> <p>Orderbook data used by Freqtrade are the data retrieved from exchange by the ccxt's function <code>fetch_order_book()</code>, i.e. are usually data from the L2-aggregated orderbook, while the ticker data are the structures returned by the ccxt's <code>fetch_ticker()</code>/<code>fetch_tickers()</code> functions. Refer to the ccxt library documentation for more details.</p> <p>Using market orders</p> <p>Please read the section Market order pricing section when using market orders.</p>"},{"location":"configuration/#entry-price","title":"Entry price","text":""},{"location":"configuration/#enter-price-side","title":"Enter price side","text":"<p>The configuration setting <code>entry_pricing.price_side</code> defines the side of the orderbook the bot looks for when buying.</p> <p>The following displays an orderbook.</p> <pre><code>...\n103\n102\n101  # ask\n-------------Current spread\n99   # bid\n98\n97\n...\n</code></pre> <p>If <code>entry_pricing.price_side</code> is set to <code>\"bid\"</code>, then the bot will use 99 as entry price. In line with that, if <code>entry_pricing.price_side</code> is set to <code>\"ask\"</code>, then the bot will use 101 as entry price.</p> <p>Depending on the order direction (long/short), this will lead to different results. Therefore we recommend to use <code>\"same\"</code> or <code>\"other\"</code> for this configuration instead. This would result in the following pricing matrix:</p> direction Order setting price crosses spread long buy ask 101 yes long buy bid 99 no long buy same 99 no long buy other 101 yes short sell ask 101 no short sell bid 99 yes short sell same 101 no short sell other 99 yes <p>Using the other side of the orderbook often guarantees quicker filled orders, but the bot can also end up paying more than what would have been necessary. Taker fees instead of maker fees will most likely apply even when using limit buy orders. Also, prices at the \"other\" side of the spread are higher than prices at the \"bid\" side in the orderbook, so the order behaves similar to a market order (however with a maximum price).</p>"},{"location":"configuration/#entry-price-with-orderbook-enabled","title":"Entry price with Orderbook enabled","text":"<p>When entering a trade with the orderbook enabled (<code>entry_pricing.use_order_book=True</code>), Freqtrade fetches the <code>entry_pricing.order_book_top</code> entries from the orderbook and uses the entry specified as <code>entry_pricing.order_book_top</code> on the configured side (<code>entry_pricing.price_side</code>) of the orderbook. 1 specifies the topmost entry in the orderbook, while 2 would use the 2<sup>nd</sup> entry in the orderbook, and so on.</p>"},{"location":"configuration/#entry-price-without-orderbook-enabled","title":"Entry price without Orderbook enabled","text":"<p>The following section uses <code>side</code> as the configured <code>entry_pricing.price_side</code> (defaults to <code>\"same\"</code>).</p> <p>When not using orderbook (<code>entry_pricing.use_order_book=False</code>), Freqtrade uses the best <code>side</code> price from the ticker if it's below the <code>last</code> traded price from the ticker. Otherwise (when the <code>side</code> price is above the <code>last</code> price), it calculates a rate between <code>side</code> and <code>last</code> price based on <code>entry_pricing.price_last_balance</code>.</p> <p>The <code>entry_pricing.price_last_balance</code> configuration parameter controls this. A value of <code>0.0</code> will use <code>side</code> price, while <code>1.0</code> will use the <code>last</code> price and values between those interpolate between ask and last price.</p>"},{"location":"configuration/#check-depth-of-market","title":"Check depth of market","text":"<p>When check depth of market is enabled (<code>entry_pricing.check_depth_of_market.enabled=True</code>), the entry signals are filtered based on the orderbook depth (sum of all amounts) for each orderbook side.</p> <p>Orderbook <code>bid</code> (buy) side depth is then divided by the orderbook <code>ask</code> (sell) side depth and the resulting delta is compared to the value of the <code>entry_pricing.check_depth_of_market.bids_to_ask_delta</code> parameter. The entry order is only executed if the orderbook delta is greater than or equal to the configured delta value.</p> <p>Note</p> <p>A delta value below 1 means that <code>ask</code> (sell) orderbook side depth is greater than the depth of the <code>bid</code> (buy) orderbook side, while a value greater than 1 means opposite (depth of the buy side is higher than the depth of the sell side).</p>"},{"location":"configuration/#exit-price","title":"Exit price","text":""},{"location":"configuration/#exit-price-side","title":"Exit price side","text":"<p>The configuration setting <code>exit_pricing.price_side</code> defines the side of the spread the bot looks for when exiting a trade.</p> <p>The following displays an orderbook:</p> <pre><code>...\n103\n102\n101  # ask\n-------------Current spread\n99   # bid\n98\n97\n...\n</code></pre> <p>If <code>exit_pricing.price_side</code> is set to <code>\"ask\"</code>, then the bot will use 101 as exiting price. In line with that, if <code>exit_pricing.price_side</code> is set to <code>\"bid\"</code>, then the bot will use 99 as exiting price.</p> <p>Depending on the order direction (long/short), this will lead to different results. Therefore we recommend to use <code>\"same\"</code> or <code>\"other\"</code> for this configuration instead. This would result in the following pricing matrix:</p> Direction Order setting price crosses spread long sell ask 101 no long sell bid 99 yes long sell same 101 no long sell other 99 yes short buy ask 101 yes short buy bid 99 no short buy same 99 no short buy other 101 yes"},{"location":"configuration/#exit-price-with-orderbook-enabled","title":"Exit price with Orderbook enabled","text":"<p>When exiting with the orderbook enabled (<code>exit_pricing.use_order_book=True</code>), Freqtrade fetches the <code>exit_pricing.order_book_top</code> entries in the orderbook and uses the entry specified as <code>exit_pricing.order_book_top</code> from the configured side (<code>exit_pricing.price_side</code>) as trade exit price.</p> <p>1 specifies the topmost entry in the orderbook, while 2 would use the 2<sup>nd</sup> entry in the orderbook, and so on.</p>"},{"location":"configuration/#exit-price-without-orderbook-enabled","title":"Exit price without Orderbook enabled","text":"<p>The following section uses <code>side</code> as the configured <code>exit_pricing.price_side</code> (defaults to <code>\"ask\"</code>).</p> <p>When not using orderbook (<code>exit_pricing.use_order_book=False</code>), Freqtrade uses the best <code>side</code> price from the ticker if it's above the <code>last</code> traded price from the ticker. Otherwise (when the <code>side</code> price is below the <code>last</code> price), it calculates a rate between <code>side</code> and <code>last</code> price based on <code>exit_pricing.price_last_balance</code>.</p> <p>The <code>exit_pricing.price_last_balance</code> configuration parameter controls this. A value of <code>0.0</code> will use <code>side</code> price, while <code>1.0</code> will use the last price and values between those interpolate between <code>side</code> and last price.</p>"},{"location":"configuration/#market-order-pricing","title":"Market order pricing","text":"<p>When using market orders, prices should be configured to use the \"correct\" side of the orderbook to allow realistic pricing detection. Assuming both entry and exits are using market orders, a configuration similar to the following must be used</p> <pre><code>  \"order_types\": {\n    \"entry\": \"market\",\n    \"exit\": \"market\"\n    // ...\n  },\n  \"entry_pricing\": {\n    \"price_side\": \"other\",\n    // ...\n  },\n  \"exit_pricing\":{\n    \"price_side\": \"other\",\n    // ...\n  },\n</code></pre> <p>Obviously, if only one side is using limit orders, different pricing combinations can be used.</p>"},{"location":"configuration/#understand-minimal_roi","title":"Understand minimal_roi","text":"<p>The <code>minimal_roi</code> configuration parameter is a JSON object where the key is a duration in minutes and the value is the minimum ROI as a ratio. See the example below:</p> <pre><code>\"minimal_roi\": {\n    \"40\": 0.0,    # Exit after 40 minutes if the profit is not negative\n    \"30\": 0.01,   # Exit after 30 minutes if there is at least 1% profit\n    \"20\": 0.02,   # Exit after 20 minutes if there is at least 2% profit\n    \"0\":  0.04    # Exit immediately if there is at least 4% profit\n},\n</code></pre> <p>Most of the strategy files already include the optimal <code>minimal_roi</code> value. This parameter can be set in either Strategy or Configuration file. If you use it in the configuration file, it will override the <code>minimal_roi</code> value from the strategy file. If it is not set in either Strategy or Configuration, a default of 1000% <code>{\"0\": 10}</code> is used, and minimal ROI is disabled unless your trade generates 1000% profit.</p> <p>Special case to forceexit after a specific time</p> <p>A special case presents using <code>\"&lt;N&gt;\": -1</code> as ROI. This forces the bot to exit a trade after N Minutes, no matter if it's positive or negative, so represents a time-limited force-exit.</p>"},{"location":"configuration/#understand-force_entry_enable","title":"Understand force_entry_enable","text":"<p>The <code>force_entry_enable</code> configuration parameter enables the usage of force-enter (<code>/forcelong</code>, <code>/forceshort</code>) commands via Telegram and REST API. For security reasons, it's disabled by default, and freqtrade will show a warning message on startup if enabled. For example, you can send <code>/forceenter ETH/BTC</code> to the bot, which will result in freqtrade buying the pair and holds it until a regular exit-signal (ROI, stoploss, /forceexit) appears.</p> <p>This can be dangerous with some strategies, so use with care.</p> <p>See the telegram documentation for details on usage.</p>"},{"location":"configuration/#ignoring-expired-candles","title":"Ignoring expired candles","text":"<p>When working with larger timeframes (for example 1h or more) and using a low <code>max_open_trades</code> value, the last candle can be processed as soon as a trade slot becomes available. When processing the last candle, this can lead to a situation where it may not be desirable to use the buy signal on that candle. For example, when using a condition in your strategy where you use a cross-over, that point may have passed too long ago for you to start a trade on it.</p> <p>In these situations, you can enable the functionality to ignore candles that are beyond a specified period by setting <code>ignore_buying_expired_candle_after</code> to a positive number, indicating the number of seconds after which the buy signal becomes expired.</p> <p>For example, if your strategy is using a 1h timeframe, and you only want to buy within the first 5 minutes when a new candle comes in, you can add the following configuration to your strategy:</p> <pre><code>  {\n    //...\n    \"ignore_buying_expired_candle_after\": 300,\n    // ...\n  }\n</code></pre> <p>Note</p> <p>This setting resets with each new candle, so it will not prevent sticking-signals from executing on the 2<sup>nd</sup> or 3<sup>rd</sup> candle they're active. Best use a \"trigger\" selector for buy signals, which are only active for one candle.</p>"},{"location":"configuration/#understand-order_types","title":"Understand order_types","text":"<p>The <code>order_types</code> configuration parameter maps actions (<code>entry</code>, <code>exit</code>, <code>stoploss</code>, <code>emergency_exit</code>, <code>force_exit</code>, <code>force_entry</code>) to order-types (<code>market</code>, <code>limit</code>, ...) as well as configures stoploss to be on the exchange and defines stoploss on exchange update interval in seconds.</p> <p>This allows to enter using limit orders, exit using limit-orders, and create stoplosses using market orders. It also allows to set the stoploss \"on exchange\" which means stoploss order would be placed immediately once the buy order is fulfilled.</p> <p><code>order_types</code> set in the configuration file overwrites values set in the strategy as a whole, so you need to configure the whole <code>order_types</code> dictionary in one place.</p> <p>If this is configured, the following 4 values (<code>entry</code>, <code>exit</code>, <code>stoploss</code> and <code>stoploss_on_exchange</code>) need to be present, otherwise, the bot will fail to start.</p> <p>For information on (<code>emergency_exit</code>,<code>force_exit</code>, <code>force_entry</code>, <code>stoploss_on_exchange</code>,<code>stoploss_on_exchange_interval</code>,<code>stoploss_on_exchange_limit_ratio</code>) please see stop loss documentation stop loss on exchange</p> <p>Syntax for Strategy:</p> <pre><code>order_types = {\n    \"entry\": \"limit\",\n    \"exit\": \"limit\",\n    \"emergency_exit\": \"market\",\n    \"force_entry\": \"market\",\n    \"force_exit\": \"market\",\n    \"stoploss\": \"market\",\n    \"stoploss_on_exchange\": False,\n    \"stoploss_on_exchange_interval\": 60,\n    \"stoploss_on_exchange_limit_ratio\": 0.99,\n}\n</code></pre> <p>Configuration:</p> <pre><code>\"order_types\": {\n    \"entry\": \"limit\",\n    \"exit\": \"limit\",\n    \"emergency_exit\": \"market\",\n    \"force_entry\": \"market\",\n    \"force_exit\": \"market\",\n    \"stoploss\": \"market\",\n    \"stoploss_on_exchange\": false,\n    \"stoploss_on_exchange_interval\": 60\n}\n</code></pre> <p>Market order support</p> <p>Not all exchanges support \"market\" orders. The following message will be shown if your exchange does not support market orders: <code>\"Exchange &lt;yourexchange&gt; does not support market orders.\"</code> and the bot will refuse to start.</p> <p>Using market orders</p> <p>Please carefully read the section Market order pricing section when using market orders.</p> <p>Stoploss on exchange</p> <p><code>order_types.stoploss_on_exchange_interval</code> is not mandatory. Do not change its value if you are unsure of what you are doing. For more information about how stoploss works please refer to the stoploss documentation.</p> <p>If <code>order_types.stoploss_on_exchange</code> is enabled and the stoploss is cancelled manually on the exchange, then the bot will create a new stoploss order.</p> <p>Warning: order_types.stoploss_on_exchange failures</p> <p>If stoploss on exchange creation fails for some reason, then an \"emergency exit\" is initiated. By default, this will exit the trade using a market order. The order-type for the emergency-exit can be changed by setting the <code>emergency_exit</code> value in the <code>order_types</code> dictionary - however, this is not advised.</p>"},{"location":"configuration/#understand-order_time_in_force","title":"Understand order_time_in_force","text":"<p>The <code>order_time_in_force</code> configuration parameter defines the policy by which the order is executed on the exchange. Three commonly used time in force are:</p> <p>GTC (Good Till Canceled):</p> <p>This is most of the time the default time in force. It means the order will remain on exchange till it is cancelled by the user. It can be fully or partially fulfilled. If partially fulfilled, the remaining will stay on the exchange till cancelled.</p> <p>FOK (Fill Or Kill):</p> <p>It means if the order is not executed immediately AND fully then it is cancelled by the exchange.</p> <p>IOC (Immediate Or Canceled):</p> <p>It is the same as FOK (above) except it can be partially fulfilled. The remaining part is automatically cancelled by the exchange.</p> <p>PO (Post only):</p> <p>Post only order. The order is either placed as a maker order, or it is canceled. This means the order must be placed on orderbook for at least time in an unfilled state.</p>"},{"location":"configuration/#time_in_force-config","title":"time_in_force config","text":"<p>The <code>order_time_in_force</code> parameter contains a dict with entry and exit time in force policy values. This can be set in the configuration file or in the strategy. Values set in the configuration file overwrites values set in the strategy.</p> <p>The possible values are: <code>GTC</code> (default), <code>FOK</code> or <code>IOC</code>.</p> <pre><code>\"order_time_in_force\": {\n    \"entry\": \"GTC\",\n    \"exit\": \"GTC\"\n},\n</code></pre> <p>Warning</p> <p>This is ongoing work. For now, it is supported only for binance, gate and kucoin. Please don't change the default value unless you know what you are doing and have researched the impact of using different values for your particular exchange.</p>"},{"location":"configuration/#fiat-conversion","title":"Fiat conversion","text":"<p>Freqtrade uses the Coingecko API to convert the coin value to it's corresponding fiat value for the Telegram reports. The FIAT currency can be set in the configuration file as <code>fiat_display_currency</code>.</p> <p>Removing <code>fiat_display_currency</code> completely from the configuration will skip initializing coingecko, and will not show any FIAT currency conversion. This has no importance for the correct functioning of the bot.</p>"},{"location":"configuration/#what-values-can-be-used-for-fiat_display_currency","title":"What values can be used for fiat_display_currency?","text":"<p>The <code>fiat_display_currency</code> configuration parameter sets the base currency to use for the conversion from coin to fiat in the bot Telegram reports.</p> <p>The valid values are:</p> <pre><code>\"AUD\", \"BRL\", \"CAD\", \"CHF\", \"CLP\", \"CNY\", \"CZK\", \"DKK\", \"EUR\", \"GBP\", \"HKD\", \"HUF\", \"IDR\", \"ILS\", \"INR\", \"JPY\", \"KRW\", \"MXN\", \"MYR\", \"NOK\", \"NZD\", \"PHP\", \"PKR\", \"PLN\", \"RUB\", \"SEK\", \"SGD\", \"THB\", \"TRY\", \"TWD\", \"ZAR\", \"USD\"\n</code></pre> <p>In addition to fiat currencies, a range of crypto currencies is supported.</p> <p>The valid values are:</p> <pre><code>\"BTC\", \"ETH\", \"XRP\", \"LTC\", \"BCH\", \"BNB\"\n</code></pre>"},{"location":"configuration/#coingecko-rate-limit-problems","title":"Coingecko Rate limit problems","text":"<p>On some IP ranges, coingecko is heavily rate-limiting. In such cases, you may want to add your coingecko API key to the configuration.</p> <pre><code>{\n    \"fiat_display_currency\": \"USD\",\n    \"coingecko\": {\n        \"api_key\": \"your-api\",\n        \"is_demo\": true\n    }\n}\n</code></pre> <p>Freqtrade supports both Demo and Pro coingecko API keys.</p> <p>The Coingecko API key is NOT required for the bot to function correctly. It is only used for the conversion of coin to fiat in the Telegram reports, which usually also work without API key.</p>"},{"location":"configuration/#using-dry-run-mode","title":"Using Dry-run mode","text":"<p>We recommend starting the bot in the Dry-run mode to see how your bot will behave and what is the performance of your strategy. In the Dry-run mode, the bot does not engage your money. It only runs a live simulation without creating trades on the exchange.</p> <ol> <li>Edit your <code>config.json</code> configuration file.</li> <li>Switch <code>dry-run</code> to <code>true</code> and specify <code>db_url</code> for a persistence database.</li> </ol> <pre><code>\"dry_run\": true,\n\"db_url\": \"sqlite:///tradesv3.dryrun.sqlite\",\n</code></pre> <ol> <li>Remove your Exchange API key and secret (change them by empty values or fake credentials):</li> </ol> <pre><code>\"exchange\": {\n    \"name\": \"binance\",\n    \"key\": \"key\",\n    \"secret\": \"secret\",\n    ...\n}\n</code></pre> <p>Once you will be happy with your bot performance running in the Dry-run mode, you can switch it to production mode.</p> <p>Note</p> <p>A simulated wallet is available during dry-run mode and will assume a starting capital of <code>dry_run_wallet</code> (defaults to 1000).</p>"},{"location":"configuration/#considerations-for-dry-run","title":"Considerations for dry-run","text":"<ul> <li>API-keys may or may not be provided. Only Read-Only operations (i.e. operations that do not alter account state) on the exchange are performed in dry-run mode.</li> <li>Wallets (<code>/balance</code>) are simulated based on <code>dry_run_wallet</code>.</li> <li>Orders are simulated, and will not be posted to the exchange.</li> <li>Market orders fill based on orderbook volume the moment the order is placed.</li> <li>Limit orders fill once the price reaches the defined level - or time out based on <code>unfilledtimeout</code> settings.</li> <li>Limit orders will be converted to market orders if they cross the price by more than 1%.</li> <li>In combination with <code>stoploss_on_exchange</code>, the stop_loss price is assumed to be filled.</li> <li>Open orders (not trades, which are stored in the database) are kept open after bot restarts, with the assumption that they were not filled while being offline.</li> </ul>"},{"location":"configuration/#switch-to-production-mode","title":"Switch to production mode","text":"<p>In production mode, the bot will engage your money. Be careful, since a wrong strategy can lose all your money. Be aware of what you are doing when you run it in production mode.</p> <p>When switching to Production mode, please make sure to use a different / fresh database to avoid dry-run trades messing with your exchange money and eventually tainting your statistics.</p>"},{"location":"configuration/#setup-your-exchange-account","title":"Setup your exchange account","text":"<p>You will need to create API Keys (usually you get <code>key</code> and <code>secret</code>, some exchanges require an additional <code>password</code>) from the Exchange website and you'll need to insert this into the appropriate fields in the configuration or when asked by the <code>freqtrade new-config</code> command. API Keys are usually only required for live trading (trading for real money, bot running in \"production mode\", executing real orders on the exchange) and are not required for the bot running in dry-run (trade simulation) mode. When you set up the bot in dry-run mode, you may fill these fields with empty values.</p>"},{"location":"configuration/#to-switch-your-bot-in-production-mode","title":"To switch your bot in production mode","text":"<p>Edit your <code>config.json</code>  file.</p> <p>Switch dry-run to false and don't forget to adapt your database URL if set:</p> <pre><code>\"dry_run\": false,\n</code></pre> <p>Insert your Exchange API key (change them by fake API keys):</p> <pre><code>{\n    \"exchange\": {\n        \"name\": \"binance\",\n        \"key\": \"af8ddd35195e9dc500b9a6f799f6f5c93d89193b\",\n        \"secret\": \"08a9dc6db3d7b53e1acebd9275677f4b0a04f1a5\",\n        //\"password\": \"\", // Optional, not needed by all exchanges)\n        // ...\n    }\n    //...\n}\n</code></pre> <p>You should also make sure to read the Exchanges section of the documentation to be aware of potential configuration details specific to your exchange.</p> <p>Keep your secrets secret</p> <p>To keep your secrets secret, we recommend using a 2<sup>nd</sup> configuration for your API keys. Simply use the above snippet in a new configuration file (e.g. <code>config-private.json</code>) and keep your settings in this file. You can then start the bot with <code>freqtrade trade --config user_data/config.json --config user_data/config-private.json &lt;...&gt;</code> to have your keys loaded.</p> <p>NEVER share your private configuration file or your exchange keys with anyone!</p>"},{"location":"configuration/#using-proxy-with-freqtrade","title":"Using proxy with Freqtrade","text":"<p>To use a proxy with freqtrade, export your proxy settings using the variables <code>\"HTTP_PROXY\"</code> and <code>\"HTTPS_PROXY\"</code> set to the appropriate values. This will have the proxy settings applied to everything (telegram, coingecko, ...) except for exchange requests.</p> <pre><code>export HTTP_PROXY=\"http://addr:port\"\nexport HTTPS_PROXY=\"http://addr:port\"\nfreqtrade\n</code></pre>"},{"location":"configuration/#proxy-exchange-requests","title":"Proxy exchange requests","text":"<p>To use a proxy for exchange connections - you will have to define the proxies as part of the ccxt configuration.</p> <pre><code>{ \n  \"exchange\": {\n    \"ccxt_config\": {\n      \"httpsProxy\": \"http://addr:port\",\n    }\n  }\n}\n</code></pre> <p>For more information on available proxy types, please consult the ccxt proxy documentation.</p>"},{"location":"configuration/#next-step","title":"Next step","text":"<p>Now you have configured your config.json, the next step is to start your bot.</p>"},{"location":"data-analysis/","title":"Analyzing bot data with Jupyter notebooks","text":"<p>You can analyze the results of backtests and trading history easily using Jupyter notebooks. Sample notebooks are located at <code>user_data/notebooks/</code> after initializing the user directory with <code>freqtrade create-userdir --userdir user_data</code>.</p>"},{"location":"data-analysis/#quick-start-with-docker","title":"Quick start with docker","text":"<p>Freqtrade provides a docker-compose file which starts up a jupyter lab server. You can run this server using the following command: <code>docker compose -f docker/docker-compose-jupyter.yml up</code></p> <p>This will create a dockercontainer running jupyter lab, which will be accessible using <code>https://127.0.0.1:8888/lab</code>. Please use the link that's printed in the console after startup for simplified login.</p> <p>For more information, Please visit the Data analysis with Docker section.</p>"},{"location":"data-analysis/#pro-tips","title":"Pro tips","text":"<ul> <li>See jupyter.org for usage instructions.</li> <li>Don't forget to start a Jupyter notebook server from within your conda or venv environment or use nb_conda_kernels*</li> <li>Copy the example notebook before use so your changes don't get overwritten with the next freqtrade update.</li> </ul>"},{"location":"data-analysis/#using-virtual-environment-with-system-wide-jupyter-installation","title":"Using virtual environment with system-wide Jupyter installation","text":"<p>Sometimes it can be desired to use a system-wide installation of Jupyter notebook, and use a jupyter kernel from the virtual environment. This prevents you from installing the full jupyter suite multiple times per system, and provides an easy way to switch between tasks (freqtrade / other analytics tasks).</p> <p>For this to work, first activate your virtual environment and run the following commands:</p> <pre><code># Activate virtual environment\nsource .venv/bin/activate\n\npip install ipykernel\nipython kernel install --user --name=freqtrade\n# Restart jupyter (lab / notebook)\n# select kernel \"freqtrade\" in the notebook\n</code></pre> <p>Note</p> <p>This section is provided for completeness, the Freqtrade Team won't provide full support for problems with this setup and will recommend to install Jupyter in the virtual environment directly, as that is the easiest way to get jupyter notebooks up and running. For help with this setup please refer to the Project Jupyter documentation or help channels.</p> <p>Warning</p> <p>Some tasks don't work especially well in notebooks. For example, anything using asynchronous execution is a problem for Jupyter. Also, freqtrade's primary entry point is the shell cli, so using pure python in a notebook bypasses arguments that provide required objects and parameters to helper functions. You may need to set those values or create expected objects manually.</p>"},{"location":"data-analysis/#recommended-workflow","title":"Recommended workflow","text":"Task Tool Bot operations CLI Repetitive tasks Shell scripts Data analysis &amp; visualization Notebook <ol> <li> <p>Use the CLI to</p> <p>* download historical data   * run a backtest   * run with real-time data   * export results</p> </li> <li> <p>Collect these actions in shell scripts</p> <p>* save complicated commands with arguments   * execute multi-step operations   * automate testing strategies and preparing data for analysis</p> </li> <li> <p>Use a notebook to</p> <p>* visualize data   * mangle and plot to generate insights</p> </li> </ol>"},{"location":"data-analysis/#example-utility-snippets","title":"Example utility snippets","text":""},{"location":"data-analysis/#change-directory-to-root","title":"Change directory to root","text":"<p>Jupyter notebooks execute from the notebook directory. The following snippet searches for the project root, so relative paths remain consistent.</p> <pre><code>import os\nfrom pathlib import Path\n\n# Change directory\n# Modify this cell to insure that the output shows the correct path.\n# Define all paths relative to the project root shown in the cell output\nproject_root = \"somedir/freqtrade\"\ni=0\ntry:\n    os.chdir(project_root)\n    assert Path('LICENSE').is_file()\nexcept:\n    while i&lt;4 and (not Path('LICENSE').is_file()):\n        os.chdir(Path(Path.cwd(), '../'))\n        i+=1\n    project_root = Path.cwd()\nprint(Path.cwd())\n</code></pre>"},{"location":"data-analysis/#load-multiple-configuration-files","title":"Load multiple configuration files","text":"<p>This option can be useful to inspect the results of passing in multiple configs. This will also run through the whole Configuration initialization, so the configuration is completely initialized to be passed to other methods.</p> <pre><code>import json\nfrom freqtrade.configuration import Configuration\n\n# Load config from multiple files\nconfig = Configuration.from_files([\"config1.json\", \"config2.json\"])\n\n# Show the config in memory\nprint(json.dumps(config['original_config'], indent=2))\n</code></pre> <p>For Interactive environments, have an additional configuration specifying <code>user_data_dir</code> and pass this in last, so you don't have to change directories while running the bot. Best avoid relative paths, since this starts at the storage location of the jupyter notebook, unless the directory is changed.</p> <pre><code>{\n    \"user_data_dir\": \"~/.freqtrade/\"\n}\n</code></pre>"},{"location":"data-analysis/#further-data-analysis-documentation","title":"Further Data analysis documentation","text":"<ul> <li>Strategy debugging - also available as Jupyter notebook (<code>user_data/notebooks/strategy_analysis_example.ipynb</code>)</li> <li>Plotting</li> <li>Tag Analysis</li> </ul> <p>Feel free to submit an issue or Pull Request enhancing this document if you would like to share ideas on how to best analyze the data.</p>"},{"location":"data-download/","title":"Data Downloading","text":""},{"location":"data-download/#getting-data-for-backtesting-and-hyperopt","title":"Getting data for backtesting and hyperopt","text":"<p>To download data (candles / OHLCV) needed for backtesting and hyperoptimization use the <code>freqtrade download-data</code> command.</p> <p>If no additional parameter is specified, freqtrade will download data for <code>\"1m\"</code> and <code>\"5m\"</code> timeframes for the last 30 days. Exchange and pairs will come from <code>config.json</code> (if specified using <code>-c/--config</code>). Without provided configuration, <code>--exchange</code> becomes mandatory.</p> <p>You can use a relative timerange (<code>--days 20</code>) or an absolute starting point (<code>--timerange 20200101-</code>). For incremental downloads, the relative approach should be used.</p> <p>Tip: Updating existing data</p> <p>If you already have backtesting data available in your data-directory and would like to refresh this data up to today, freqtrade will automatically calculate the data missing for the existing pairs and the download will occur from the latest available point until \"now\", neither --days or --timerange parameters are required. Freqtrade will keep the available data and only download the missing data. If you are updating existing data after inserting new pairs that you have no data for, use <code>--new-pairs-days xx</code> parameter. Specified number of days will be downloaded for new pairs while old pairs will be updated with missing data only. If you use <code>--days xx</code> parameter alone - data for specified number of days will be downloaded for all pairs. Be careful, if specified number of days is smaller than gap between now and last downloaded candle - freqtrade will delete all existing data to avoid gaps in candle data.</p>"},{"location":"data-download/#usage","title":"Usage","text":"<pre><code>usage: freqtrade download-data [-h] [-v] [--logfile FILE] [-V] [-c PATH]\n                               [-d PATH] [--userdir PATH]\n                               [-p PAIRS [PAIRS ...]] [--pairs-file FILE]\n                               [--days INT] [--new-pairs-days INT]\n                               [--include-inactive-pairs]\n                               [--timerange TIMERANGE] [--dl-trades]\n                               [--convert] [--exchange EXCHANGE]\n                               [-t TIMEFRAMES [TIMEFRAMES ...]] [--erase]\n                               [--data-format-ohlcv {json,jsongz,hdf5,feather,parquet}]\n                               [--data-format-trades {json,jsongz,hdf5,feather,parquet}]\n                               [--trading-mode {spot,margin,futures}]\n                               [--prepend]\n\noptions:\n  -h, --help            show this help message and exit\n  -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...]\n                        Limit command to these pairs. Pairs are space-\n                        separated.\n  --pairs-file FILE     File containing a list of pairs. Takes precedence over\n                        --pairs or pairs configured in the configuration.\n  --days INT            Download data for given number of days.\n  --new-pairs-days INT  Download data of new pairs for given number of days.\n                        Default: `None`.\n  --include-inactive-pairs\n                        Also download data from inactive pairs.\n  --timerange TIMERANGE\n                        Specify what timerange of data to use.\n  --dl-trades           Download trades instead of OHLCV data. The bot will\n                        resample trades to the desired timeframe as specified\n                        as --timeframes/-t.\n  --convert             Convert downloaded trades to OHLCV data. Only\n                        applicable in combination with `--dl-trades`. Will be\n                        automatic for exchanges which don't have historic\n                        OHLCV (e.g. Kraken). If not provided, use `trades-to-\n                        ohlcv` to convert trades data to OHLCV data.\n  --exchange EXCHANGE   Exchange name. Only valid if no config is provided.\n  -t TIMEFRAMES [TIMEFRAMES ...], --timeframes TIMEFRAMES [TIMEFRAMES ...]\n                        Specify which tickers to download. Space-separated\n                        list. Default: `1m 5m`.\n  --erase               Clean all existing data for the selected\n                        exchange/pairs/timeframes.\n  --data-format-ohlcv {json,jsongz,hdf5,feather,parquet}\n                        Storage format for downloaded candle (OHLCV) data.\n                        (default: `feather`).\n  --data-format-trades {json,jsongz,hdf5,feather,parquet}\n                        Storage format for downloaded trades data. (default:\n                        `feather`).\n  --trading-mode {spot,margin,futures}, --tradingmode {spot,margin,futures}\n                        Select Trading mode\n  --prepend             Allow data prepending. (Data-appending is disabled)\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE, --log-file FILE\n                        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH, --data-dir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n</code></pre> <p>Downloading all data for one quote currency</p> <p>Often, you'll want to download data for all pairs of a specific quote-currency. In such cases, you can use the following shorthand: <code>freqtrade download-data --exchange binance --pairs .*/USDT &lt;...&gt;</code>. The provided \"pairs\" string will be expanded to contain all active pairs on the exchange. To also download data for inactive (delisted) pairs, add <code>--include-inactive-pairs</code> to the command.</p> <p>Startup period</p> <p><code>download-data</code> is a strategy-independent command. The idea is to download a big chunk of data once, and then iteratively increase the amount of data stored.</p> <p>For that reason, <code>download-data</code> does not care about the \"startup-period\" defined in a strategy. It's up to the user to download additional days if the backtest should start at a specific point in time (while respecting startup period).</p>"},{"location":"data-download/#start-download","title":"Start download","text":"<p>A very simple command (assuming an available <code>config.json</code> file) can look as follows.</p> <pre><code>freqtrade download-data --exchange binance\n</code></pre> <p>This will download historical candle (OHLCV) data for all the currency pairs defined in the configuration.</p> <p>Alternatively, specify the pairs directly</p> <pre><code>freqtrade download-data --exchange binance --pairs ETH/USDT XRP/USDT BTC/USDT\n</code></pre> <p>or as regex (in this case, to download all active USDT pairs)</p> <pre><code>freqtrade download-data --exchange binance --pairs .*/USDT\n</code></pre>"},{"location":"data-download/#other-notes","title":"Other Notes","text":"<ul> <li>To use a different directory than the exchange specific default, use <code>--datadir user_data/data/some_directory</code>.</li> <li>To change the exchange used to download the historical data from, please use a different configuration file (you'll probably need to adjust rate limits etc.)</li> <li>To use <code>pairs.json</code> from some other directory, use <code>--pairs-file some_other_dir/pairs.json</code>.</li> <li>To download historical candle (OHLCV) data for only 10 days, use <code>--days 10</code> (defaults to 30 days).</li> <li>To download historical candle (OHLCV) data from a fixed starting point, use <code>--timerange 20200101-</code> - which will download all data from January 1<sup>st</sup>, 2020.</li> <li>Use <code>--timeframes</code> to specify what timeframe download the historical candle (OHLCV) data for. Default is <code>--timeframes 1m 5m</code> which will download 1-minute and 5-minute data.</li> <li>To use exchange, timeframe and list of pairs as defined in your configuration file, use the <code>-c/--config</code> option. With this, the script uses the whitelist defined in the config as the list of currency pairs to download data for and does not require the pairs.json file. You can combine <code>-c/--config</code> with most other options.</li> </ul> Permission denied errors <p>If your configuration directory <code>user_data</code> was made by docker, you may get the following error:</p> <pre><code>cp: cannot create regular file 'user_data/data/binance/pairs.json': Permission denied\n</code></pre> <p>You can fix the permissions of your user-data directory as follows:</p> <pre><code>sudo chown -R $UID:$GID user_data\n</code></pre>"},{"location":"data-download/#download-additional-data-before-the-current-timerange","title":"Download additional data before the current timerange","text":"<p>Assuming you downloaded all data from 2022 (<code>--timerange 20220101-</code>) - but you'd now like to also backtest with earlier data. You can do so by using the <code>--prepend</code> flag, combined with <code>--timerange</code> - specifying an end-date.</p> <pre><code>freqtrade download-data --exchange binance --pairs ETH/USDT XRP/USDT BTC/USDT --prepend --timerange 20210101-20220101\n</code></pre> <p>Note</p> <p>Freqtrade will ignore the end-date in this mode if data is available, updating the end-date to the existing data start point.</p>"},{"location":"data-download/#data-format","title":"Data format","text":"<p>Freqtrade currently supports the following data-formats:</p> <ul> <li><code>feather</code> - a dataformat based on Apache Arrow</li> <li><code>json</code> -  plain \"text\" json files</li> <li><code>jsongz</code> - a gzip-zipped version of json files</li> <li><code>hdf5</code> - a high performance datastore</li> <li><code>parquet</code> - columnar datastore (OHLCV only)</li> </ul> <p>By default, both OHLCV data and trades data are stored in the <code>feather</code> format.</p> <p>This can be changed via the <code>--data-format-ohlcv</code> and <code>--data-format-trades</code> command line arguments respectively. To persist this change, you should also add the following snippet to your configuration, so you don't have to insert the above arguments each time:</p> <pre><code>    // ...\n    \"dataformat_ohlcv\": \"hdf5\",\n    \"dataformat_trades\": \"hdf5\",\n    // ...\n</code></pre> <p>If the default data-format has been changed during download, then the keys <code>dataformat_ohlcv</code> and <code>dataformat_trades</code> in the configuration file need to be adjusted to the selected dataformat as well.</p> <p>Note</p> <p>You can convert between data-formats using the convert-data and convert-trade-data methods.</p>"},{"location":"data-download/#dataformat-comparison","title":"Dataformat comparison","text":"<p>The following comparisons have been made with the following data, and by using the linux <code>time</code> command.</p> <pre><code>Found 6 pair / timeframe combinations.\n+----------+-------------+--------+---------------------+---------------------+\n|     Pair |   Timeframe |   Type |                From |                  To |\n|----------+-------------+--------+---------------------+---------------------|\n| BTC/USDT |          5m |   spot | 2017-08-17 04:00:00 | 2022-09-13 19:25:00 |\n| ETH/USDT |          1m |   spot | 2017-08-17 04:00:00 | 2022-09-13 19:26:00 |\n| BTC/USDT |          1m |   spot | 2017-08-17 04:00:00 | 2022-09-13 19:30:00 |\n| XRP/USDT |          5m |   spot | 2018-05-04 08:10:00 | 2022-09-13 19:15:00 |\n| XRP/USDT |          1m |   spot | 2018-05-04 08:11:00 | 2022-09-13 19:22:00 |\n| ETH/USDT |          5m |   spot | 2017-08-17 04:00:00 | 2022-09-13 19:20:00 |\n+----------+-------------+--------+---------------------+---------------------+\n</code></pre> <p>Timings have been taken in a not very scientific way with the following command, which forces reading the data into memory.</p> <pre><code>time freqtrade list-data --show-timerange --data-format-ohlcv &lt;dataformat&gt;\n</code></pre> Format Size timing <code>feather</code> 72Mb 3.5s <code>json</code> 149Mb 25.6s <code>jsongz</code> 39Mb 27s <code>hdf5</code> 145Mb 3.9s <code>parquet</code> 83Mb 3.8s <p>Size has been taken from the BTC/USDT 1m spot combination for the timerange specified above.</p> <p>To have a best performance/size mix, we recommend using the default feather format, or parquet.</p>"},{"location":"data-download/#pairs-file","title":"Pairs file","text":"<p>In alternative to the whitelist from <code>config.json</code>, a <code>pairs.json</code> file can be used. If you are using Binance for example:</p> <ul> <li>create a directory <code>user_data/data/binance</code> and copy or create the <code>pairs.json</code> file in that directory.</li> <li>update the <code>pairs.json</code> file to contain the currency pairs you are interested in.</li> </ul> <pre><code>mkdir -p user_data/data/binance\ntouch user_data/data/binance/pairs.json\n</code></pre> <p>The format of the <code>pairs.json</code> file is a simple json list. Mixing different stake-currencies is allowed for this file, since it's only used for downloading.</p> <pre><code>[\n    \"ETH/BTC\",\n    \"ETH/USDT\",\n    \"BTC/USDT\",\n    \"XRP/ETH\"\n]\n</code></pre> <p>Note</p> <p>The <code>pairs.json</code> file is only used when no configuration is loaded (implicitly by naming, or via <code>--config</code> flag). You can force the usage of this file via <code>--pairs-file pairs.json</code> - however we recommend to use the pairlist from within the configuration, either via <code>exchange.pair_whitelist</code> or <code>pairs</code> setting in the configuration.</p>"},{"location":"data-download/#sub-command-convert-data","title":"Sub-command convert data","text":"<pre><code>usage: freqtrade convert-data [-h] [-v] [--logfile FILE] [-V] [-c PATH]\n                              [-d PATH] [--userdir PATH]\n                              [-p PAIRS [PAIRS ...]] --format-from\n                              {json,jsongz,hdf5,feather,parquet} --format-to\n                              {json,jsongz,hdf5,feather,parquet} [--erase]\n                              [--exchange EXCHANGE]\n                              [-t TIMEFRAMES [TIMEFRAMES ...]]\n                              [--trading-mode {spot,margin,futures}]\n                              [--candle-types {spot,futures,mark,index,premiumIndex,funding_rate} [{spot,futures,mark,index,premiumIndex,funding_rate} ...]]\n\noptions:\n  -h, --help            show this help message and exit\n  -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...]\n                        Limit command to these pairs. Pairs are space-\n                        separated.\n  --format-from {json,jsongz,hdf5,feather,parquet}\n                        Source format for data conversion.\n  --format-to {json,jsongz,hdf5,feather,parquet}\n                        Destination format for data conversion.\n  --erase               Clean all existing data for the selected\n                        exchange/pairs/timeframes.\n  --exchange EXCHANGE   Exchange name. Only valid if no config is provided.\n  -t TIMEFRAMES [TIMEFRAMES ...], --timeframes TIMEFRAMES [TIMEFRAMES ...]\n                        Specify which tickers to download. Space-separated\n                        list. Default: `1m 5m`.\n  --trading-mode {spot,margin,futures}, --tradingmode {spot,margin,futures}\n                        Select Trading mode\n  --candle-types {spot,futures,mark,index,premiumIndex,funding_rate} [{spot,futures,mark,index,premiumIndex,funding_rate} ...]\n                        Select candle type to convert. Defaults to all\n                        available types.\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE, --log-file FILE\n                        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH, --data-dir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n</code></pre>"},{"location":"data-download/#example-converting-data","title":"Example converting data","text":"<p>The following command will convert all candle (OHLCV) data available in <code>~/.freqtrade/data/binance</code> from json to jsongz, saving diskspace in the process. It'll also remove original json data files (<code>--erase</code> parameter).</p> <pre><code>freqtrade convert-data --format-from json --format-to jsongz --datadir ~/.freqtrade/data/binance -t 5m 15m --erase\n</code></pre>"},{"location":"data-download/#sub-command-convert-trade-data","title":"Sub-command convert trade data","text":"<pre><code>usage: freqtrade convert-trade-data [-h] [-v] [--logfile FILE] [-V] [-c PATH]\n                                    [-d PATH] [--userdir PATH]\n                                    [-p PAIRS [PAIRS ...]] --format-from\n                                    {json,jsongz,hdf5,feather,parquet}\n                                    --format-to\n                                    {json,jsongz,hdf5,feather,parquet}\n                                    [--erase] [--exchange EXCHANGE]\n\noptions:\n  -h, --help            show this help message and exit\n  -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...]\n                        Limit command to these pairs. Pairs are space-\n                        separated.\n  --format-from {json,jsongz,hdf5,feather,parquet}\n                        Source format for data conversion.\n  --format-to {json,jsongz,hdf5,feather,parquet}\n                        Destination format for data conversion.\n  --erase               Clean all existing data for the selected\n                        exchange/pairs/timeframes.\n  --exchange EXCHANGE   Exchange name. Only valid if no config is provided.\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE, --log-file FILE\n                        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH, --data-dir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n</code></pre>"},{"location":"data-download/#example-converting-trades","title":"Example converting trades","text":"<p>The following command will convert all available trade-data in <code>~/.freqtrade/data/kraken</code> from jsongz to json. It'll also remove original jsongz data files (<code>--erase</code> parameter).</p> <pre><code>freqtrade convert-trade-data --format-from jsongz --format-to json --datadir ~/.freqtrade/data/kraken --erase\n</code></pre>"},{"location":"data-download/#sub-command-trades-to-ohlcv","title":"Sub-command trades to ohlcv","text":"<p>When you need to use <code>--dl-trades</code> (kraken only) to download data, conversion of trades data to ohlcv data is the last step. This command will allow you to repeat this last step for additional timeframes without re-downloading the data.</p> <pre><code>usage: freqtrade trades-to-ohlcv [-h] [-v] [--logfile FILE] [-V] [-c PATH]\n                                 [-d PATH] [--userdir PATH]\n                                 [-p PAIRS [PAIRS ...]]\n                                 [-t TIMEFRAMES [TIMEFRAMES ...]]\n                                 [--exchange EXCHANGE]\n                                 [--data-format-ohlcv {json,jsongz,hdf5,feather,parquet}]\n                                 [--data-format-trades {json,jsongz,hdf5,feather}]\n\noptions:\n  -h, --help            show this help message and exit\n  -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...]\n                        Limit command to these pairs. Pairs are space-\n                        separated.\n  -t TIMEFRAMES [TIMEFRAMES ...], --timeframes TIMEFRAMES [TIMEFRAMES ...]\n                        Specify which tickers to download. Space-separated\n                        list. Default: `1m 5m`.\n  --exchange EXCHANGE   Exchange name. Only valid if no config is provided.\n  --data-format-ohlcv {json,jsongz,hdf5,feather,parquet}\n                        Storage format for downloaded candle (OHLCV) data.\n                        (default: `feather`).\n  --data-format-trades {json,jsongz,hdf5,feather}\n                        Storage format for downloaded trades data. (default:\n                        `feather`).\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE, --log-file FILE\n                        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH, --data-dir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n</code></pre>"},{"location":"data-download/#example-trade-to-ohlcv-conversion","title":"Example trade-to-ohlcv conversion","text":"<pre><code>freqtrade trades-to-ohlcv --exchange kraken -t 5m 1h 1d --pairs BTC/EUR ETH/EUR\n</code></pre>"},{"location":"data-download/#sub-command-list-data","title":"Sub-command list-data","text":"<p>You can get a list of downloaded data using the <code>list-data</code> sub-command.</p> <pre><code>usage: freqtrade list-data [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH]\n                           [--userdir PATH] [--exchange EXCHANGE]\n                           [--data-format-ohlcv {json,jsongz,hdf5,feather,parquet}]\n                           [-p PAIRS [PAIRS ...]]\n                           [--trading-mode {spot,margin,futures}]\n                           [--show-timerange]\n\noptions:\n  -h, --help            show this help message and exit\n  --exchange EXCHANGE   Exchange name. Only valid if no config is provided.\n  --data-format-ohlcv {json,jsongz,hdf5,feather,parquet}\n                        Storage format for downloaded candle (OHLCV) data.\n                        (default: `feather`).\n  -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...]\n                        Limit command to these pairs. Pairs are space-\n                        separated.\n  --trading-mode {spot,margin,futures}, --tradingmode {spot,margin,futures}\n                        Select Trading mode\n  --show-timerange      Show timerange available for available data. (May take\n                        a while to calculate).\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE, --log-file FILE\n                        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH, --data-dir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n</code></pre>"},{"location":"data-download/#example-list-data","title":"Example list-data","text":"<pre><code>&gt; freqtrade list-data --userdir ~/.freqtrade/user_data/\n\nFound 33 pair / timeframe combinations.\npairs       timeframe\n----------  -----------------------------------------\nADA/BTC     5m, 15m, 30m, 1h, 2h, 4h, 6h, 12h, 1d\nADA/ETH     5m, 15m, 30m, 1h, 2h, 4h, 6h, 12h, 1d\nETH/BTC     5m, 15m, 30m, 1h, 2h, 4h, 6h, 12h, 1d\nETH/USDT    5m, 15m, 30m, 1h, 2h, 4h\n</code></pre>"},{"location":"data-download/#trades-tick-data","title":"Trades (tick) data","text":"<p>By default, <code>download-data</code> sub-command downloads Candles (OHLCV) data. Most exchanges also provide historic trade-data via their API. This data can be useful if you need many different timeframes, since it is only downloaded once, and then resampled locally to the desired timeframes.</p> <p>Since this data is large by default, the files use the feather file format by default. They are stored in your data-directory with the naming convention of <code>&lt;pair&gt;-trades.feather</code> (<code>ETH_BTC-trades.feather</code>). Incremental mode is also supported, as for historic OHLCV data, so downloading the data once per week with <code>--days 8</code> will create an incremental data-repository.</p> <p>To use this mode, simply add <code>--dl-trades</code> to your call. This will swap the download method to download trades. If <code>--convert</code> is also provided, the resample step will happen automatically and overwrite eventually existing OHLCV data for the given pair/timeframe combinations.</p> <p>Do not use</p> <p>You should not use this unless you're a kraken user (Kraken does not provide historic OHLCV data). Most other exchanges provide OHLCV data with sufficient history, so downloading multiple timeframes through that method will still proof to be a lot faster than downloading trades data.</p> <p>Kraken user</p> <p>Kraken users should read this before starting to download data.</p> <p>Example call:</p> <pre><code>freqtrade download-data --exchange kraken --pairs XRP/EUR ETH/EUR --days 20 --dl-trades\n</code></pre> <p>Note</p> <p>While this method uses async calls, it will be slow, since it requires the result of the previous call to generate the next request to the exchange.</p>"},{"location":"data-download/#next-step","title":"Next step","text":"<p>Great, you now have some data downloaded, so you can now start backtesting your strategy.</p>"},{"location":"deprecated/","title":"Deprecated features","text":"<p>This page contains description of the command line arguments, configuration parameters and the bot features that were declared as DEPRECATED by the bot development team and are no longer supported. Please avoid their usage in your configuration.</p>"},{"location":"deprecated/#removed-features","title":"Removed features","text":""},{"location":"deprecated/#the-refresh-pairs-cached-command-line-option","title":"the <code>--refresh-pairs-cached</code> command line option","text":"<p><code>--refresh-pairs-cached</code> in the context of backtesting, hyperopt and edge allows to refresh candle data for backtesting. Since this leads to much confusion, and slows down backtesting (while not being part of backtesting) this has been singled out as a separate freqtrade sub-command <code>freqtrade download-data</code>.</p> <p>This command line option was deprecated in 2019.7-dev (develop branch) and removed in 2019.9.</p>"},{"location":"deprecated/#the-dynamic-whitelist-command-line-option","title":"The --dynamic-whitelist command line option","text":"<p>This command line option was deprecated in 2018 and removed freqtrade 2019.6-dev (develop branch) and in freqtrade 2019.7. Please refer to pairlists instead.</p>"},{"location":"deprecated/#the-live-command-line-option","title":"the <code>--live</code> command line option","text":"<p><code>--live</code> in the context of backtesting allowed to download the latest tick data for backtesting. Did only download the latest 500 candles, so was ineffective in getting good backtest data. Removed in 2019-7-dev (develop branch) and in freqtrade 2019.8.</p>"},{"location":"deprecated/#ticker_interval-now-timeframe","title":"<code>ticker_interval</code> (now <code>timeframe</code>)","text":"<p>Support for <code>ticker_interval</code> terminology was deprecated in 2020.6 in favor of <code>timeframe</code> - and compatibility code was removed in 2022.3.</p>"},{"location":"deprecated/#allow-running-multiple-pairlists-in-sequence","title":"Allow running multiple pairlists in sequence","text":"<p>The former <code>\"pairlist\"</code> section in the configuration has been removed, and is replaced by <code>\"pairlists\"</code> - being a list to specify a sequence of pairlists.</p> <p>The old section of configuration parameters (<code>\"pairlist\"</code>) has been deprecated in 2019.11 and has been removed in 2020.4.</p>"},{"location":"deprecated/#deprecation-of-bidvolume-and-askvolume-from-volume-pairlist","title":"deprecation of bidVolume and askVolume from volume-pairlist","text":"<p>Since only quoteVolume can be compared between assets, the other options (bidVolume, askVolume) have been deprecated in 2020.4, and have been removed in 2020.9.</p>"},{"location":"deprecated/#using-order-book-steps-for-exit-price","title":"Using order book steps for exit price","text":"<p>Using <code>order_book_min</code> and <code>order_book_max</code> used to allow stepping the orderbook and trying to find the next ROI slot - trying to place sell-orders early. As this does however increase risk and provides no benefit, it's been removed for maintainability purposes in 2021.7.</p>"},{"location":"deprecated/#legacy-hyperopt-mode","title":"Legacy Hyperopt mode","text":"<p>Using separate hyperopt files was deprecated in 2021.4 and was removed in 2021.9. Please switch to the new Parametrized Strategies to benefit from the new hyperopt interface.</p>"},{"location":"deprecated/#strategy-changes-between-v2-and-v3","title":"Strategy changes between V2 and V3","text":"<p>Isolated Futures / short trading was introduced in 2022.4. This required major changes to configuration settings, strategy interfaces, ...</p> <p>We have put a great effort into keeping compatibility with existing strategies, so if you just want to continue using freqtrade in spot markets, there are no changes necessary. While we may drop support for the current interface sometime in the future, we will announce this separately and have an appropriate transition period.</p> <p>Please follow the Strategy migration guide to migrate your strategy to the new format to start using the new functionalities.</p>"},{"location":"deprecated/#webhooks-changes-with-20224","title":"webhooks - changes with 2022.4","text":""},{"location":"deprecated/#buy_tag-has-been-renamed-to-enter_tag","title":"<code>buy_tag</code> has been renamed to <code>enter_tag</code>","text":"<p>This should apply only to your strategy and potentially to webhooks. We will keep a compatibility layer for 1-2 versions (so both <code>buy_tag</code> and <code>enter_tag</code> will still work), but support for this in webhooks will disappear after that.</p>"},{"location":"deprecated/#naming-changes","title":"Naming changes","text":"<p>Webhook terminology changed from \"sell\" to \"exit\", and from \"buy\" to \"entry\", removing \"webhook\" in the process.</p> <ul> <li><code>webhookbuy</code>, <code>webhookentry</code> -&gt; <code>entry</code></li> <li><code>webhookbuyfill</code>, <code>webhookentryfill</code> -&gt; <code>entry_fill</code></li> <li><code>webhookbuycancel</code>, <code>webhookentrycancel</code> -&gt; <code>entry_cancel</code></li> <li><code>webhooksell</code>, <code>webhookexit</code> -&gt; <code>exit</code></li> <li><code>webhooksellfill</code>, <code>webhookexitfill</code> -&gt; <code>exit_fill</code></li> <li><code>webhooksellcancel</code>, <code>webhookexitcancel</code> -&gt; <code>exit_cancel</code></li> </ul>"},{"location":"deprecated/#removal-of-populate_any_indicators","title":"Removal of <code>populate_any_indicators</code>","text":"<p>version 2023.3 saw the removal of <code>populate_any_indicators</code> in favor of split methods for feature engineering and targets. Please read the migration document for full details.</p>"},{"location":"developer/","title":"Development Help","text":"<p>This page is intended for developers of Freqtrade, people who want to contribute to the Freqtrade codebase or documentation, or people who want to understand the source code of the application they're running.</p> <p>All contributions, bug reports, bug fixes, documentation improvements, enhancements and ideas are welcome. We track issues on GitHub and also have a dev channel on discord where you can ask questions.</p>"},{"location":"developer/#documentation","title":"Documentation","text":"<p>Documentation is available at https://freqtrade.io and needs to be provided with every new feature PR.</p> <p>Special fields for the documentation (like Note boxes, ...) can be found here.</p> <p>To test the documentation locally use the following commands.</p> <pre><code>pip install -r docs/requirements-docs.txt\nmkdocs serve\n</code></pre> <p>This will spin up a local server (usually on port 8000) so you can see if everything looks as you'd like it to.</p>"},{"location":"developer/#developer-setup","title":"Developer setup","text":"<p>To configure a development environment, you can either use the provided DevContainer, or use the <code>setup.sh</code> script and answer \"y\" when asked \"Do you want to install dependencies for dev [y/N]? \". Alternatively (e.g. if your system is not supported by the setup.sh script), follow the manual installation process and run <code>pip3 install -e .[all]</code>.</p> <p>This will install all required tools for development, including <code>pytest</code>, <code>ruff</code>, <code>mypy</code>, and <code>coveralls</code>.</p> <p>Then install the git hook scripts by running <code>pre-commit install</code>, so your changes will be verified locally before committing. This avoids a lot of waiting for CI already, as some basic formatting checks are done locally on your machine.</p> <p>Before opening a pull request, please familiarize yourself with our Contributing Guidelines.</p>"},{"location":"developer/#devcontainer-setup","title":"Devcontainer setup","text":"<p>The fastest and easiest way to get started is to use VSCode with the Remote container extension. This gives developers the ability to start the bot with all required dependencies without needing to install any freqtrade specific dependencies on your local machine.</p>"},{"location":"developer/#devcontainer-dependencies","title":"Devcontainer dependencies","text":"<ul> <li>VSCode</li> <li>docker</li> <li>Remote container extension documentation</li> </ul> <p>For more information about the Remote container extension, best consult the documentation.</p>"},{"location":"developer/#tests","title":"Tests","text":"<p>New code should be covered by basic unittests. Depending on the complexity of the feature, Reviewers may request more in-depth unittests. If necessary, the Freqtrade team can assist and give guidance with writing good tests (however please don't expect anyone to write the tests for you).</p>"},{"location":"developer/#how-to-run-tests","title":"How to run tests","text":"<p>Use <code>pytest</code> in root folder to run all available testcases and confirm your local environment is setup correctly</p> <p>feature branches</p> <p>Tests are expected to pass on the <code>develop</code> and <code>stable</code> branches. Other branches may be work in progress with tests not working yet.</p>"},{"location":"developer/#checking-log-content-in-tests","title":"Checking log content in tests","text":"<p>Freqtrade uses 2 main methods to check log content in tests, <code>log_has()</code> and <code>log_has_re()</code> (to check using regex, in case of dynamic log-messages). These are available from <code>conftest.py</code> and can be imported in any test module.</p> <p>A sample check looks as follows:</p> <pre><code>from tests.conftest import log_has, log_has_re\n\ndef test_method_to_test(caplog):\n    method_to_test()\n\n    assert log_has(\"This event happened\", caplog)\n    # Check regex with trailing number ...\n    assert log_has_re(r\"This dynamic event happened and produced \\d+\", caplog)\n</code></pre>"},{"location":"developer/#debug-configuration","title":"Debug configuration","text":"<p>To debug freqtrade, we recommend VSCode (with the Python extension) with the following launch configuration (located in <code>.vscode/launch.json</code>). Details will obviously vary between setups - but this should work to get you started.</p> <pre><code>{\n    \"name\": \"freqtrade trade\",\n    \"type\": \"debugpy\",\n    \"request\": \"launch\",\n    \"module\": \"freqtrade\",\n    \"console\": \"integratedTerminal\",\n    \"args\": [\n        \"trade\",\n        // Optional:\n        // \"--userdir\", \"user_data\",\n        \"--strategy\", \n        \"MyAwesomeStrategy\",\n    ]\n},\n</code></pre> <p>Command line arguments can be added in the <code>\"args\"</code> array. This method can also be used to debug a strategy, by setting the breakpoints within the strategy.</p> <p>A similar setup can also be taken for Pycharm - using <code>freqtrade</code> as module name, and setting the command line arguments as \"parameters\".</p> Correct venv usage <p>When using a virtual environment (which you should), make sure that your Editor is using the correct virtual environment to avoid problems or \"unknown import\" errors.</p> <p>Startup directory</p> <p>This assumes that you have the repository checked out, and the editor is started at the repository root level (so setup.py is at the top level of your repository).</p>"},{"location":"developer/#vscode","title":"Vscode","text":"<p>You can select the correct environment in VSCode with the command \"Python: Select Interpreter\" - which will show you environments the extension detected. If your environment has not been detected, you can also pick a path manually.</p>"},{"location":"developer/#pycharm","title":"Pycharm","text":"<p>In pycharm, you can select the appropriate Environment in the \"Run/Debug Configurations\" window. </p>"},{"location":"developer/#errorhandling","title":"ErrorHandling","text":"<p>Freqtrade Exceptions all inherit from <code>FreqtradeException</code>. This general class of error should however not be used directly. Instead, multiple specialized sub-Exceptions exist.</p> <p>Below is an outline of exception inheritance hierarchy:</p> <pre><code>+ FreqtradeException\n|\n+---+ OperationalException\n|   |\n|   +---+ ConfigurationError\n|\n+---+ DependencyException\n|   |\n|   +---+ PricingError\n|   |\n|   +---+ ExchangeError\n|       |\n|       +---+ TemporaryError\n|       |\n|       +---+ DDosProtection\n|       |\n|       +---+ InvalidOrderException\n|           |\n|           +---+ RetryableOrderError\n|           |\n|           +---+ InsufficientFundsError\n|\n+---+ StrategyError\n</code></pre>"},{"location":"developer/#plugins","title":"Plugins","text":""},{"location":"developer/#pairlists","title":"Pairlists","text":"<p>You have a great idea for a new pair selection algorithm you would like to try out? Great. Hopefully you also want to contribute this back upstream.</p> <p>Whatever your motivations are - This should get you off the ground in trying to develop a new Pairlist Handler.</p> <p>First of all, have a look at the VolumePairList Handler, and best copy this file with a name of your new Pairlist Handler.</p> <p>This is a simple Handler, which however serves as a good example on how to start developing.</p> <p>Next, modify the class-name of the Handler (ideally align this with the module filename).</p> <p>The base-class provides an instance of the exchange (<code>self._exchange</code>) the pairlist manager (<code>self._pairlistmanager</code>), as well as the main configuration (<code>self._config</code>), the pairlist dedicated configuration (<code>self._pairlistconfig</code>) and the absolute position within the list of pairlists.</p> <pre><code>        self._exchange = exchange\n        self._pairlistmanager = pairlistmanager\n        self._config = config\n        self._pairlistconfig = pairlistconfig\n        self._pairlist_pos = pairlist_pos\n</code></pre> <p>Tip</p> <p>Don't forget to register your pairlist in <code>constants.py</code> under the variable <code>AVAILABLE_PAIRLISTS</code> - otherwise it will not be selectable.</p> <p>Now, let's step through the methods which require actions:</p>"},{"location":"developer/#pairlist-configuration","title":"Pairlist configuration","text":"<p>Configuration for the chain of Pairlist Handlers is done in the bot configuration file in the element <code>\"pairlists\"</code>, an array of configuration parameters for each Pairlist Handlers in the chain.</p> <p>By convention, <code>\"number_assets\"</code> is used to specify the maximum number of pairs to keep in the pairlist. Please follow this to ensure a consistent user experience.</p> <p>Additional parameters can be configured as needed. For instance, <code>VolumePairList</code> uses <code>\"sort_key\"</code> to specify the sorting value - however feel free to specify whatever is necessary for your great algorithm to be successful and dynamic.</p>"},{"location":"developer/#short_desc","title":"short_desc","text":"<p>Returns a description used for Telegram messages.</p> <p>This should contain the name of the Pairlist Handler, as well as a short description containing the number of assets. Please follow the format <code>\"PairlistName - top/bottom X pairs\"</code>.</p>"},{"location":"developer/#gen_pairlist","title":"gen_pairlist","text":"<p>Override this method if the Pairlist Handler can be used as the leading Pairlist Handler in the chain, defining the initial pairlist which is then handled by all Pairlist Handlers in the chain. Examples are <code>StaticPairList</code> and <code>VolumePairList</code>.</p> <p>This is called with each iteration of the bot (only if the Pairlist Handler is at the first location) - so consider implementing caching for compute/network heavy calculations.</p> <p>It must return the resulting pairlist (which may then be passed into the chain of Pairlist Handlers).</p> <p>Validations are optional, the parent class exposes a <code>_verify_blacklist(pairlist)</code> and <code>_whitelist_for_active_markets(pairlist)</code> to do default filtering. Use this if you limit your result to a certain number of pairs - so the end-result is not shorter than expected.</p>"},{"location":"developer/#filter_pairlist","title":"filter_pairlist","text":"<p>This method is called for each Pairlist Handler in the chain by the pairlist manager.</p> <p>This is called with each iteration of the bot - so consider implementing caching for compute/network heavy calculations.</p> <p>It gets passed a pairlist (which can be the result of previous pairlists) as well as <code>tickers</code>, a pre-fetched version of <code>get_tickers()</code>.</p> <p>The default implementation in the base class simply calls the <code>_validate_pair()</code> method for each pair in the pairlist, but you may override it. So you should either implement the <code>_validate_pair()</code> in your Pairlist Handler or override <code>filter_pairlist()</code> to do something else.</p> <p>If overridden, it must return the resulting pairlist (which may then be passed into the next Pairlist Handler in the chain).</p> <p>Validations are optional, the parent class exposes a <code>_verify_blacklist(pairlist)</code> and <code>_whitelist_for_active_markets(pairlist)</code> to do default filters. Use this if you limit your result to a certain number of pairs - so the end result is not shorter than expected.</p> <p>In <code>VolumePairList</code>, this implements different methods of sorting, does early validation so only the expected number of pairs is returned.</p>"},{"location":"developer/#sample","title":"sample","text":"<pre><code>    def filter_pairlist(self, pairlist: List[str], tickers: Dict) -&gt; List[str]:\n        # Generate dynamic whitelist\n        pairs = self._calculate_pairlist(pairlist, tickers)\n        return pairs\n</code></pre>"},{"location":"developer/#protections","title":"Protections","text":"<p>Best read the Protection documentation to understand protections. This Guide is directed towards Developers who want to develop a new protection.</p> <p>No protection should use datetime directly, but use the provided <code>date_now</code> variable for date calculations. This preserves the ability to backtest protections.</p> <p>Writing a new Protection</p> <p>Best copy one of the existing Protections to have a good example. Don't forget to register your protection in <code>constants.py</code> under the variable <code>AVAILABLE_PROTECTIONS</code> - otherwise it will not be selectable.</p>"},{"location":"developer/#implementation-of-a-new-protection","title":"Implementation of a new protection","text":"<p>All Protection implementations must have <code>IProtection</code> as parent class. For that reason, they must implement the following methods:</p> <ul> <li><code>short_desc()</code></li> <li><code>global_stop()</code></li> <li><code>stop_per_pair()</code>.</li> </ul> <p><code>global_stop()</code> and <code>stop_per_pair()</code> must return a ProtectionReturn object, which consists of:</p> <ul> <li>lock pair - boolean</li> <li>lock until - datetime - until when should the pair be locked (will be rounded up to the next new candle)</li> <li>reason - string, used for logging and storage in the database</li> <li>lock_side - long, short or '*'.</li> </ul> <p>The <code>until</code> portion should be calculated using the provided <code>calculate_lock_end()</code> method.</p> <p>All Protections should use <code>\"stop_duration\"</code> / <code>\"stop_duration_candles\"</code> to define how long a pair (or all pairs) should be locked. The content of this is made available as <code>self._stop_duration</code> to the each Protection.</p> <p>If your protection requires a look-back period, please use <code>\"lookback_period\"</code> / <code>\"lockback_period_candles\"</code> to keep all protections aligned.</p>"},{"location":"developer/#global-vs-local-stops","title":"Global vs. local stops","text":"<p>Protections can have 2 different ways to stop trading for a limited :</p> <ul> <li>Per pair (local)</li> <li>For all Pairs (globally)</li> </ul>"},{"location":"developer/#protections-per-pair","title":"Protections - per pair","text":"<p>Protections that implement the per pair approach must set <code>has_local_stop=True</code>. The method <code>stop_per_pair()</code> will be called whenever a trade closed (exit order completed).</p>"},{"location":"developer/#protections-global-protection","title":"Protections - global protection","text":"<p>These Protections should do their evaluation across all pairs, and consequently will also lock all pairs from trading (called a global PairLock). Global protection must set <code>has_global_stop=True</code> to be evaluated for global stops. The method <code>global_stop()</code> will be called whenever a trade closed (exit order completed).</p>"},{"location":"developer/#protections-calculating-lock-end-time","title":"Protections - calculating lock end time","text":"<p>Protections should calculate the lock end time based on the last trade it considers. This avoids re-locking should the lookback-period be longer than the actual lock period.</p> <p>The <code>IProtection</code> parent class provides a helper method for this in <code>calculate_lock_end()</code>.</p>"},{"location":"developer/#implement-a-new-exchange-wip","title":"Implement a new Exchange (WIP)","text":"<p>Note</p> <p>This section is a Work in Progress and is not a complete guide on how to test a new exchange with Freqtrade.</p> <p>Note</p> <p>Make sure to use an up-to-date version of CCXT before running any of the below tests. You can get the latest version of ccxt by running <code>pip install -U ccxt</code> with activated virtual environment. Native docker is not supported for these tests, however the available dev-container will support all required actions and eventually necessary changes.</p> <p>Most exchanges supported by CCXT should work out of the box.</p> <p>To quickly test the public endpoints of an exchange, add a configuration for your exchange to <code>tests/exchange_online/conftest.py</code> and run these tests with <code>pytest --longrun tests/exchange_online/test_ccxt_compat.py</code>. Completing these tests successfully a good basis point (it's a requirement, actually), however these won't guarantee correct exchange functioning, as this only tests public endpoints, but no private endpoint (like generate order or similar).</p> <p>Also try to use <code>freqtrade download-data</code> for an extended timerange (multiple months) and verify that the data downloaded correctly (no holes, the specified timerange was actually downloaded).</p> <p>These are prerequisites to have an exchange listed as either Supported or Community tested (listed on the homepage). The below are \"extras\", which will make an exchange better (feature-complete) - but are not absolutely necessary for either of the 2 categories.</p> <p>Additional tests / steps to complete:</p> <ul> <li>Verify data provided by <code>fetch_ohlcv()</code> - and eventually adjust <code>ohlcv_candle_limit</code> for this exchange</li> <li>Check L2 orderbook limit range (API documentation) - and eventually set as necessary</li> <li>Check if balance shows correctly (*)</li> <li>Create market order (*)</li> <li>Create limit order (*)</li> <li>Cancel order (*)</li> <li>Complete trade (enter + exit) (*)<ul> <li>Compare result calculation between exchange and bot</li> <li>Ensure fees are applied correctly (check the database against the exchange)</li> </ul> </li> </ul> <p>(*) Requires API keys and Balance on the exchange.</p>"},{"location":"developer/#stoploss-on-exchange","title":"Stoploss On Exchange","text":"<p>Check if the new exchange supports Stoploss on Exchange orders through their API.</p> <p>Since CCXT does not provide unification for Stoploss On Exchange yet, we'll need to implement the exchange-specific parameters ourselves. Best look at <code>binance.py</code> for an example implementation of this. You'll need to dig through the documentation of the Exchange's API on how exactly this can be done. CCXT Issues may also provide great help, since others may have implemented something similar for their projects.</p>"},{"location":"developer/#incomplete-candles","title":"Incomplete candles","text":"<p>While fetching candle (OHLCV) data, we may end up getting incomplete candles (depending on the exchange). To demonstrate this, we'll use daily candles (<code>\"1d\"</code>) to keep things simple. We query the api (<code>ct.fetch_ohlcv()</code>) for the timeframe and look at the date of the last entry. If this entry changes or shows the date of a \"incomplete\" candle, then we should drop this since having incomplete candles is problematic because indicators assume that only complete candles are passed to them, and will generate a lot of false buy signals. By default, we're therefore removing the last candle assuming it's incomplete.</p> <p>To check how the new exchange behaves, you can use the following snippet:</p> <pre><code>import ccxt\nfrom datetime import datetime, timezone\nfrom freqtrade.data.converter import ohlcv_to_dataframe\nct = ccxt.binance()  # Use the exchange you're testing\ntimeframe = \"1d\"\npair = \"BTC/USDT\"  # Make sure to use a pair that exists on that exchange!\nraw = ct.fetch_ohlcv(pair, timeframe=timeframe)\n\n# convert to dataframe\ndf1 = ohlcv_to_dataframe(raw, timeframe, pair=pair, drop_incomplete=False)\n\nprint(df1.tail(1))\nprint(datetime.now(timezone.utc))\n</code></pre> <pre><code>                         date      open      high       low     close  volume  \n499 2019-06-08 00:00:00+00:00  0.000007  0.000007  0.000007  0.000007   26264344.0  \n2019-06-09 12:30:27.873327\n</code></pre> <p>The output will show the last entry from the Exchange as well as the current UTC date. If the day shows the same day, then the last candle can be assumed as incomplete and should be dropped (leave the setting <code>\"ohlcv_partial_candle\"</code> from the exchange-class untouched / True). Otherwise, set <code>\"ohlcv_partial_candle\"</code> to <code>False</code> to not drop Candles (shown in the example above). Another way is to run this command multiple times in a row and observe if the volume is changing (while the date remains the same).</p>"},{"location":"developer/#update-binance-cached-leverage-tiers","title":"Update binance cached leverage tiers","text":"<p>Updating leveraged tiers should be done regularly - and requires an authenticated account with futures enabled.</p> <pre><code>import ccxt\nimport json\nfrom pathlib import Path\n\nexchange = ccxt.binance({\n    'apiKey': '&lt;apikey&gt;',\n    'secret': '&lt;secret&gt;',\n    'options': {'defaultType': 'swap'}\n    })\n_ = exchange.load_markets()\n\nlev_tiers = exchange.fetch_leverage_tiers()\n\n# Assumes this is running in the root of the repository.\nfile = Path('freqtrade/exchange/binance_leverage_tiers.json')\njson.dump(dict(sorted(lev_tiers.items())), file.open('w'), indent=2)\n</code></pre> <p>This file should then be contributed upstream, so others can benefit from this, too.</p>"},{"location":"developer/#updating-example-notebooks","title":"Updating example notebooks","text":"<p>To keep the jupyter notebooks aligned with the documentation, the following should be ran after updating a example notebook.</p> <pre><code>jupyter nbconvert --ClearOutputPreprocessor.enabled=True --inplace freqtrade/templates/strategy_analysis_example.ipynb\njupyter nbconvert --ClearOutputPreprocessor.enabled=True --to markdown freqtrade/templates/strategy_analysis_example.ipynb --stdout &gt; docs/strategy_analysis_example.md\n</code></pre>"},{"location":"developer/#continuous-integration","title":"Continuous integration","text":"<p>This documents some decisions taken for the CI Pipeline.</p> <ul> <li>CI runs on all OS variants, Linux (ubuntu), macOS and Windows.</li> <li>Docker images are build for the branches <code>stable</code> and <code>develop</code>, and are built as multiarch builds, supporting multiple platforms via the same tag.</li> <li>Docker images containing Plot dependencies are also available as <code>stable_plot</code> and <code>develop_plot</code>.</li> <li>Docker images contain a file, <code>/freqtrade/freqtrade_commit</code> containing the commit this image is based of.</li> <li>Full docker image rebuilds are run once a week via schedule.</li> <li>Deployments run on ubuntu.</li> <li>ta-lib binaries are contained in the build_helpers directory to avoid fails related to external unavailability.</li> <li>All tests must pass for a PR to be merged to <code>stable</code> or <code>develop</code>.</li> </ul>"},{"location":"developer/#creating-a-release","title":"Creating a release","text":"<p>This part of the documentation is aimed at maintainers, and shows how to create a release.</p>"},{"location":"developer/#create-release-branch","title":"Create release branch","text":"<p>Note</p> <p>Make sure that the <code>stable</code> branch is up-to-date!</p> <p>First, pick a commit that's about one week old (to not include latest additions to releases).</p> <pre><code># create new branch\ngit checkout -b new_release &lt;commitid&gt;\n</code></pre> <p>Determine if crucial bugfixes have been made between this commit and the current state, and eventually cherry-pick these.</p> <ul> <li>Merge the release branch (stable) into this branch.</li> <li>Edit <code>freqtrade/__init__.py</code> and add the version matching the current date (for example <code>2019.7</code> for July 2019). Minor versions can be <code>2019.7.1</code> should we need to do a second release that month. Version numbers must follow allowed versions from PEP0440 to avoid failures pushing to pypi.</li> <li>Commit this part.</li> <li>Push that branch to the remote and create a PR against the stable branch.</li> <li>Update develop version to next version following the pattern <code>2019.8-dev</code>.</li> </ul>"},{"location":"developer/#create-changelog-from-git-commits","title":"Create changelog from git commits","text":"<pre><code># Needs to be done before merging / pulling that branch.\ngit log --oneline --no-decorate --no-merges stable..new_release\n</code></pre> <p>To keep the release-log short, best wrap the full git changelog into a collapsible details section.</p> <pre><code>&lt;details&gt;\n&lt;summary&gt;Expand full changelog&lt;/summary&gt;\n\n... Full git changelog\n\n&lt;/details&gt;\n</code></pre>"},{"location":"developer/#frequi-release","title":"FreqUI release","text":"<p>If FreqUI has been updated substantially, make sure to create a release before merging the release branch. Make sure that freqUI CI on the release is finished and passed before merging the release.</p>"},{"location":"developer/#create-github-release-tag","title":"Create github release / tag","text":"<p>Once the PR against stable is merged (best right after merging):</p> <ul> <li>Use the button \"Draft a new release\" in the Github UI (subsection releases).</li> <li>Use the version-number specified as tag.</li> <li>Use \"stable\" as reference (this step comes after the above PR is merged).</li> <li>Use the above changelog as release comment (as codeblock).</li> <li>Use the below snippet for the new release</li> </ul> Release template <pre><code>## Highlighted changes\n\n- ...\n\n### How to update\n\nAs always, you can update your bot using one of the following commands:\n\n#### docker-compose\n\n```bash\ndocker-compose pull\ndocker-compose up -d\n```\n\n#### Installation via setup script\n\n```\n# Deactivate venv and run \n./setup.sh --update\n```\n\n#### Plain native installation\n\n```\ngit pull\npip install -U -r requirements.txt\n```\n\n&lt;details&gt;\n&lt;summary&gt;Expand full changelog&lt;/summary&gt;\n\n```\n&lt;Paste your changelog here&gt;\n```\n\n&lt;/details&gt;\n</code></pre>"},{"location":"developer/#releases","title":"Releases","text":""},{"location":"developer/#pypi","title":"pypi","text":"<p>Note</p> <p>This process is now automated as part of Github Actions.</p> <p>To create a pypi release, please run the following commands:</p> <p>Additional requirement: <code>wheel</code>, <code>twine</code> (for uploading), account on pypi with proper permissions.</p> <pre><code>python setup.py sdist bdist_wheel\n\n# For pypi test (to check if some change to the installation did work)\ntwine upload --repository-url https://test.pypi.org/legacy/ dist/*\n\n# For production:\ntwine upload dist/*\n</code></pre> <p>Please don't push non-releases to the productive / real pypi instance.</p>"},{"location":"docker_quickstart/","title":"Using Freqtrade with Docker","text":"<p>This page explains how to run the bot with Docker. It is not meant to work out of the box. You'll still need to read through the documentation and understand how to properly configure it.</p>"},{"location":"docker_quickstart/#install-docker","title":"Install Docker","text":"<p>Start by downloading and installing Docker / Docker Desktop for your platform:</p> <ul> <li>Mac</li> <li>Windows</li> <li>Linux</li> </ul> <p>Docker compose install</p> <p>Freqtrade documentation assumes the use of Docker desktop (or the docker compose plugin). While the docker-compose standalone installation still works, it will require changing all <code>docker compose</code> commands from <code>docker compose</code> to <code>docker-compose</code> to work (e.g. <code>docker compose up -d</code> will become <code>docker-compose up -d</code>).</p> Docker on windows <p>If you just installed docker on a windows system, make sure to reboot your system, otherwise you might encounter unexplainable Problems related to network connectivity to docker containers.</p>"},{"location":"docker_quickstart/#freqtrade-with-docker","title":"Freqtrade with docker","text":"<p>Freqtrade provides an official Docker image on Dockerhub, as well as a docker compose file ready for usage.</p> <p>Note</p> <ul> <li>The following section assumes that <code>docker</code> is installed and available to the logged in user.</li> <li>All below commands use relative directories and will have to be executed from the directory containing the <code>docker-compose.yml</code> file.</li> </ul>"},{"location":"docker_quickstart/#docker-quick-start","title":"Docker quick start","text":"<p>Create a new directory and place the docker-compose file in this directory.</p> <pre><code>mkdir ft_userdata\ncd ft_userdata/\n# Download the docker-compose file from the repository\ncurl https://raw.githubusercontent.com/freqtrade/freqtrade/stable/docker-compose.yml -o docker-compose.yml\n\n# Pull the freqtrade image\ndocker compose pull\n\n# Create user directory structure\ndocker compose run --rm freqtrade create-userdir --userdir user_data\n\n# Create configuration - Requires answering interactive questions\ndocker compose run --rm freqtrade new-config --config user_data/config.json\n</code></pre> <p>The above snippet creates a new directory called <code>ft_userdata</code>, downloads the latest compose file and pulls the freqtrade image. The last 2 steps in the snippet create the directory with <code>user_data</code>, as well as (interactively) the default configuration based on your selections.</p> <p>How to edit the bot configuration?</p> <p>You can edit the configuration at any time, which is available as <code>user_data/config.json</code> (within the directory <code>ft_userdata</code>) when using the above configuration.</p> <p>You can also change the both Strategy and commands by editing the command section of your <code>docker-compose.yml</code> file.</p>"},{"location":"docker_quickstart/#adding-a-custom-strategy","title":"Adding a custom strategy","text":"<ol> <li>The configuration is now available as <code>user_data/config.json</code></li> <li>Copy a custom strategy to the directory <code>user_data/strategies/</code></li> <li>Add the Strategy' class name to the <code>docker-compose.yml</code> file</li> </ol> <p>The <code>SampleStrategy</code> is run by default.</p> <p><code>SampleStrategy</code> is just a demo!</p> <p>The <code>SampleStrategy</code> is there for your reference and give you ideas for your own strategy. Please always backtest your strategy and use dry-run for some time before risking real money! You will find more information about Strategy development in the Strategy documentation.</p> <p>Once this is done, you're ready to launch the bot in trading mode (Dry-run or Live-trading, depending on your answer to the corresponding question you made above).</p> <pre><code>docker compose up -d\n</code></pre> <p>Default configuration</p> <p>While the configuration generated will be mostly functional, you will still need to verify that all options correspond to what you want (like Pricing, pairlist, ...) before starting the bot.</p>"},{"location":"docker_quickstart/#accessing-the-ui","title":"Accessing the UI","text":"<p>If you've selected to enable FreqUI in the <code>new-config</code> step, you will have freqUI available at port <code>localhost:8080</code>.</p> <p>You can now access the UI by typing localhost:8080 in your browser.</p> UI Access on a remote server <p>If you're running on a VPS, you should consider using either a ssh tunnel, or setup a VPN (openVPN, wireguard) to connect to your bot. This will ensure that freqUI is not directly exposed to the internet, which is not recommended for security reasons (freqUI does not support https out of the box). Setup of these tools is not part of this tutorial, however many good tutorials can be found on the internet. Please also read the API configuration with docker section to learn more about this configuration.</p>"},{"location":"docker_quickstart/#monitoring-the-bot","title":"Monitoring the bot","text":"<p>You can check for running instances with <code>docker compose ps</code>. This should list the service <code>freqtrade</code> as <code>running</code>. If that's not the case, best check the logs (see next point).</p>"},{"location":"docker_quickstart/#docker-compose-logs","title":"Docker compose logs","text":"<p>Logs will be written to: <code>user_data/logs/freqtrade.log</code>. You can also check the latest log with the command <code>docker compose logs -f</code>.</p>"},{"location":"docker_quickstart/#database","title":"Database","text":"<p>The database will be located at: <code>user_data/tradesv3.sqlite</code></p>"},{"location":"docker_quickstart/#updating-freqtrade-with-docker","title":"Updating freqtrade with docker","text":"<p>Updating freqtrade when using <code>docker</code> is as simple as running the following 2 commands:</p> <pre><code># Download the latest image\ndocker compose pull\n# Restart the image\ndocker compose up -d\n</code></pre> <p>This will first pull the latest image, and will then restart the container with the just pulled version.</p> <p>Check the Changelog</p> <p>You should always check the changelog for breaking changes / manual interventions required and make sure the bot starts correctly after the update.</p>"},{"location":"docker_quickstart/#editing-the-docker-compose-file","title":"Editing the docker-compose file","text":"<p>Advanced users may edit the docker-compose file further to include all possible options or arguments.</p> <p>All freqtrade arguments will be available by running <code>docker compose run --rm freqtrade &lt;command&gt; &lt;optional arguments&gt;</code>.</p> <p><code>docker compose</code> for trade commands</p> <p>Trade commands (<code>freqtrade trade &lt;...&gt;</code>) should not be ran via <code>docker compose run</code> - but should use <code>docker compose up -d</code> instead. This makes sure that the container is properly started (including port forwardings) and will make sure that the container will restart after a system reboot. If you intend to use freqUI, please also ensure to adjust the configuration accordingly, otherwise the UI will not be available.</p> <p><code>docker compose run --rm</code></p> <p>Including <code>--rm</code> will remove the container after completion, and is highly recommended for all modes except trading mode (running with <code>freqtrade trade</code> command).</p> Using docker without docker compose <p>\"<code>docker compose run --rm</code>\" will require a compose file to be provided. Some freqtrade commands that don't require authentication such as <code>list-pairs</code> can be run with \"<code>docker run --rm</code>\" instead. For example <code>docker run --rm freqtradeorg/freqtrade:stable list-pairs --exchange binance --quote BTC --print-json</code>. This can be useful for fetching exchange information to add to your <code>config.json</code> without affecting your running containers.</p>"},{"location":"docker_quickstart/#example-download-data-with-docker","title":"Example: Download data with docker","text":"<p>Download backtesting data for 5 days for the pair ETH/BTC and 1h timeframe from Binance. The data will be stored in the directory <code>user_data/data/</code> on the host.</p> <pre><code>docker compose run --rm freqtrade download-data --pairs ETH/BTC --exchange binance --days 5 -t 1h\n</code></pre> <p>Head over to the Data Downloading Documentation for more details on downloading data.</p>"},{"location":"docker_quickstart/#example-backtest-with-docker","title":"Example: Backtest with docker","text":"<p>Run backtesting in docker-containers for SampleStrategy and specified timerange of historical data, on 5m timeframe:</p> <pre><code>docker compose run --rm freqtrade backtesting --config user_data/config.json --strategy SampleStrategy --timerange 20190801-20191001 -i 5m\n</code></pre> <p>Head over to the Backtesting Documentation to learn more.</p>"},{"location":"docker_quickstart/#additional-dependencies-with-docker","title":"Additional dependencies with docker","text":"<p>If your strategy requires dependencies not included in the default image - it will be necessary to build the image on your host. For this, please create a Dockerfile containing installation steps for the additional dependencies (have a look at docker/Dockerfile.custom for an example).</p> <p>You'll then also need to modify the <code>docker-compose.yml</code> file and uncomment the build step, as well as rename the image to avoid naming collisions.</p> <pre><code>    image: freqtrade_custom\n    build:\n      context: .\n      dockerfile: \"./Dockerfile.&lt;yourextension&gt;\"\n</code></pre> <p>You can then run <code>docker compose build --pull</code> to build the docker image, and run it using the commands described above.</p>"},{"location":"docker_quickstart/#plotting-with-docker","title":"Plotting with docker","text":"<p>Commands <code>freqtrade plot-profit</code> and <code>freqtrade plot-dataframe</code> (Documentation) are available by changing the image to <code>*_plot</code> in your <code>docker-compose.yml</code> file. You can then use these commands as follows:</p> <pre><code>docker compose run --rm freqtrade plot-dataframe --strategy AwesomeStrategy -p BTC/ETH --timerange=20180801-20180805\n</code></pre> <p>The output will be stored in the <code>user_data/plot</code> directory, and can be opened with any modern browser.</p>"},{"location":"docker_quickstart/#data-analysis-using-docker-compose","title":"Data analysis using docker compose","text":"<p>Freqtrade provides a docker-compose file which starts up a jupyter lab server. You can run this server using the following command:</p> <pre><code>docker compose -f docker/docker-compose-jupyter.yml up\n</code></pre> <p>This will create a docker-container running jupyter lab, which will be accessible using <code>https://127.0.0.1:8888/lab</code>. Please use the link that's printed in the console after startup for simplified login.</p> <p>Since part of this image is built on your machine, it is recommended to rebuild the image from time to time to keep freqtrade (and dependencies) up-to-date.</p> <pre><code>docker compose -f docker/docker-compose-jupyter.yml build --no-cache\n</code></pre>"},{"location":"docker_quickstart/#troubleshooting","title":"Troubleshooting","text":""},{"location":"docker_quickstart/#docker-on-windows","title":"Docker on Windows","text":"<ul> <li> <p>Error: <code>\"Timestamp for this request is outside of the recvWindow.\"</code>   The market api requests require a synchronized clock but the time in the docker container shifts a bit over time into the past.   To fix this issue temporarily you need to run <code>wsl --shutdown</code> and restart docker again (a popup on windows 10 will ask you to do so).   A permanent solution is either to host the docker container on a linux host or restart the wsl from time to time with the scheduler.</p> <pre><code>taskkill /IM \"Docker Desktop.exe\" /F\nwsl --shutdown\nstart \"\" \"C:\\Program Files\\Docker\\Docker\\Docker Desktop.exe\"\n</code></pre> </li> </ul> <ul> <li>Cannot connect to the API (Windows)   If you're on windows and just installed Docker (desktop), make sure to reboot your System. Docker can have problems with network connectivity without a restart.   You should obviously also make sure to have your settings accordingly.</li> </ul> <p>Warning</p> <p>Due to the above, we do not recommend the usage of docker on windows for production setups, but only for experimentation, datadownload and backtesting. Best use a linux-VPS for running freqtrade reliably.</p>"},{"location":"edge/","title":"Edge positioning","text":"<p>The <code>Edge Positioning</code> module uses probability to calculate your win rate and risk reward ratio. It will use these statistics to control your strategy trade entry points, position size and, stoploss.</p> <p>Deprecated functionality</p> <p><code>Edge positioning</code> (or short Edge) is currently in maintenance mode only (we keep existing functionality alive) and should be considered as deprecated. It will currently not receive new features until either someone stepped forward to take up ownership of that module - or we'll decide to remove edge from freqtrade.</p> <p>Warning</p> <p>When using <code>Edge positioning</code> with a dynamic whitelist (VolumePairList), make sure to also use <code>AgeFilter</code> and set it to at least <code>calculate_since_number_of_days</code> to avoid problems with missing data.</p> <p>Note</p> <p><code>Edge Positioning</code> only considers its own buy/sell/stoploss signals. It ignores the stoploss, trailing stoploss, and ROI settings in the strategy configuration file. <code>Edge Positioning</code> improves the performance of some trading strategies and decreases the performance of others.</p>"},{"location":"edge/#introduction","title":"Introduction","text":"<p>Trading strategies are not perfect. They are frameworks that are susceptible to the market and its indicators. Because the market is not at all predictable, sometimes a strategy will win and sometimes the same strategy will lose.</p> <p>To obtain an edge in the market, a strategy has to make more money than it loses. Making money in trading is not only about how often the strategy makes or loses money.</p> <p>It doesn't matter how often, but how much!</p> <p>A bad strategy might make 1 penny in ten transactions but lose 1 dollar in one transaction. If one only checks the number of winning trades, it would be misleading to think that the strategy is actually making a profit.</p> <p>The Edge Positioning module seeks to improve a strategy's winning probability and the money that the strategy will make on the long run. </p> <p>We raise the following question<sup>1</sup>:</p> <p>Which trade is a better option?</p> <p>a) A trade with 80% of chance of losing 100$ and 20% chance of winning 200$ b) A trade with 100% of chance of losing 30$</p> Answer <p>The expected value of a) is smaller than the expected value of b). Hence, b) represents a smaller loss in the long run. However, the answer is: it depends</p> <p>Another way to look at it is to ask a similar question:</p> <p>Which trade is a better option?</p> <p>a) A trade with 80% of chance of winning 100$ and 20% chance of losing 200$ b) A trade with 100% of chance of winning 30$</p> <p>Edge positioning tries to answer the hard questions about risk/reward and position size automatically, seeking to minimizes the chances of losing of a given strategy.</p>"},{"location":"edge/#trading-winning-and-losing","title":"Trading, winning and losing","text":"<p>Let's call \\(o\\) the return of a single transaction \\(o\\) where \\(o \\in \\mathbb{R}\\). The collection \\(O = \\{o_1, o_2, ..., o_N\\}\\) is the set of all returns of transactions made during a trading session. We say that \\(N\\) is the cardinality of \\(O\\), or, in lay terms, it is the number of transactions made in a trading session.</p> <p>Example</p> <p>In a session where a strategy made three transactions we can say that \\(O = \\{3.5, -1, 15\\}\\). That means that \\(N = 3\\) and \\(o_1 = 3.5\\), \\(o_2 = -1\\), \\(o_3 = 15\\).</p> <p>A winning trade is a trade where a strategy made money. Making money means that the strategy closed the position in a value that returned a profit, after all deducted fees. Formally, a winning trade will have a return \\(o_i &gt; 0\\). Similarly, a losing trade will have a return \\(o_j \\leq 0\\). With that, we can discover the set of all winning trades, \\(T_{win}\\), as follows:</p> \\[ T_{win} = \\{ o \\in O | o &gt; 0 \\} \\] <p>Similarly, we can discover the set of losing trades \\(T_{lose}\\) as follows:</p> \\[ T_{lose} = \\{o \\in O | o \\leq 0\\} \\] <p>Example</p> <p>In a section where a strategy made four transactions \\(O = \\{3.5, -1, 15, 0\\}\\): \\(T_{win} = \\{3.5, 15\\}\\) \\(T_{lose} = \\{-1, 0\\}\\)</p>"},{"location":"edge/#win-rate-and-lose-rate","title":"Win Rate and Lose Rate","text":"<p>The win rate \\(W\\) is the proportion of winning trades with respect to all the trades made by a strategy. We use the following function to compute the win rate:</p> \\[W = \\frac{|T_{win}|}{N}\\] <p>Where \\(W\\) is the win rate, \\(N\\) is the number of trades and, \\(T_{win}\\) is the set of all trades where the strategy made money.</p> <p>Similarly, we can compute the rate of losing trades:</p> \\[      L = \\frac{|T_{lose}|}{N}  \\] <p>Where \\(L\\) is the lose rate, \\(N\\) is the amount of trades made and, \\(T_{lose}\\) is the set of all trades where the strategy lost money. Note that the above formula is the same as calculating \\(L = 1 \u2013 W\\) or \\(W = 1 \u2013 L\\)</p>"},{"location":"edge/#risk-reward-ratio","title":"Risk Reward Ratio","text":"<p>Risk Reward Ratio (\\(R\\)) is a formula used to measure the expected gains of a given investment against the risk of loss. It is basically what you potentially win divided by what you potentially lose. Formally:</p> \\[ R = \\frac{\\text{potential_profit}}{\\text{potential_loss}} \\] Worked example of \\(R\\) calculation <p>Let's say that you think that the price of stonecoin today is 10.0$. You believe that, because they will start mining stonecoin, it will go up to 15.0$ tomorrow. There is the risk that the stone is too hard, and the GPUs can't mine it, so the price might go to 0$ tomorrow. You are planning to invest 100$, which will give you 10 shares (100 / 10).</p> <p>Your potential profit is calculated as:</p> <p>\\(\\begin{aligned}      \\text{potential_profit} &amp;= (\\text{potential_price} - \\text{entry_price}) * \\frac{\\text{investment}}{\\text{entry_price}} \\\\                             &amp;= (15 - 10) * (100 / 10) \\\\                             &amp;= 50 \\end{aligned}\\)</p> <p>Since the price might go to 0$, the 100$ dollars invested could turn into 0.</p> <p>We do however use a stoploss of 15% - so in the worst case, we'll sell 15% below entry price (or at 8.5$).</p> <p>\\(\\begin{aligned}     \\text{potential_loss} &amp;= (\\text{entry_price} - \\text{stoploss}) * \\frac{\\text{investment}}{\\text{entry_price}} \\\\                             &amp;= (10 - 8.5) * (100 / 10)\\\\                             &amp;= 15 \\end{aligned}\\)</p> <p>We can compute the Risk Reward Ratio as follows:</p> <p>\\(\\begin{aligned}     R   &amp;= \\frac{\\text{potential_profit}}{\\text{potential_loss}}\\\\         &amp;= \\frac{50}{15}\\\\         &amp;= 3.33 \\end{aligned}\\) What it effectively means is that the strategy have the potential to make 3.33$ for each 1$ invested.</p> <p>On a long horizon, that is, on many trades, we can calculate the risk reward by dividing the strategy' average profit on winning trades by the strategy' average loss on losing trades. We can calculate the average profit, \\(\\mu_{win}\\), as follows:</p> \\[ \\text{average_profit} = \\mu_{win} = \\frac{\\text{sum_of_profits}}{\\text{count_winning_trades}} = \\frac{\\sum^{o \\in T_{win}} o}{|T_{win}|} \\] <p>Similarly, we can calculate the average loss, \\(\\mu_{lose}\\), as follows:</p> \\[ \\text{average_loss} = \\mu_{lose} = \\frac{\\text{sum_of_losses}}{\\text{count_losing_trades}} = \\frac{\\sum^{o \\in T_{lose}} o}{|T_{lose}|} \\] <p>Finally, we can calculate the Risk Reward ratio, \\(R\\), as follows:</p> \\[ R = \\frac{\\text{average_profit}}{\\text{average_loss}} = \\frac{\\mu_{win}}{\\mu_{lose}}\\\\ \\] Worked example of \\(R\\) calculation using mean profit/loss <p>Let's say the strategy that we are using makes an average win \\(\\mu_{win} = 2.06\\) and an average loss \\(\\mu_{loss} = 4.11\\). We calculate the risk reward ratio as follows: \\(R = \\frac{\\mu_{win}}{\\mu_{loss}} = \\frac{2.06}{4.11} = 0.5012...\\)</p>"},{"location":"edge/#expectancy","title":"Expectancy","text":"<p>By combining the Win Rate \\(W\\) and the Risk Reward ratio \\(R\\) to create an expectancy ratio \\(E\\). A expectance ratio is the expected return of the investment made in a trade. We can compute the value of \\(E\\) as follows:</p> \\[E = R * W - L\\] <p>Calculating \\(E\\)</p> <p>Let's say that a strategy has a win rate \\(W = 0.28\\) and a risk reward ratio \\(R = 5\\). What this means is that the strategy is expected to make 5 times the investment around on 28% of the trades it makes. Working out the example: \\(E = R * W - L = 5 * 0.28 - 0.72 = 0.68\\) </p> <p>The expectancy worked out in the example above means that, on average, this strategy' trades will return 1.68 times the size of its losses. Said another way, the strategy makes 1.68$ for every 1$ it loses, on average. </p> <p>This is important for two reasons: First, it may seem obvious, but you know right away that you have a positive return. Second, you now have a number you can compare to other candidate systems to make decisions about which ones you employ.</p> <p>It is important to remember that any system with an expectancy greater than 0 is profitable using past data. The key is finding one that will be profitable in the future.</p> <p>You can also use this value to evaluate the effectiveness of modifications to this system.</p> <p>Note</p> <p>It's important to keep in mind that Edge is testing your expectancy using historical data, there's no guarantee that you will have a similar edge in the future. It's still vital to do this testing in order to build confidence in your methodology but be wary of \"curve-fitting\" your approach to the historical data as things are unlikely to play out the exact same way for future trades.</p>"},{"location":"edge/#how-does-it-work","title":"How does it work?","text":"<p>Edge combines dynamic stoploss, dynamic positions, and whitelist generation into one isolated module which is then applied to the trading strategy. If enabled in config, Edge will go through historical data with a range of stoplosses in order to find buy and sell/stoploss signals. It then calculates win rate and expectancy over N trades for each stoploss. Here is an example:</p> Pair Stoploss Win Rate Risk Reward Ratio Expectancy XZC/ETH -0.01 0.50 1.176384 0.088 XZC/ETH -0.02 0.51 1.115941 0.079 XZC/ETH -0.03 0.52 1.359670 0.228 XZC/ETH -0.04 0.51 1.234539 0.117 <p>The goal here is to find the best stoploss for the strategy in order to have the maximum expectancy. In the above example stoploss at \\(3%\\) leads to the maximum expectancy according to historical data.</p> <p>Edge module then forces stoploss value it evaluated to your strategy dynamically.</p>"},{"location":"edge/#position-size","title":"Position size","text":"<p>Edge dictates the amount at stake for each trade to the bot according to the following factors:</p> <ul> <li>Allowed capital at risk</li> <li>Stoploss</li> </ul> <p>Allowed capital at risk is calculated as follows:</p> <pre><code>Allowed capital at risk = (Capital available_percentage) X (Allowed risk per trade)\n</code></pre> <p>Stoploss is calculated as described above with respect to historical data.</p> <p>The position size is calculated as follows:</p> <pre><code>Position size = (Allowed capital at risk) / Stoploss\n</code></pre> <p>Example:</p> <p>Let's say the stake currency is ETH and there is \\(10\\) ETH on the wallet. The capital available percentage is \\(50%\\) and the allowed risk per trade is \\(1\\%\\). Thus, the available capital for trading is \\(10 * 0.5 = 5\\) ETH and the allowed capital at risk would be \\(5 * 0.01 = 0.05\\) ETH.</p> <ul> <li>Trade 1: The strategy detects a new buy signal in the XLM/ETH market. <code>Edge Positioning</code> calculates a stoploss of \\(2\\%\\) and a position of \\(0.05 / 0.02 = 2.5\\) ETH. The bot takes a position of \\(2.5\\) ETH in the XLM/ETH market.</li> </ul> <ul> <li>Trade 2: The strategy detects a buy signal on the BTC/ETH market while Trade 1 is still open. <code>Edge Positioning</code> calculates the stoploss of \\(4\\%\\) on this market. Thus, Trade 2 position size is \\(0.05 / 0.04 = 1.25\\) ETH.</li> </ul> <p>Available Capital \\(\\neq\\) Available in wallet</p> <p>The available capital for trading didn't change in Trade 2 even with Trade 1 still open. The available capital is not the free amount in the wallet.</p> <ul> <li>Trade 3: The strategy detects a buy signal in the ADA/ETH market. <code>Edge Positioning</code> calculates a stoploss of \\(1\\%\\) and a position of \\(0.05 / 0.01 = 5\\) ETH. Since Trade 1 has \\(2.5\\) ETH blocked and Trade 2 has \\(1.25\\) ETH blocked, there is only \\(5 - 1.25 - 2.5 = 1.25\\) ETH available. Hence, the position size of Trade 3 is \\(1.25\\) ETH. </li> </ul> <p>Available Capital Updates</p> <p>The available capital does not change before a position is sold. After a trade is closed the Available Capital goes up if the trade was profitable or goes down if the trade was a loss.</p> <ul> <li>The strategy detects a sell signal in the XLM/ETH market. The bot exits Trade 1 for a profit of \\(1\\) ETH. The total capital in the wallet becomes \\(11\\) ETH and the available capital for trading becomes \\(5.5\\) ETH.</li> </ul> <ul> <li>Trade 4 The strategy detects a new buy signal int the XLM/ETH market. <code>Edge Positioning</code> calculates the stoploss of \\(2\\%\\), and the position size of \\(0.055 / 0.02 = 2.75\\) ETH.</li> </ul>"},{"location":"edge/#edge-command-reference","title":"Edge command reference","text":"<pre><code>usage: freqtrade edge [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH]\n                      [--userdir PATH] [-s NAME] [--strategy-path PATH]\n                      [-i TIMEFRAME] [--timerange TIMERANGE]\n                      [--data-format-ohlcv {json,jsongz,hdf5}]\n                      [--max-open-trades INT] [--stake-amount STAKE_AMOUNT]\n                      [--fee FLOAT] [-p PAIRS [PAIRS ...]]\n                      [--stoplosses STOPLOSS_RANGE]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -i TIMEFRAME, --timeframe TIMEFRAME\n                        Specify timeframe (`1m`, `5m`, `30m`, `1h`, `1d`).\n  --timerange TIMERANGE\n                        Specify what timerange of data to use.\n  --data-format-ohlcv {json,jsongz,hdf5}\n                        Storage format for downloaded candle (OHLCV) data.\n                        (default: `None`).\n  --max-open-trades INT\n                        Override the value of the `max_open_trades`\n                        configuration setting.\n  --stake-amount STAKE_AMOUNT\n                        Override the value of the `stake_amount` configuration\n                        setting.\n  --fee FLOAT           Specify fee ratio. Will be applied twice (on trade\n                        entry and exit).\n  -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...]\n                        Limit command to these pairs. Pairs are space-\n                        separated.\n  --stoplosses STOPLOSS_RANGE\n                        Defines a range of stoploss values against which edge\n                        will assess the strategy. The format is \"min,max,step\"\n                        (without any space). Example:\n                        `--stoplosses=-0.01,-0.1,-0.001`\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n\nStrategy arguments:\n  -s NAME, --strategy NAME\n                        Specify strategy class name which will be used by the\n                        bot.\n  --strategy-path PATH  Specify additional strategy lookup path.\n</code></pre>"},{"location":"edge/#configurations","title":"Configurations","text":"<p>Edge module has following configuration options:</p> Parameter Description <code>enabled</code> If true, then Edge will run periodically. Defaults to <code>false</code>. Datatype: Boolean <code>process_throttle_secs</code> How often should Edge run in seconds. Defaults to <code>3600</code> (once per hour). Datatype: Integer <code>calculate_since_number_of_days</code> Number of days of data against which Edge calculates Win Rate, Risk Reward and Expectancy.  Note that it downloads historical data so increasing this number would lead to slowing down the bot. Defaults to <code>7</code>. Datatype: Integer <code>allowed_risk</code> Ratio of allowed risk per trade. Defaults to <code>0.01</code> (1%)). Datatype: Float <code>stoploss_range_min</code> Minimum stoploss. Defaults to <code>-0.01</code>. Datatype: Float <code>stoploss_range_max</code> Maximum stoploss. Defaults to <code>-0.10</code>. Datatype: Float <code>stoploss_range_step</code> As an example if this is set to -0.01 then Edge will test the strategy for <code>[-0.01, -0,02, -0,03 ..., -0.09, -0.10]</code> ranges.  Note than having a smaller step means having a bigger range which could lead to slow calculation.  If you set this parameter to -0.001, you then slow down the Edge calculation by a factor of 10. Defaults to <code>-0.001</code>. Datatype: Float <code>minimum_winrate</code> It filters out pairs which don't have at least minimum_winrate. This comes handy if you want to be conservative and don't comprise win rate in favour of risk reward ratio. Defaults to <code>0.60</code>. Datatype: Float <code>minimum_expectancy</code> It filters out pairs which have the expectancy lower than this number. Having an expectancy of 0.20 means if you put 10$ on a trade you expect a 12$ return. Defaults to <code>0.20</code>. Datatype: Float <code>min_trade_number</code> When calculating W, R and E (expectancy) against historical data, you always want to have a minimum number of trades. The more this number is the more Edge is reliable. Having a win rate of 100% on a single trade doesn't mean anything at all. But having a win rate of 70% over past 100 trades means clearly something. Defaults to <code>10</code> (it is highly recommended not to decrease this number). Datatype: Integer <code>max_trade_duration_minute</code> Edge will filter out trades with long duration. If a trade is profitable after 1 month, it is hard to evaluate the strategy based on it. But if most of trades are profitable and they have maximum duration of 30 minutes, then it is clearly a good sign.NOTICE: While configuring this value, you should take into consideration your timeframe. As an example filtering out trades having duration less than one day for a strategy which has 4h interval does not make sense. Default value is set assuming your strategy interval is relatively small (1m or 5m, etc.).Defaults to <code>1440</code> (one day). Datatype: Integer <code>remove_pumps</code> Edge will remove sudden pumps in a given market while going through historical data. However, given that pumps happen very often in crypto markets, we recommend you keep this off.Defaults to <code>false</code>. Datatype: Boolean"},{"location":"edge/#running-edge-independently","title":"Running Edge independently","text":"<p>You can run Edge independently in order to see in details the result. Here is an example:</p> <pre><code>freqtrade edge\n</code></pre> <p>An example of its output:</p> pair stoploss win rate risk reward ratio required risk reward expectancy total number of trades average duration (min) AGI/BTC -0.02 0.64 5.86 0.56 3.41 14 54 NXS/BTC -0.03 0.64 2.99 0.57 1.54 11 26 LEND/BTC -0.02 0.82 2.05 0.22 1.50 11 36 VIA/BTC -0.01 0.55 3.01 0.83 1.19 11 48 MTH/BTC -0.09 0.56 2.82 0.80 1.12 18 52 ARDR/BTC -0.04 0.42 3.14 1.40 0.73 12 42 BCPT/BTC -0.01 0.71 1.34 0.40 0.67 14 30 WINGS/BTC -0.02 0.56 1.97 0.80 0.65 27 42 VIBE/BTC -0.02 0.83 0.91 0.20 0.59 12 35 MCO/BTC -0.02 0.79 0.97 0.27 0.55 14 31 GNT/BTC -0.02 0.50 2.06 1.00 0.53 18 24 HOT/BTC -0.01 0.17 7.72 4.81 0.50 209 7 SNM/BTC -0.03 0.71 1.06 0.42 0.45 17 38 APPC/BTC -0.02 0.44 2.28 1.27 0.44 25 43 NEBL/BTC -0.03 0.63 1.29 0.58 0.44 19 59 <p>Edge produced the above table by comparing <code>calculate_since_number_of_days</code> to <code>minimum_expectancy</code> to find <code>min_trade_number</code> historical information based on the config file. The timerange Edge uses for its comparisons can be further limited by using the <code>--timerange</code> switch.</p> <p>In live and dry-run modes, after the <code>process_throttle_secs</code> has passed, Edge will again process <code>calculate_since_number_of_days</code> against <code>minimum_expectancy</code> to find <code>min_trade_number</code>. If no <code>min_trade_number</code> is found, the bot will return \"whitelist empty\". Depending on the trade strategy being deployed, \"whitelist empty\" may be return much of the time - or all of the time. The use of Edge may also cause trading to occur in bursts, though this is rare.</p> <p>If you encounter \"whitelist empty\" a lot, condsider tuning <code>calculate_since_number_of_days</code>, <code>minimum_expectancy</code>  and <code>min_trade_number</code> to align to the trading frequency of your strategy.</p>"},{"location":"edge/#update-cached-pairs-with-the-latest-data","title":"Update cached pairs with the latest data","text":"<p>Edge requires historic data the same way as backtesting does. Please refer to the Data Downloading section of the documentation for details.</p>"},{"location":"edge/#precising-stoploss-range","title":"Precising stoploss range","text":"<pre><code>freqtrade edge --stoplosses=-0.01,-0.1,-0.001 #min,max,step\n</code></pre>"},{"location":"edge/#advanced-use-of-timerange","title":"Advanced use of timerange","text":"<pre><code>freqtrade edge --timerange=20181110-20181113\n</code></pre> <p>Doing <code>--timerange=-20190901</code> will get all available data until September 1<sup>st</sup> (excluding September 1<sup>st</sup> 2019).</p> <p>The full timerange specification:</p> <ul> <li>Use tickframes till 2018/01/31: <code>--timerange=-20180131</code></li> <li>Use tickframes since 2018/01/31: <code>--timerange=20180131-</code></li> <li>Use tickframes since 2018/01/31 till 2018/03/01 : <code>--timerange=20180131-20180301</code></li> <li>Use tickframes between POSIX timestamps 1527595200 1527618600: <code>--timerange=1527595200-1527618600</code></li> </ul> <ol> <li> <p>Question extracted from MIT Opencourseware S096 - Mathematics with applications in Finance: https://ocw.mit.edu/courses/mathematics/18-s096-topics-in-mathematics-with-applications-in-finance-fall-2013/ \u21a9</p> </li> </ol>"},{"location":"exchanges/","title":"Exchange-specific Notes","text":"<p>This page combines common gotchas and Information which are exchange-specific and most likely don't apply to other exchanges.</p>"},{"location":"exchanges/#exchange-configuration","title":"Exchange configuration","text":"<p>Freqtrade is based on CCXT library that supports over 100 cryptocurrency exchange markets and trading APIs. The complete up-to-date list can be found in the CCXT repo homepage. However, the bot was tested by the development team with only a few exchanges. A current list of these can be found in the \"Home\" section of this documentation.</p> <p>Feel free to test other exchanges and submit your feedback or PR to improve the bot or confirm exchanges that work flawlessly..</p> <p>Some exchanges require special configuration, which can be found below.</p>"},{"location":"exchanges/#sample-exchange-configuration","title":"Sample exchange configuration","text":"<p>A exchange configuration for \"binance\" would look as follows:</p> <pre><code>\"exchange\": {\n    \"name\": \"binance\",\n    \"key\": \"your_exchange_key\",\n    \"secret\": \"your_exchange_secret\",\n    \"ccxt_config\": {},\n    \"ccxt_async_config\": {},\n    // ... \n</code></pre>"},{"location":"exchanges/#setting-rate-limits","title":"Setting rate limits","text":"<p>Usually, rate limits set by CCXT are reliable and work well. In case of problems related to rate-limits (usually DDOS Exceptions in your logs), it's easy to change rateLimit settings to other values.</p> <pre><code>\"exchange\": {\n    \"name\": \"kraken\",\n    \"key\": \"your_exchange_key\",\n    \"secret\": \"your_exchange_secret\",\n    \"ccxt_config\": {\"enableRateLimit\": true},\n    \"ccxt_async_config\": {\n        \"enableRateLimit\": true,\n        \"rateLimit\": 3100\n    },\n</code></pre> <p>This configuration enables kraken, as well as rate-limiting to avoid bans from the exchange. <code>\"rateLimit\": 3100</code> defines a wait-event of 3.1s between each call. This can also be completely disabled by setting <code>\"enableRateLimit\"</code> to false.</p> <p>Note</p> <p>Optimal settings for rate-limiting depend on the exchange and the size of the whitelist, so an ideal parameter will vary on many other settings. We try to provide sensible defaults per exchange where possible, if you encounter bans please make sure that <code>\"enableRateLimit\"</code> is enabled and increase the <code>\"rateLimit\"</code> parameter step by step.</p>"},{"location":"exchanges/#binance","title":"Binance","text":"<p>Server location and geo-ip restrictions</p> <p>Please be aware that Binance restricts API access regarding the server country. The current and non-exhaustive countries blocked are Canada, Malaysia, Netherlands and United States. Please go to binance terms &gt; b. Eligibility to find up to date list.</p> <p>Binance supports time_in_force.</p> <p>Stoploss on Exchange</p> <p>Binance supports <code>stoploss_on_exchange</code> and uses <code>stop-loss-limit</code> orders. It provides great advantages, so we recommend to benefit from it by enabling stoploss on exchange. On futures, Binance supports both <code>stop-limit</code> as well as <code>stop-market</code> orders. You can use either <code>\"limit\"</code> or <code>\"market\"</code> in the <code>order_types.stoploss</code> configuration setting to decide which type to use.</p>"},{"location":"exchanges/#binance-blacklist-recommendation","title":"Binance Blacklist recommendation","text":"<p>For Binance, it is suggested to add <code>\"BNB/&lt;STAKE&gt;\"</code> to your blacklist to avoid issues, unless you are willing to maintain enough extra <code>BNB</code> on the account or unless you're willing to disable using <code>BNB</code> for fees. Binance accounts may use <code>BNB</code> for fees, and if a trade happens to be on <code>BNB</code>, further trades may consume this position and make the initial BNB trade unsellable as the expected amount is not there anymore.</p> <p>If not enough <code>BNB</code> is available to cover transaction fees, then fees will not be covered by <code>BNB</code> and no fee reduction will occur. Freqtrade will never buy BNB to cover for fees. BNB needs to be bought and monitored manually to this end.</p>"},{"location":"exchanges/#binance-sites","title":"Binance sites","text":"<p>Binance has been split into 2, and users must use the correct ccxt exchange ID for their exchange, otherwise API keys are not recognized.</p> <ul> <li>binance.com - International users. Use exchange id: <code>binance</code>.</li> <li>binance.us - US based users. Use exchange id: <code>binanceus</code>.</li> </ul>"},{"location":"exchanges/#binance-rsa-keys","title":"Binance RSA keys","text":"<p>Freqtrade supports binance RSA API keys.</p> <p>We recommend to use them as environment variable.</p> <pre><code>export FREQTRADE__EXCHANGE__SECRET=\"$(cat ./rsa_binance.private)\"\n</code></pre> <p>They can however also be configured via configuration file. Since json doesn't support multi-line strings, you'll have to replace all newlines with <code>\\n</code> to have a valid json file.</p> <pre><code>// ...\n \"key\": \"&lt;someapikey&gt;\",\n \"secret\": \"-----BEGIN PRIVATE KEY-----\\nMIIEvQIBABACAFQA&lt;...&gt;s8KX8=\\n-----END PRIVATE KEY-----\"\n// ...\n</code></pre>"},{"location":"exchanges/#binance-futures","title":"Binance Futures","text":"<p>Binance has specific (unfortunately complex) Futures Trading Quantitative Rules which need to be followed, and which prohibit a too low stake-amount (among others) for too many orders. Violating these rules will result in a trading restriction.</p> <p>When trading on Binance Futures market, orderbook must be used because there is no price ticker data for futures.</p> <pre><code>  \"entry_pricing\": {\n      \"use_order_book\": true,\n      \"order_book_top\": 1,\n      \"check_depth_of_market\": {\n          \"enabled\": false,\n          \"bids_to_ask_delta\": 1\n      }\n  },\n  \"exit_pricing\": {\n      \"use_order_book\": true,\n      \"order_book_top\": 1\n  },\n</code></pre>"},{"location":"exchanges/#binance-futures-settings","title":"Binance futures settings","text":"<p>Users will also have to have the futures-setting \"Position Mode\" set to \"One-way Mode\", and \"Asset Mode\" set to \"Single-Asset Mode\". These settings will be checked on startup, and freqtrade will show an error if this setting is wrong.</p> <p></p> <p>Freqtrade will not attempt to change these settings.</p>"},{"location":"exchanges/#bingx","title":"Bingx","text":"<p>BingX supports time_in_force with settings \"GTC\" (good till cancelled), \"IOC\" (immediate-or-cancel) and \"PO\" (Post only) settings.</p> <p>Stoploss on Exchange</p> <p>Bingx supports <code>stoploss_on_exchange</code> and can use both stop-limit and stop-market orders. It provides great advantages, so we recommend to benefit from it by enabling stoploss on exchange.</p>"},{"location":"exchanges/#kraken","title":"Kraken","text":"<p>Kraken supports time_in_force with settings \"GTC\" (good till cancelled), \"IOC\" (immediate-or-cancel) and \"PO\" (Post only) settings.</p> <p>Stoploss on Exchange</p> <p>Kraken supports <code>stoploss_on_exchange</code> and can use both stop-loss-market and stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it. You can use either <code>\"limit\"</code> or <code>\"market\"</code> in the <code>order_types.stoploss</code> configuration setting to decide which type to use.</p>"},{"location":"exchanges/#historic-kraken-data","title":"Historic Kraken data","text":"<p>The Kraken API does only provide 720 historic candles, which is sufficient for Freqtrade dry-run and live trade modes, but is a problem for backtesting. To download data for the Kraken exchange, using <code>--dl-trades</code> is mandatory, otherwise the bot will download the same 720 candles over and over, and you'll not have enough backtest data.</p> <p>To speed up downloading, you can download the trades zip files kraken provides. These are usually updated once per quarter. Freqtrade expects these files to be placed in <code>user_data/data/kraken/trades_csv</code>.</p> <p>A structure as follows can make sense if using incremental files, with the \"full\" history in one directory, and incremental files in different directories. The assumption for this mode is that the data is downloaded and unzipped keeping filenames as they are. Duplicate content will be ignored (based on timestamp) - though the assumption is that there is no gap in the data.</p> <p>This means, if your \"full\" history ends in Q4 2022 - then both incremental updates Q1 2023 and Q2 2023 are available. Not having this will lead to incomplete data, and therefore invalid results while using the data.</p> <pre><code>\u2514\u2500\u2500 trades_csv\n\u00a0 \u00a0 \u251c\u2500\u2500 Kraken_full_history\n \u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 BCHEUR.csv\n \u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 XBTEUR.csv\n \u00a0\u00a0 \u251c\u2500\u2500 Kraken_Trading_History_Q1_2023\n \u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 BCHEUR.csv\n \u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 XBTEUR.csv\n \u00a0\u00a0 \u2514\u2500\u2500 Kraken_Trading_History_Q2_2023\n \u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 BCHEUR.csv\n \u00a0\u00a0  \u00a0\u00a0 \u2514\u2500\u2500 XBTEUR.csv\n</code></pre> <p>You can convert these files into freqtrade files:</p> <pre><code>freqtrade convert-trade-data --exchange kraken --format-from kraken_csv --format-to feather\n# Convert trade data to different ohlcv timeframes\nfreqtrade trades-to-ohlcv -p BTC/EUR BCH/EUR --exchange kraken -t 1m 5m 15m 1h\n</code></pre> <p>The converted data also makes downloading data possible, and will start the download after the latest loaded trade.</p> <pre><code>freqtrade download-data --exchange kraken --dl-trades -p BTC/EUR BCH/EUR \n</code></pre> <p>Downloading data from kraken</p> <p>Downloading kraken data will require significantly more memory (RAM) than any other exchange, as the trades-data needs to be converted into candles on your machine. It will also take a long time, as freqtrade will need to download every single trade that happened on the exchange for the pair / timerange combination, therefore please be patient.</p> <p>rateLimit tuning</p> <p>Please pay attention that rateLimit configuration entry holds delay in milliseconds between requests, NOT requests\\sec rate. So, in order to mitigate Kraken API \"Rate limit exceeded\" exception, this configuration should be increased, NOT decreased.</p>"},{"location":"exchanges/#kucoin","title":"Kucoin","text":"<p>Kucoin requires a passphrase for each api key, you will therefore need to add this key into the configuration so your exchange section looks as follows:</p> <pre><code>\"exchange\": {\n    \"name\": \"kucoin\",\n    \"key\": \"your_exchange_key\",\n    \"secret\": \"your_exchange_secret\",\n    \"password\": \"your_exchange_api_key_password\",\n    // ...\n}\n</code></pre> <p>Kucoin supports time_in_force.</p> <p>Stoploss on Exchange</p> <p>Kucoin supports <code>stoploss_on_exchange</code> and can use both stop-loss-market and stop-loss-limit orders. It provides great advantages, so we recommend to benefit from it. You can use either <code>\"limit\"</code> or <code>\"market\"</code> in the <code>order_types.stoploss</code> configuration setting to decide which type of stoploss shall be used.</p>"},{"location":"exchanges/#kucoin-blacklists","title":"Kucoin Blacklists","text":"<p>For Kucoin, it is suggested to add <code>\"KCS/&lt;STAKE&gt;\"</code> to your blacklist to avoid issues, unless you are willing to maintain enough extra <code>KCS</code> on the account or unless you're willing to disable using <code>KCS</code> for fees.  Kucoin accounts may use <code>KCS</code> for fees, and if a trade happens to be on <code>KCS</code>, further trades may consume this position and make the initial <code>KCS</code> trade unsellable as the expected amount is not there anymore.</p>"},{"location":"exchanges/#htx-formerly-huobi","title":"HTX (formerly Huobi)","text":"<p>Stoploss on Exchange</p> <p>HTX supports <code>stoploss_on_exchange</code> and uses <code>stop-limit</code> orders. It provides great advantages, so we recommend to benefit from it by enabling stoploss on exchange.</p>"},{"location":"exchanges/#okx-former-okex","title":"OKX (former OKEX)","text":"<p>OKX requires a passphrase for each api key, you will therefore need to add this key into the configuration so your exchange section looks as follows:</p> <pre><code>\"exchange\": {\n    \"name\": \"okx\",\n    \"key\": \"your_exchange_key\",\n    \"secret\": \"your_exchange_secret\",\n    \"password\": \"your_exchange_api_key_password\",\n    // ...\n}\n</code></pre> <p>Warning</p> <p>OKX only provides 100 candles per api call. Therefore, the strategy will only have a pretty low amount of data available in backtesting mode.</p> <p>Futures</p> <p>OKX Futures has the concept of \"position mode\" - which can be \"Buy/Sell\" or long/short (hedge mode). Freqtrade supports both modes (we recommend to use Buy/Sell mode) - but changing the mode mid-trading is not supported and will lead to exceptions and failures to place trades. OKX also only provides MARK candles for the past ~3 months. Backtesting futures prior to that date will therefore lead to slight deviations, as funding-fees cannot be calculated correctly without this data.</p>"},{"location":"exchanges/#gateio","title":"Gate.io","text":"<p>Stoploss on Exchange</p> <p>Gate.io supports <code>stoploss_on_exchange</code> and uses <code>stop-loss-limit</code> orders. It provides great advantages, so we recommend to benefit from it by enabling stoploss on exchange..</p> <p>Gate.io allows the use of <code>POINT</code> to pay for fees. As this is not a tradable currency (no regular market available), automatic fee calculations will fail (and default to a fee of 0). The configuration parameter <code>exchange.unknown_fee_rate</code> can be used to specify the exchange rate between Point and the stake currency. Obviously, changing the stake-currency will also require changes to this value.</p>"},{"location":"exchanges/#bybit","title":"Bybit","text":"<p>Futures trading on bybit is currently supported for USDT markets, and will use isolated futures mode. Users with unified accounts (there's no way back) can create a Sub-account which will start as \"non-unified\", and can therefore use isolated futures. On startup, freqtrade will set the position mode to \"One-way Mode\" for the whole (sub)account. This avoids making this call over and over again (slowing down bot operations), but means that changes to this setting may result in exceptions and errors</p> <p>As bybit doesn't provide funding rate history, the dry-run calculation is used for live trades as well.</p> <p>API Keys for live futures trading (Subaccount on non-unified) must have the following permissions: * Read-write * Contract - Orders * Contract - Positions</p> <p>We do strongly recommend to limit all API keys to the IP you're going to use it from.</p> <p>Stoploss on Exchange</p> <p>Bybit (futures only) supports <code>stoploss_on_exchange</code> and uses <code>stop-loss-limit</code> orders. It provides great advantages, so we recommend to benefit from it by enabling stoploss on exchange. On futures, Bybit supports both <code>stop-limit</code> as well as <code>stop-market</code> orders. You can use either <code>\"limit\"</code> or <code>\"market\"</code> in the <code>order_types.stoploss</code> configuration setting to decide which type to use.</p>"},{"location":"exchanges/#bitmart","title":"Bitmart","text":"<p>Bitmart requires the API key Memo (the name you give the API key) to go along with the exchange key and secret. It's therefore required to pass the UID as well.</p> <pre><code>\"exchange\": {\n    \"name\": \"bitmart\",\n    \"uid\": \"your_bitmart_api_key_memo\",\n    \"secret\": \"your_exchange_secret\",\n    \"password\": \"your_exchange_api_key_password\",\n    // ...\n}\n</code></pre> <p>Necessary Verification</p> <p>Bitmart requires Verification Lvl2 to successfully trade on the spot market through the API - even though trading via UI works just fine with just Lvl1 verification.</p>"},{"location":"exchanges/#all-exchanges","title":"All exchanges","text":"<p>Should you experience constant errors with Nonce (like <code>InvalidNonce</code>), it is best to regenerate the API keys. Resetting Nonce is difficult and it's usually easier to regenerate the API keys.</p>"},{"location":"exchanges/#random-notes-for-other-exchanges","title":"Random notes for other exchanges","text":"<ul> <li>The Ocean (exchange id: <code>theocean</code>) exchange uses Web3 functionality and requires <code>web3</code> python package to be installed:</li> </ul> <pre><code>$ pip3 install web3\n</code></pre>"},{"location":"exchanges/#getting-latest-price-incomplete-candles","title":"Getting latest price / Incomplete candles","text":"<p>Most exchanges return current incomplete candle via their OHLCV/klines API interface. By default, Freqtrade assumes that incomplete candle is fetched from the exchange and removes the last candle assuming it's the incomplete candle.</p> <p>Whether your exchange returns incomplete candles or not can be checked using the helper script from the Contributor documentation.</p> <p>Due to the danger of repainting, Freqtrade does not allow you to use this incomplete candle.</p> <p>However, if it is based on the need for the latest price for your strategy - then this requirement can be acquired using the data provider from within the strategy.</p>"},{"location":"exchanges/#advanced-freqtrade-exchange-configuration","title":"Advanced Freqtrade Exchange configuration","text":"<p>Advanced options can be configured using the <code>_ft_has_params</code> setting, which will override Defaults and exchange-specific behavior.</p> <p>Available options are listed in the exchange-class as <code>_ft_has_default</code>.</p> <p>For example, to test the order type <code>FOK</code> with Kraken, and modify candle limit to 200 (so you only get 200 candles per API call):</p> <pre><code>\"exchange\": {\n    \"name\": \"kraken\",\n    \"_ft_has_params\": {\n        \"order_time_in_force\": [\"GTC\", \"FOK\"],\n        \"ohlcv_candle_limit\": 200\n        }\n    //...\n}\n</code></pre> <p>Warning</p> <p>Please make sure to fully understand the impacts of these settings before modifying them.</p>"},{"location":"faq/","title":"Freqtrade FAQ","text":""},{"location":"faq/#supported-markets","title":"Supported Markets","text":"<p>Freqtrade supports spot trading, as well as (isolated) futures trading for some selected exchanges. Please refer to the documentation start page for an up-to-date list of supported exchanges.</p>"},{"location":"faq/#can-my-bot-open-short-positions","title":"Can my bot open short positions?","text":"<p>Freqtrade can open short positions in futures markets. This requires the strategy to be made for this - and <code>\"trading_mode\": \"futures\"</code> in the configuration. Please make sure to read the relevant documentation page first.</p> <p>In spot markets, you can in some cases use leveraged spot tokens, which reflect an inverted pair (eg. BTCUP/USD, BTCDOWN/USD, ETHBULL/USD, ETHBEAR/USD,...) which can be traded with Freqtrade.</p>"},{"location":"faq/#can-my-bot-trade-options-or-futures","title":"Can my bot trade options or futures?","text":"<p>Futures trading is supported for selected exchanges. Please refer to the documentation start page for an up-to-date list of supported exchanges.</p>"},{"location":"faq/#beginner-tips-tricks","title":"Beginner Tips &amp; Tricks","text":"<ul> <li>When you work with your strategy &amp; hyperopt file you should use a proper code editor like VSCode or PyCharm. A good code editor will provide syntax highlighting as well as line numbers, making it easy to find syntax errors (most likely pointed out by Freqtrade during startup).</li> </ul>"},{"location":"faq/#freqtrade-common-questions","title":"Freqtrade common questions","text":""},{"location":"faq/#can-freqtrade-open-multiple-positions-on-the-same-pair-in-parallel","title":"Can freqtrade open multiple positions on the same pair in parallel?","text":"<p>No. Freqtrade will only open one position per pair at a time. You can however use the <code>adjust_trade_position()</code> callback to adjust an open position.</p> <p>Backtesting provides an option for this in <code>--eps</code> - however this is only there to highlight \"hidden\" signals, and will not work in live.</p>"},{"location":"faq/#the-bot-does-not-start","title":"The bot does not start","text":"<p>Running the bot with <code>freqtrade trade --config config.json</code> shows the output <code>freqtrade: command not found</code>.</p> <p>This could be caused by the following reasons:</p> <ul> <li>The virtual environment is not active.<ul> <li>Run <code>source .venv/bin/activate</code> to activate the virtual environment.</li> </ul> </li> <li>The installation did not complete successfully.<ul> <li>Please check the Installation documentation.</li> </ul> </li> </ul>"},{"location":"faq/#i-have-waited-5-minutes-why-hasnt-the-bot-made-any-trades-yet","title":"I have waited 5 minutes, why hasn't the bot made any trades yet?","text":"<ul> <li>Depending on the buy strategy, the amount of whitelisted coins, the situation of the market etc, it can take up to hours to find a good entry position for a trade. Be patient!</li> </ul> <ul> <li>It may be because of a configuration error. It's best to check the logs, they usually tell you if the bot is simply not getting buy signals (only heartbeat messages), or if there is something wrong (errors / exceptions in the log).</li> </ul>"},{"location":"faq/#i-have-made-12-trades-already-why-is-my-total-profit-negative","title":"I have made 12 trades already, why is my total profit negative?","text":"<p>I understand your disappointment but unfortunately 12 trades is just not enough to say anything. If you run backtesting, you can see that the current algorithm does leave you on the plus side, but that is after thousands of trades and even there, you will be left with losses on specific coins that you have traded tens if not hundreds of times. We of course constantly aim to improve the bot but it will always be a gamble, which should leave you with modest wins on monthly basis but you can't say much from few trades.</p>"},{"location":"faq/#id-like-to-make-changes-to-the-config-can-i-do-that-without-having-to-kill-the-bot","title":"I\u2019d like to make changes to the config. Can I do that without having to kill the bot?","text":"<p>Yes. You can edit your config and use the <code>/reload_config</code> command to reload the configuration. The bot will stop, reload the configuration and strategy and will restart with the new configuration and strategy.</p>"},{"location":"faq/#why-does-my-bot-not-sell-everything-it-bought","title":"Why does my bot not sell everything it bought?","text":"<p>This is called \"coin dust\" and can happen on all exchanges. It happens because many exchanges subtract fees from the \"receiving currency\" - so you buy 100 COIN - but you only get 99.9 COIN. As COIN is trading in full lot sizes (1COIN steps), you cannot sell 0.9 COIN (or 99.9 COIN) - but you need to round down to 99 COIN.</p> <p>This is not a bot-problem, but will also happen while manual trading.</p> <p>While freqtrade can handle this (it'll sell 99 COIN), fees are often below the minimum tradable lot-size (you can only trade full COIN, not 0.9 COIN). Leaving the dust (0.9 COIN) on the exchange makes usually sense, as the next time freqtrade buys COIN, it'll eat into the remaining small balance, this time selling everything it bought, and therefore slowly declining the dust balance (although it most likely will never reach exactly 0).</p> <p>Where possible (e.g. on binance), the use of the exchange's dedicated fee currency will fix this. On binance, it's sufficient to have BNB in your account, and have \"Pay fees in BNB\" enabled in your profile. Your BNB balance will slowly decline (as it's used to pay fees) - but you'll no longer encounter dust (Freqtrade will include the fees in the profit calculations). Other exchanges don't offer such possibilities, where it's simply something you'll have to accept or move to a different exchange.</p>"},{"location":"faq/#i-deposited-more-funds-to-the-exchange-but-my-bot-doesnt-recognize-this","title":"I deposited more funds to the exchange, but my bot doesn't recognize this","text":"<p>Freqtrade will update the exchange balance when necessary (Before placing an order). RPC calls (Telegram's <code>/balance</code>, API calls to <code>/balance</code>) can trigger an update at max. once per hour.</p> <p>If <code>adjust_trade_position</code> is enabled (and the bot has open trades eligible for position adjustments) - then the wallets will be refreshed once per hour. To force an immediate update, you can use <code>/reload_config</code> - which will restart the bot.</p>"},{"location":"faq/#i-want-to-use-incomplete-candles","title":"I want to use incomplete candles","text":"<p>Freqtrade will not provide incomplete candles to strategies. Using incomplete candles will lead to repainting and consequently to strategies with \"ghost\" buys, which are impossible to both backtest, and verify after they happened.</p> <p>You can use \"current\" market data by using the dataprovider's orderbook or ticker methods - which however cannot be used during backtesting.</p>"},{"location":"faq/#is-there-a-setting-to-only-exit-the-trades-being-held-and-not-perform-any-new-entries","title":"Is there a setting to only Exit the trades being held and not perform any new Entries?","text":"<p>You can use the <code>/stopentry</code> command in Telegram to prevent future trade entry, followed by <code>/forceexit all</code> (sell all open trades).</p>"},{"location":"faq/#i-want-to-run-multiple-bots-on-the-same-machine","title":"I want to run multiple bots on the same machine","text":"<p>Please look at the advanced setup documentation Page.</p>"},{"location":"faq/#im-getting-missing-data-fillup-messages-in-the-log","title":"I'm getting \"Missing data fillup\" messages in the log","text":"<p>This message is just a warning that the latest candles had missing candles in them. Depending on the exchange, this can indicate that the pair didn't have a trade for the timeframe you are using - and the exchange does only return candles with volume. On low volume pairs, this is a rather common occurrence.</p> <p>If this happens for all pairs in the pairlist, this might indicate a recent exchange downtime. Please check your exchange's public channels for details.</p> <p>Irrespectively of the reason, Freqtrade will fill up these candles with \"empty\" candles, where open, high, low and close are set to the previous candle close - and volume is empty. In a chart, this will look like a <code>_</code> - and is aligned with how exchanges usually represent 0 volume candles.</p>"},{"location":"faq/#im-getting-price-jump-between-2-candles-detected","title":"I'm getting \"Price jump between 2 candles detected\"","text":"<p>This message is a warning that the candles had a price jump of &gt; 30%. This might be a sign that the pair stopped trading, and some token exchange took place (e.g. COCOS in 2021 - where price jumped from 0.0000154 to 0.01621). This message is often accompanied by \"Missing data fillup\" - as trading on such pairs is often stopped for some time.</p>"},{"location":"faq/#im-getting-outdated-history-for-pair-xxx-in-the-log","title":"I'm getting \"Outdated history for pair xxx\" in the log","text":"<p>The bot is trying to tell you that it got an outdated last candle (not the last complete candle). As a consequence, Freqtrade will not enter a trade for this pair - as trading on old information is usually not what is desired.</p> <p>This warning can point to one of the below problems:</p> <ul> <li>Exchange downtime -&gt; Check your exchange status page / blog / twitter feed for details.</li> <li>Wrong system time -&gt; Ensure your system-time is correct.</li> <li>Barely traded pair -&gt; Check the pair on the exchange webpage, look at the timeframe your strategy uses. If the pair does not have any volume in some candles (usually visualized with a \"volume 0\" bar, and a \"_\" as candle), this pair did not have any trades in this timeframe. These pairs should ideally be avoided, as they can cause problems with order-filling.</li> <li>API problem -&gt; API returns wrong data (this only here for completeness, and should not happen with supported exchanges).</li> </ul>"},{"location":"faq/#im-getting-the-exchange-xxx-does-not-support-market-orders-message-and-cannot-run-my-strategy","title":"I'm getting the \"Exchange XXX does not support market orders.\" message and cannot run my strategy","text":"<p>As the message says, your exchange does not support market orders and you have one of the order types set to \"market\". Your strategy was probably written with other exchanges in mind and sets \"market\" orders for \"stoploss\" orders, which is correct and preferable for most of the exchanges supporting market orders (but not for Gate.io).</p> <p>To fix this, redefine order types in the strategy to use \"limit\" instead of \"market\":</p> <pre><code>    order_types = {\n        ...\n        \"stoploss\": \"limit\",\n        ...\n    }\n</code></pre> <p>The same fix should be applied in the configuration file, if order types are defined in your custom config rather than in the strategy.</p>"},{"location":"faq/#im-trying-to-start-the-bot-live-but-get-an-api-permission-error","title":"I'm trying to start the bot live, but get an API permission error","text":"<p>Errors like <code>Invalid API-key, IP, or permissions for action</code> mean exactly what they actually say. Your API key is either invalid (copy/paste error? check for leading/trailing spaces in the config), expired, or the IP you're running the bot from is not enabled in the Exchange's API console. Usually, the permission \"Spot Trading\" (or the equivalent in the exchange you use) will be necessary. Futures will usually have to be enabled specifically.</p>"},{"location":"faq/#how-do-i-search-the-bot-logs-for-something","title":"How do I search the bot logs for something?","text":"<p>By default, the bot writes its log into stderr stream. This is implemented this way so that you can easily separate the bot's diagnostics messages from Backtesting, Edge and Hyperopt results, output from other various Freqtrade utility sub-commands, as well as from the output of your custom <code>print()</code>'s you may have inserted into your strategy. So if you need to search the log messages with the grep utility, you need to redirect stderr to stdout and disregard stdout.</p> <ul> <li>In unix shells, this normally can be done as simple as: <pre><code>$ freqtrade --some-options 2&gt;&amp;1 &gt;/dev/null | grep 'something'\n</code></pre> (note, <code>2&gt;&amp;1</code> and <code>&gt;/dev/null</code> should be written in this order)</li> </ul> <ul> <li>Bash interpreter also supports so called process substitution syntax, you can grep the log for a string with it as: <pre><code>$ freqtrade --some-options 2&gt; &gt;(grep 'something') &gt;/dev/null\n</code></pre> or <pre><code>$ freqtrade --some-options 2&gt; &gt;(grep -v 'something' 1&gt;&amp;2)\n</code></pre></li> </ul> <ul> <li>You can also write the copy of Freqtrade log messages to a file with the <code>--logfile</code> option: <pre><code>$ freqtrade --logfile /path/to/mylogfile.log --some-options\n</code></pre> and then grep it as: <pre><code>$ cat /path/to/mylogfile.log | grep 'something'\n</code></pre> or even on the fly, as the bot works and the log file grows: <pre><code>$ tail -f /path/to/mylogfile.log | grep 'something'\n</code></pre> from a separate terminal window.</li> </ul> <p>On Windows, the <code>--logfile</code> option is also supported by Freqtrade and you can use the <code>findstr</code> command to search the log for the string of interest: <pre><code>&gt; type \\path\\to\\mylogfile.log | findstr \"something\"\n</code></pre></p>"},{"location":"faq/#hyperopt-module","title":"Hyperopt module","text":""},{"location":"faq/#why-does-freqtrade-not-have-gpu-support","title":"Why does freqtrade not have GPU support?","text":"<p>First of all, most indicator libraries don't have GPU support - as such, there would be little benefit for indicator calculations. The GPU improvements would only apply to pandas-native calculations - or ones written by yourself.</p> <p>For hyperopt, freqtrade is using scikit-optimize, which is built on top of scikit-learn. Their statement about GPU support is pretty clear.</p> <p>GPU's also are only good at crunching numbers (floating point operations). For hyperopt, we need both number-crunching (find next parameters) and running python code (running backtesting). As such, GPU's are not too well suited for most parts of hyperopt.</p> <p>The benefit of using GPU would therefore be pretty slim - and will not justify the complexity introduced by trying to add GPU support.</p> <p>There is however nothing preventing you from using GPU-enabled indicators within your strategy if you think you must have this - you will however probably be disappointed by the slim gain that will give you (compared to the complexity).</p>"},{"location":"faq/#how-many-epochs-do-i-need-to-get-a-good-hyperopt-result","title":"How many epochs do I need to get a good Hyperopt result?","text":"<p>Per default Hyperopt called without the <code>-e</code>/<code>--epochs</code> command line option will only run 100 epochs, means 100 evaluations of your triggers, guards, ... Too few to find a great result (unless if you are very lucky), so you probably have to run it for 10000 or more. But it will take an eternity to compute.</p> <p>Since hyperopt uses Bayesian search, running for too many epochs may not produce greater results.</p> <p>It's therefore recommended to run between 500-1000 epochs over and over until you hit at least 10000 epochs in total (or are satisfied with the result). You can best judge by looking at the results - if the bot keeps discovering better strategies, it's best to keep on going.</p> <pre><code>freqtrade hyperopt --hyperopt-loss SharpeHyperOptLossDaily --strategy SampleStrategy -e 1000\n</code></pre>"},{"location":"faq/#why-does-it-take-a-long-time-to-run-hyperopt","title":"Why does it take a long time to run hyperopt?","text":"<ul> <li>Discovering a great strategy with Hyperopt takes time. Study www.freqtrade.io, the Freqtrade Documentation page, join the Freqtrade discord community. While you patiently wait for the most advanced, free crypto bot in the world, to hand you a possible golden strategy specially designed just for you.</li> </ul> <ul> <li>If you wonder why it can take from 20 minutes to days to do 1000 epochs here are some answers:</li> </ul> <p>This answer was written during the release 0.15.1, when we had:</p> <ul> <li>8 triggers</li> <li>9 guards: let's say we evaluate even 10 values from each</li> <li>1 stoploss calculation: let's say we want 10 values from that too to be evaluated</li> </ul> <p>The following calculation is still very rough and not very precise but it will give the idea. With only these triggers and guards there is already 8*10^9*10 evaluations. A roughly total of 80 billion evaluations. Did you run 100 000 evaluations? Congrats, you've done roughly 1 / 100 000 th of the search space, assuming that the bot never tests the same parameters more than once.</p> <ul> <li>The time it takes to run 1000 hyperopt epochs depends on things like: The available cpu, hard-disk, ram, timeframe, timerange, indicator settings, indicator count, amount of coins that hyperopt test strategies on and the resulting trade count - which can be 650 trades in a year or 100000 trades depending if the strategy aims for big profits by trading rarely or for many low profit trades.</li> </ul> <p>Example: 4% profit 650 times vs 0,3% profit a trade 10000 times in a year. If we assume you set the --timerange to 365 days.</p> <p>Example: <code>freqtrade --config config.json --strategy SampleStrategy --hyperopt SampleHyperopt -e 1000 --timerange 20190601-20200601</code></p>"},{"location":"faq/#edge-module","title":"Edge module","text":""},{"location":"faq/#edge-implements-interesting-approach-for-controlling-position-size-is-there-any-theory-behind-it","title":"Edge implements interesting approach for controlling position size, is there any theory behind it?","text":"<p>The Edge module is mostly a result of brainstorming of @mishaker and @creslinux freqtrade team members.</p> <p>You can find further info on expectancy, win rate, risk management and position size in the following sources:</p> <ul> <li>https://www.tradeciety.com/ultimate-math-guide-for-traders/</li> <li>https://samuraitradingacademy.com/trading-expectancy/</li> <li>https://www.learningmarkets.com/determining-expectancy-in-your-trading/</li> <li>https://www.lonestocktrader.com/make-money-trading-positive-expectancy/</li> <li>https://www.babypips.com/trading/trade-expectancy-matter</li> </ul>"},{"location":"faq/#official-channels","title":"Official channels","text":"<p>Freqtrade is using exclusively the following official channels:</p> <ul> <li>Freqtrade discord server</li> <li>Freqtrade documentation (https://freqtrade.io)</li> <li>Freqtrade github organization</li> </ul> <p>Nobody affiliated with the freqtrade project will ask you about your exchange keys or anything else exposing your funds to exploitation. Should you be asked to expose your exchange keys or send funds to some random wallet, then please don't follow these instructions.</p> <p>Failing to follow these guidelines will not be responsibility of freqtrade.</p>"},{"location":"faq/#freqtrade-token","title":"\"Freqtrade token\"","text":"<p>Freqtrade does not have a Crypto token offering.</p> <p>Token offerings you find on the internet referring Freqtrade, FreqAI or freqUI must be considered to be a scam, trying to exploit freqtrade's popularity for their own, nefarious gains.</p>"},{"location":"freq-ui/","title":"FreqUI","text":"<p>Freqtrade provides a builtin webserver, which can serve FreqUI, the freqtrade frontend.</p> <p>By default, the UI is automatically installed as part of the installation (script, docker). freqUI can also be manually installed by using the <code>freqtrade install-ui</code> command. This same command can also be used to update freqUI to new new releases.</p> <p>Once the bot is started in trade / dry-run mode (with <code>freqtrade trade</code>) - the UI will be available under the configured API port (by default <code>http://127.0.0.1:8080</code>).</p> Looking to contribute to freqUI? <p>Developers should not use this method, but instead clone the corresponding use the method described in the freqUI repository to get the source-code of freqUI. A working installation of node will be required to build the frontend.</p> <p>freqUI is not required to run freqtrade</p> <p>freqUI is an optional component of freqtrade, and is not required to run the bot. It is a frontend that can be used to monitor the bot and to interact with it - but freqtrade itself will work perfectly fine without it.</p>"},{"location":"freq-ui/#configuration","title":"Configuration","text":"<p>FreqUI does not have it's own configuration file - but assumes a working setup for the rest-api is available. Please refer to the corresponding documentation page to get setup with freqUI</p>"},{"location":"freq-ui/#ui","title":"UI","text":"<p>FreqUI is a modern, responsive web application that can be used to monitor and interact with your bot.</p> <p>FreqUI provides a light, as well as a dark theme. Themes can be easily switched via a prominent button at the top of the page. The theme of the screenshots on this page will adapt to the selected documentation Theme, so to see the dark (or light) version, please switch the theme of the Documentation.</p>"},{"location":"freq-ui/#login","title":"Login","text":"<p>The below screenshot shows the login screen of freqUI.</p> <p> </p> <p>CORS</p> <p>The Cors error shown in this screenshot is due to the fact that the UI is running on a different port than the API, and CORS has not been setup correctly yet.</p>"},{"location":"freq-ui/#trade-view","title":"Trade view","text":"<p>The trade view allows you to visualize the trades that the bot is making and to interact with the bot. On this page, you can also interact with the bot by starting and stopping it and - if configured - force trade entries and exits.</p> <p> </p>"},{"location":"freq-ui/#plot-configurator","title":"Plot Configurator","text":"<p>FreqUI Plots can be configured either via a <code>plot_config</code> configuration object in the strategy (which can be loaded via \"from strategy\" button) or via the UI. Multiple plot configurations can be created and switched at will - allowing for flexible, different views into your charts.</p> <p>The plot configuration can be accessed via the \"Plot Configurator\" (Cog icon) button in the top right corner of the trade view.</p> <p> </p>"},{"location":"freq-ui/#settings","title":"Settings","text":"<p>Several UI related settings can be changed by accessing the settings page.</p> <p>Things you can change (among others):</p> <ul> <li>Timezone of the UI</li> <li>Visualization of open trades as part of the favicon (browser tab)</li> <li>Candle colors (up/down -&gt; red/green)</li> <li>Enable / disable in-app notification types</li> </ul> <p> </p>"},{"location":"freq-ui/#backtesting","title":"Backtesting","text":"<p>When freqtrade is started in webserver mode (freqtrade started with <code>freqtrade webserver</code>), the backtesting view becomes available. This view allows you to backtest strategies and visualize the results.</p> <p>You can also load and visualize previous backtest results, as well as compare the results with each other.</p> <p> </p>"},{"location":"freq-ui/#cors","title":"CORS","text":"<p>This whole section is only necessary in cross-origin cases (where you multiple bot API's running on <code>localhost:8081</code>, <code>localhost:8082</code>, ...), and want to combine them into one FreqUI instance.</p> Technical explanation <p>All web-based front-ends are subject to CORS - Cross-Origin Resource Sharing. Since most of the requests to the Freqtrade API must be authenticated, a proper CORS policy is key to avoid security problems. Also, the standard disallows <code>*</code> CORS policies for requests with credentials, so this setting must be set appropriately.</p> <p>Users can allow access from different origin URL's to the bot API via the <code>CORS_origins</code> configuration setting. It consists of a list of allowed URL's that are allowed to consume resources from the bot's API.</p> <p>Assuming your application is deployed as <code>https://frequi.freqtrade.io/home/</code> - this would mean that the following configuration becomes necessary:</p> <pre><code>{\n    //...\n    \"jwt_secret_key\": \"somethingrandom\",\n    \"CORS_origins\": [\"https://frequi.freqtrade.io\"],\n    //...\n}\n</code></pre> <p>In the following (pretty common) case, FreqUI is accessible on <code>http://localhost:8080/trade</code> (this is what you see in your navbar when navigating to freqUI). </p> <p>The correct configuration for this case is <code>http://localhost:8080</code> - the main part of the URL including the port.</p> <pre><code>{\n    //...\n    \"jwt_secret_key\": \"somethingrandom\",\n    \"CORS_origins\": [\"http://localhost:8080\"],\n    //...\n}\n</code></pre> <p>trailing Slash</p> <p>The trailing slash is not allowed in the <code>CORS_origins</code> configuration (e.g. <code>\"http://localhots:8080/\"</code>). Such a configuration will not take effect, and the cors errors will remain.</p> <p>Note</p> <p>We strongly recommend to also set <code>jwt_secret_key</code> to something random and known only to yourself to avoid unauthorized access to your bot.</p>"},{"location":"freqai-configuration/","title":"Configuration","text":"<p>FreqAI is configured through the typical Freqtrade config file and the standard Freqtrade strategy. Examples of FreqAI config and strategy files can be found in <code>config_examples/config_freqai.example.json</code> and <code>freqtrade/templates/FreqaiExampleStrategy.py</code>, respectively.</p>"},{"location":"freqai-configuration/#setting-up-the-configuration-file","title":"Setting up the configuration file","text":"<p>Although there are plenty of additional parameters to choose from, as highlighted in the parameter table, a FreqAI config must at minimum include the following parameters (the parameter values are only examples):</p> <pre><code>    \"freqai\": {\n        \"enabled\": true,\n        \"purge_old_models\": 2,\n        \"train_period_days\": 30,\n        \"backtest_period_days\": 7,\n        \"identifier\" : \"unique-id\",\n        \"feature_parameters\" : {\n            \"include_timeframes\": [\"5m\",\"15m\",\"4h\"],\n            \"include_corr_pairlist\": [\n                \"ETH/USD\",\n                \"LINK/USD\",\n                \"BNB/USD\"\n            ],\n            \"label_period_candles\": 24,\n            \"include_shifted_candles\": 2,\n            \"indicator_periods_candles\": [10, 20]\n        },\n        \"data_split_parameters\" : {\n            \"test_size\": 0.25\n        }\n    }\n</code></pre> <p>A full example config is available in <code>config_examples/config_freqai.example.json</code>.</p> <p>Note</p> <p>The <code>identifier</code> is commonly overlooked by newcomers, however, this value plays an important role in your configuration. This value is a unique ID that you choose to describe one of your runs. Keeping it the same allows you to maintain crash resilience as well as faster backtesting. As soon as you want to try a new run (new features, new model, etc.), you should change this value (or delete the <code>user_data/models/unique-id</code> folder. More details available in the parameter table.</p>"},{"location":"freqai-configuration/#building-a-freqai-strategy","title":"Building a FreqAI strategy","text":"<p>The FreqAI strategy requires including the following lines of code in the standard Freqtrade strategy:</p> <pre><code>    # user should define the maximum startup candle count (the largest number of candles\n    # passed to any single indicator)\n    startup_candle_count: int = 20\n\n    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n\n        # the model will return all labels created by user in `set_freqai_targets()`\n        # (&amp; appended targets), an indication of whether or not the prediction should be accepted,\n        # the target mean/std values for each of the labels created by user in\n        # `set_freqai_targets()` for each training period.\n\n        dataframe = self.freqai.start(dataframe, metadata, self)\n\n        return dataframe\n\n    def feature_engineering_expand_all(self, dataframe: DataFrame, period, **kwargs) -&gt; DataFrame:\n        \"\"\"\n        *Only functional with FreqAI enabled strategies*\n        This function will automatically expand the defined features on the config defined\n        `indicator_periods_candles`, `include_timeframes`, `include_shifted_candles`, and\n        `include_corr_pairs`. In other words, a single feature defined in this function\n        will automatically expand to a total of\n        `indicator_periods_candles` * `include_timeframes` * `include_shifted_candles` *\n        `include_corr_pairs` numbers of features added to the model.\n\n        All features must be prepended with `%` to be recognized by FreqAI internals.\n\n        :param df: strategy dataframe which will receive the features\n        :param period: period of the indicator - usage example:\n        dataframe[\"%-ema-period\"] = ta.EMA(dataframe, timeperiod=period)\n        \"\"\"\n\n        dataframe[\"%-rsi-period\"] = ta.RSI(dataframe, timeperiod=period)\n        dataframe[\"%-mfi-period\"] = ta.MFI(dataframe, timeperiod=period)\n        dataframe[\"%-adx-period\"] = ta.ADX(dataframe, timeperiod=period)\n        dataframe[\"%-sma-period\"] = ta.SMA(dataframe, timeperiod=period)\n        dataframe[\"%-ema-period\"] = ta.EMA(dataframe, timeperiod=period)\n\n        return dataframe\n\n    def feature_engineering_expand_basic(self, dataframe: DataFrame, **kwargs) -&gt; DataFrame:\n        \"\"\"\n        *Only functional with FreqAI enabled strategies*\n        This function will automatically expand the defined features on the config defined\n        `include_timeframes`, `include_shifted_candles`, and `include_corr_pairs`.\n        In other words, a single feature defined in this function\n        will automatically expand to a total of\n        `include_timeframes` * `include_shifted_candles` * `include_corr_pairs`\n        numbers of features added to the model.\n\n        Features defined here will *not* be automatically duplicated on user defined\n        `indicator_periods_candles`\n\n        All features must be prepended with `%` to be recognized by FreqAI internals.\n\n        :param df: strategy dataframe which will receive the features\n        dataframe[\"%-pct-change\"] = dataframe[\"close\"].pct_change()\n        dataframe[\"%-ema-200\"] = ta.EMA(dataframe, timeperiod=200)\n        \"\"\"\n        dataframe[\"%-pct-change\"] = dataframe[\"close\"].pct_change()\n        dataframe[\"%-raw_volume\"] = dataframe[\"volume\"]\n        dataframe[\"%-raw_price\"] = dataframe[\"close\"]\n        return dataframe\n\n    def feature_engineering_standard(self, dataframe: DataFrame, **kwargs) -&gt; DataFrame:\n        \"\"\"\n        *Only functional with FreqAI enabled strategies*\n        This optional function will be called once with the dataframe of the base timeframe.\n        This is the final function to be called, which means that the dataframe entering this\n        function will contain all the features and columns created by all other\n        freqai_feature_engineering_* functions.\n\n        This function is a good place to do custom exotic feature extractions (e.g. tsfresh).\n        This function is a good place for any feature that should not be auto-expanded upon\n        (e.g. day of the week).\n\n        All features must be prepended with `%` to be recognized by FreqAI internals.\n\n        :param df: strategy dataframe which will receive the features\n        usage example: dataframe[\"%-day_of_week\"] = (dataframe[\"date\"].dt.dayofweek + 1) / 7\n        \"\"\"\n        dataframe[\"%-day_of_week\"] = (dataframe[\"date\"].dt.dayofweek + 1) / 7\n        dataframe[\"%-hour_of_day\"] = (dataframe[\"date\"].dt.hour + 1) / 25\n        return dataframe\n\n    def set_freqai_targets(self, dataframe: DataFrame, **kwargs) -&gt; DataFrame:\n        \"\"\"\n        *Only functional with FreqAI enabled strategies*\n        Required function to set the targets for the model.\n        All targets must be prepended with `&amp;` to be recognized by the FreqAI internals.\n\n        :param df: strategy dataframe which will receive the targets\n        usage example: dataframe[\"&amp;-target\"] = dataframe[\"close\"].shift(-1) / dataframe[\"close\"]\n        \"\"\"\n        dataframe[\"&amp;-s_close\"] = (\n            dataframe[\"close\"]\n            .shift(-self.freqai_info[\"feature_parameters\"][\"label_period_candles\"])\n            .rolling(self.freqai_info[\"feature_parameters\"][\"label_period_candles\"])\n            .mean()\n            / dataframe[\"close\"]\n            - 1\n            )\n        return dataframe\n</code></pre> <p>Notice how the <code>feature_engineering_*()</code> is where features are added. Meanwhile <code>set_freqai_targets()</code> adds the labels/targets. A full example strategy is available in <code>templates/FreqaiExampleStrategy.py</code>.</p> <p>Note</p> <p>The <code>self.freqai.start()</code> function cannot be called outside the <code>populate_indicators()</code>.</p> <p>Note</p> <p>Features must be defined in <code>feature_engineering_*()</code>. Defining FreqAI features in <code>populate_indicators()</code> will cause the algorithm to fail in live/dry mode. In order to add generalized features that are not associated with a specific pair or timeframe, you should use <code>feature_engineering_standard()</code> (as exemplified in <code>freqtrade/templates/FreqaiExampleStrategy.py</code>).</p>"},{"location":"freqai-configuration/#important-dataframe-key-patterns","title":"Important dataframe key patterns","text":"<p>Below are the values you can expect to include/use inside a typical strategy dataframe (<code>df[]</code>):</p> DataFrame Key Description <code>df['&amp;*']</code> Any dataframe column prepended with <code>&amp;</code> in <code>set_freqai_targets()</code> is treated as a training target (label) inside FreqAI (typically following the naming convention <code>&amp;-s*</code>). For example, to predict the close price 40 candles into the future, you would set <code>df['&amp;-s_close'] = df['close'].shift(-self.freqai_info[\"feature_parameters\"][\"label_period_candles\"])</code> with <code>\"label_period_candles\": 40</code> in the config. FreqAI makes the predictions and gives them back under the same key (<code>df['&amp;-s_close']</code>) to be used in <code>populate_entry/exit_trend()</code>.  Datatype: Depends on the output of the model. <code>df['&amp;*_std/mean']</code> Standard deviation and mean values of the defined labels during training (or live tracking with <code>fit_live_predictions_candles</code>). Commonly used to understand the rarity of a prediction (use the z-score as shown in <code>templates/FreqaiExampleStrategy.py</code> and explained here to evaluate how often a particular prediction was observed during training or historically with <code>fit_live_predictions_candles</code>).  Datatype: Float. <code>df['do_predict']</code> Indication of an outlier data point. The return value is integer between -2 and 2, which lets you know if the prediction is trustworthy or not. <code>do_predict==1</code> means that the prediction is trustworthy. If the Dissimilarity Index (DI, see details here) of the input data point is above the threshold defined in the config, FreqAI will subtract 1 from <code>do_predict</code>, resulting in <code>do_predict==0</code>. If <code>use_SVM_to_remove_outliers</code> is active, the Support Vector Machine (SVM, see details here) may also detect outliers in training and prediction data. In this case, the SVM will also subtract 1 from <code>do_predict</code>. If the input data point was considered an outlier by the SVM but not by the DI, or vice versa, the result will be <code>do_predict==0</code>. If both the DI and the SVM considers the input data point to be an outlier, the result will be <code>do_predict==-1</code>. As with the SVM, if <code>use_DBSCAN_to_remove_outliers</code> is active, DBSCAN (see details here) may also detect outliers and subtract 1 from <code>do_predict</code>. Hence, if both the SVM and DBSCAN are active and identify a datapoint that was above the DI threshold as an outlier, the result will be <code>do_predict==-2</code>. A particular case is when <code>do_predict == 2</code>, which means that the model has expired due to exceeding <code>expired_hours</code>.  Datatype: Integer between -2 and 2. <code>df['DI_values']</code> Dissimilarity Index (DI) values are proxies for the level of confidence FreqAI has in the prediction. A lower DI means the prediction is close to the training data, i.e., higher prediction confidence. See details about the DI here.  Datatype: Float. <code>df['%*']</code> Any dataframe column prepended with <code>%</code> in <code>feature_engineering_*()</code> is treated as a training feature. For example, you can include the RSI in the training feature set (similar to in <code>templates/FreqaiExampleStrategy.py</code>) by setting <code>df['%-rsi']</code>. See more details on how this is done here.  Note: Since the number of features prepended with <code>%</code> can multiply very quickly (10s of thousands of features are easily engineered using the multiplictative functionality of, e.g., <code>include_shifted_candles</code> and <code>include_timeframes</code> as described in the parameter table), these features are removed from the dataframe that is returned from FreqAI to the strategy. To keep a particular type of feature for plotting purposes, you would prepend it with <code>%%</code> (see details below).  Datatype: Depends on the feature created by the user. <code>df['%%*']</code> Any dataframe column prepended with <code>%%</code> in <code>feature_engineering_*()</code> is treated as a training feature, just the same as the above <code>%</code> prepend. However, in this case, the features are returned back to the strategy for FreqUI/plot-dataframe plotting and monitoring in Dry/Live/Backtesting  Datatype: Depends on the feature created by the user. Please note that features created in <code>feature_engineering_expand()</code> will have automatic FreqAI naming schemas depending on the expansions that you configured (i.e. <code>include_timeframes</code>, <code>include_corr_pairlist</code>, <code>indicators_periods_candles</code>, <code>include_shifted_candles</code>). So if you want to plot <code>%%-rsi</code> from <code>feature_engineering_expand_all()</code>, the final naming scheme for your plotting config would be: <code>%%-rsi-period_10_ETH/USDT:USDT_1h</code> for the <code>rsi</code> feature with <code>period=10</code>, <code>timeframe=1h</code>, and <code>pair=ETH/USDT:USDT</code> (the <code>:USDT</code> is added if you are using futures pairs). It is useful to simply add <code>print(dataframe.columns)</code> in your <code>populate_indicators()</code> after <code>self.freqai.start()</code> to see the full list of available features that are returned to the strategy for plotting purposes."},{"location":"freqai-configuration/#setting-the-startup_candle_count","title":"Setting the <code>startup_candle_count</code>","text":"<p>The <code>startup_candle_count</code> in the FreqAI strategy needs to be set up in the same way as in the standard Freqtrade strategy (see details here). This value is used by Freqtrade to ensure that a sufficient amount of data is provided when calling the <code>dataprovider</code>, to avoid any NaNs at the beginning of the first training. You can easily set this value by identifying the longest period (in candle units) which is passed to the indicator creation functions (e.g., TA-Lib functions). In the presented example, <code>startup_candle_count</code> is 20 since this is the maximum value in <code>indicators_periods_candles</code>.</p> <p>Note</p> <p>There are instances where the TA-Lib functions actually require more data than just the passed <code>period</code> or else the feature dataset gets populated with NaNs. Anecdotally, multiplying the <code>startup_candle_count</code> by 2 always leads to a fully NaN free training dataset. Hence, it is typically safest to multiply the expected <code>startup_candle_count</code> by 2. Look out for this log message to confirm that the data is clean:</p> <pre><code>2022-08-31 15:14:04 - freqtrade.freqai.data_kitchen - INFO - dropped 0 training points due to NaNs in populated dataset 4319.\n</code></pre>"},{"location":"freqai-configuration/#creating-a-dynamic-target-threshold","title":"Creating a dynamic target threshold","text":"<p>Deciding when to enter or exit a trade can be done in a dynamic way to reflect current market conditions. FreqAI allows you to return additional information from the training of a model (more info here). For example, the <code>&amp;*_std/mean</code> return values describe the statistical distribution of the target/label during the most recent training. Comparing a given prediction to these values allows you to know the rarity of the prediction. In <code>templates/FreqaiExampleStrategy.py</code>, the <code>target_roi</code> and  <code>sell_roi</code> are defined to be 1.25 z-scores away from the mean which causes predictions that are closer to the mean to be filtered out.</p> <pre><code>dataframe[\"target_roi\"] = dataframe[\"&amp;-s_close_mean\"] + dataframe[\"&amp;-s_close_std\"] * 1.25\ndataframe[\"sell_roi\"] = dataframe[\"&amp;-s_close_mean\"] - dataframe[\"&amp;-s_close_std\"] * 1.25\n</code></pre> <p>To consider the population of historical predictions for creating the dynamic target instead of information from the training as discussed above, you would set <code>fit_live_predictions_candles</code> in the config to the number of historical prediction candles you wish to use to generate target statistics.</p> <pre><code>    \"freqai\": {\n        \"fit_live_predictions_candles\": 300,\n    }\n</code></pre> <p>If this value is set, FreqAI will initially use the predictions from the training data and subsequently begin introducing real prediction data as it is generated. FreqAI will save this historical data to be reloaded if you stop and restart a model with the same <code>identifier</code>.</p>"},{"location":"freqai-configuration/#using-different-prediction-models","title":"Using different prediction models","text":"<p>FreqAI has multiple example prediction model libraries that are ready to be used as is via the flag <code>--freqaimodel</code>. These libraries include <code>CatBoost</code>, <code>LightGBM</code>, and <code>XGBoost</code> regression, classification, and multi-target models, and can be found in <code>freqai/prediction_models/</code>.</p> <p>Regression and classification models differ in what targets they predict - a regression model will predict a target of continuous values, for example what price BTC will be at tomorrow, whilst a classifier will predict a target of discrete values, for example if the price of BTC will go up tomorrow or not. This means that you have to specify your targets differently depending on which model type you are using (see details below).</p> <p>All of the aforementioned model libraries implement gradient boosted decision tree algorithms. They all work on the principle of ensemble learning, where predictions from multiple simple learners are combined to get a final prediction that is more stable and generalized. The simple learners in this case are decision trees. Gradient boosting refers to the method of learning, where each simple learner is built in sequence - the subsequent learner is used to improve on the error from the previous learner. If you want to learn more about the different model libraries you can find the information in their respective docs:</p> <ul> <li>CatBoost: https://catboost.ai/en/docs/</li> <li>LightGBM: https://lightgbm.readthedocs.io/en/v3.3.2/#</li> <li>XGBoost: https://xgboost.readthedocs.io/en/stable/#</li> </ul> <p>There are also numerous online articles describing and comparing the algorithms. Some relatively lightweight examples would be CatBoost vs. LightGBM vs. XGBoost \u2014 Which is the best algorithm? and XGBoost, LightGBM or CatBoost \u2014 which boosting algorithm should I use?. Keep in mind that the performance of each model is highly dependent on the application and so any reported metrics might not be true for your particular use of the model.</p> <p>Apart from the models already available in FreqAI, it is also possible to customize and create your own prediction models using the <code>IFreqaiModel</code> class. You are encouraged to inherit <code>fit()</code>, <code>train()</code>, and <code>predict()</code> to customize various aspects of the training procedures. You can place custom FreqAI models in <code>user_data/freqaimodels</code> - and freqtrade will pick them up from there based on the provided <code>--freqaimodel</code> name - which has to correspond to the class name of your custom model. Make sure to use unique names to avoid overriding built-in models.</p>"},{"location":"freqai-configuration/#setting-model-targets","title":"Setting model targets","text":""},{"location":"freqai-configuration/#regressors","title":"Regressors","text":"<p>If you are using a regressor, you need to specify a target that has continuous values. FreqAI includes a variety of regressors, such as the <code>CatboostRegressor</code>via the flag <code>--freqaimodel CatboostRegressor</code>. An example of how you could set a regression target for predicting the price 100 candles into the future would be</p> <pre><code>df['&amp;s-close_price'] = df['close'].shift(-100)\n</code></pre> <p>If you want to predict multiple targets, you need to define multiple labels using the same syntax as shown above.</p>"},{"location":"freqai-configuration/#classifiers","title":"Classifiers","text":"<p>If you are using a classifier, you need to specify a target that has discrete values. FreqAI includes a variety of classifiers, such as the <code>CatboostClassifier</code> via the flag <code>--freqaimodel CatboostClassifier</code>. If you elects to use a classifier, the classes need to be set using strings. For example, if you want to predict if the price 100 candles into the future goes up or down you would set</p> <pre><code>df['&amp;s-up_or_down'] = np.where( df[\"close\"].shift(-100) &gt; df[\"close\"], 'up', 'down')\n</code></pre> <p>If you want to predict multiple targets you must specify all labels in the same label column. You could, for example, add the label <code>same</code> to define where the price was unchanged by setting</p> <pre><code>df['&amp;s-up_or_down'] = np.where( df[\"close\"].shift(-100) &gt; df[\"close\"], 'up', 'down')\ndf['&amp;s-up_or_down'] = np.where( df[\"close\"].shift(-100) == df[\"close\"], 'same', df['&amp;s-up_or_down'])\n</code></pre>"},{"location":"freqai-configuration/#pytorch-module","title":"PyTorch Module","text":""},{"location":"freqai-configuration/#quick-start","title":"Quick start","text":"<p>The easiest way to quickly run a pytorch model is with the following command (for regression task):</p> <pre><code>freqtrade trade --config config_examples/config_freqai.example.json --strategy FreqaiExampleStrategy --freqaimodel PyTorchMLPRegressor --strategy-path freqtrade/templates \n</code></pre> <p>Installation/docker</p> <p>The PyTorch module requires large packages such as <code>torch</code>, which should be explicitly requested during <code>./setup.sh -i</code> by answering \"y\" to the question \"Do you also want dependencies for freqai-rl or PyTorch (~700mb additional space required) [y/N]?\". Users who prefer docker should ensure they use the docker image appended with <code>_freqaitorch</code>. We do provide an explicit docker-compose file for this in <code>docker/docker-compose-freqai.yml</code> - which can be used via <code>docker compose -f docker/docker-compose-freqai.yml run ...</code> - or can be copied to replace the original docker file. This docker-compose file also contains a (disabled) section to enable GPU resources within docker containers. This obviously assumes the system has GPU resources available.</p>"},{"location":"freqai-configuration/#structure","title":"Structure","text":""},{"location":"freqai-configuration/#model","title":"Model","text":"<p>You can construct your own Neural Network architecture in PyTorch by simply defining your <code>nn.Module</code> class inside your custom <code>IFreqaiModel</code> file and then using that class in your <code>def train()</code> function. Here is an example of logistic regression model implementation using PyTorch (should be used with nn.BCELoss criterion) for classification tasks.</p> <pre><code>class LogisticRegression(nn.Module):\n    def __init__(self, input_size: int):\n        super().__init__()\n        # Define your layers\n        self.linear = nn.Linear(input_size, 1)\n        self.activation = nn.Sigmoid()\n\n    def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n        # Define the forward pass\n        out = self.linear(x)\n        out = self.activation(out)\n        return out\n\nclass MyCoolPyTorchClassifier(BasePyTorchClassifier):\n    \"\"\"\n    This is a custom IFreqaiModel showing how a user might setup their own \n    custom Neural Network architecture for their training.\n    \"\"\"\n\n    @property\n    def data_convertor(self) -&gt; PyTorchDataConvertor:\n        return DefaultPyTorchDataConvertor(target_tensor_type=torch.float)\n\n    def __init__(self, **kwargs) -&gt; None:\n        super().__init__(**kwargs)\n        config = self.freqai_info.get(\"model_training_parameters\", {})\n        self.learning_rate: float = config.get(\"learning_rate\",  3e-4)\n        self.model_kwargs: Dict[str, Any] = config.get(\"model_kwargs\",  {})\n        self.trainer_kwargs: Dict[str, Any] = config.get(\"trainer_kwargs\",  {})\n\n    def fit(self, data_dictionary: Dict, dk: FreqaiDataKitchen, **kwargs) -&gt; Any:\n        \"\"\"\n        User sets up the training and test data to fit their desired model here\n        :param data_dictionary: the dictionary holding all data for train, test,\n            labels, weights\n        :param dk: The datakitchen object for the current coin/model\n        \"\"\"\n\n        class_names = self.get_class_names()\n        self.convert_label_column_to_int(data_dictionary, dk, class_names)\n        n_features = data_dictionary[\"train_features\"].shape[-1]\n        model = LogisticRegression(\n            input_dim=n_features\n        )\n        model.to(self.device)\n        optimizer = torch.optim.AdamW(model.parameters(), lr=self.learning_rate)\n        criterion = torch.nn.CrossEntropyLoss()\n        init_model = self.get_init_model(dk.pair)\n        trainer = PyTorchModelTrainer(\n            model=model,\n            optimizer=optimizer,\n            criterion=criterion,\n            model_meta_data={\"class_names\": class_names},\n            device=self.device,\n            init_model=init_model,\n            data_convertor=self.data_convertor,\n            **self.trainer_kwargs,\n        )\n        trainer.fit(data_dictionary, self.splits)\n        return trainer\n</code></pre>"},{"location":"freqai-configuration/#trainer","title":"Trainer","text":"<p>The <code>PyTorchModelTrainer</code> performs the idiomatic PyTorch train loop: Define our model, loss function, and optimizer, and then move them to the appropriate device (GPU or CPU). Inside the loop, we iterate through the batches in the dataloader, move the data to the device, compute the prediction and loss, backpropagate, and update the model parameters using the optimizer. </p> <p>In addition, the trainer is responsible for the following:  - saving and loading the model  - converting the data from <code>pandas.DataFrame</code> to <code>torch.Tensor</code>. </p>"},{"location":"freqai-configuration/#integration-with-freqai-module","title":"Integration with Freqai module","text":"<p>Like all freqai models, PyTorch models inherit <code>IFreqaiModel</code>. <code>IFreqaiModel</code> declares three abstract methods: <code>train</code>, <code>fit</code>, and <code>predict</code>. we implement these methods in three levels of hierarchy. From top to bottom:</p> <ol> <li><code>BasePyTorchModel</code> - Implements the <code>train</code> method. all <code>BasePyTorch*</code> inherit it. responsible for general data preparation (e.g., data normalization) and calling the <code>fit</code> method. Sets <code>device</code> attribute used by children classes. Sets <code>model_type</code> attribute used by the parent class.</li> <li><code>BasePyTorch*</code> -  Implements the <code>predict</code> method. Here, the <code>*</code> represents a group of algorithms, such as classifiers or regressors. responsible for data preprocessing, predicting, and postprocessing if needed.</li> <li><code>PyTorch*Classifier</code> / <code>PyTorch*Regressor</code> - implements the <code>fit</code> method. responsible for the main train flaw, where we initialize the trainer and model objects.</li> </ol> <p></p>"},{"location":"freqai-configuration/#full-example","title":"Full example","text":"<p>Building a PyTorch regressor using MLP (multilayer perceptron) model, MSELoss criterion, and AdamW optimizer.</p> <pre><code>class PyTorchMLPRegressor(BasePyTorchRegressor):\n    def __init__(self, **kwargs) -&gt; None:\n        super().__init__(**kwargs)\n        config = self.freqai_info.get(\"model_training_parameters\", {})\n        self.learning_rate: float = config.get(\"learning_rate\",  3e-4)\n        self.model_kwargs: Dict[str, Any] = config.get(\"model_kwargs\",  {})\n        self.trainer_kwargs: Dict[str, Any] = config.get(\"trainer_kwargs\",  {})\n\n    def fit(self, data_dictionary: Dict, dk: FreqaiDataKitchen, **kwargs) -&gt; Any:\n        n_features = data_dictionary[\"train_features\"].shape[-1]\n        model = PyTorchMLPModel(\n            input_dim=n_features,\n            output_dim=1,\n            **self.model_kwargs\n        )\n        model.to(self.device)\n        optimizer = torch.optim.AdamW(model.parameters(), lr=self.learning_rate)\n        criterion = torch.nn.MSELoss()\n        init_model = self.get_init_model(dk.pair)\n        trainer = PyTorchModelTrainer(\n            model=model,\n            optimizer=optimizer,\n            criterion=criterion,\n            device=self.device,\n            init_model=init_model,\n            target_tensor_type=torch.float,\n            **self.trainer_kwargs,\n        )\n        trainer.fit(data_dictionary)\n        return trainer\n</code></pre> <p>Here we create a <code>PyTorchMLPRegressor</code> class that implements the <code>fit</code> method. The <code>fit</code> method specifies the training building blocks: model, optimizer, criterion, and trainer. We inherit both <code>BasePyTorchRegressor</code> and <code>BasePyTorchModel</code>, where the former implements the <code>predict</code> method that is suitable for our regression task, and the latter implements the train method.</p> Setting Class Names for Classifiers <p>When using classifiers, the user must declare the class names (or targets) by overriding the <code>IFreqaiModel.class_names</code> attribute. This is achieved by setting <code>self.freqai.class_names</code> in the FreqAI strategy inside the <code>set_freqai_targets</code> method.</p> <p>For example, if you are using a binary classifier to predict price movements as up or down, you can set the class names as follows: <pre><code>def set_freqai_targets(self, dataframe: DataFrame, metadata: Dict, **kwargs) -&gt; DataFrame:\n    self.freqai.class_names = [\"down\", \"up\"]\n    dataframe['&amp;s-up_or_down'] = np.where(dataframe[\"close\"].shift(-100) &gt;\n                                              dataframe[\"close\"], 'up', 'down')\n\n    return dataframe\n</code></pre> To see a full example, you can refer to the classifier test strategy class.</p>"},{"location":"freqai-configuration/#improving-performance-with-torchcompile","title":"Improving performance with <code>torch.compile()</code>","text":"<p>Torch provides a <code>torch.compile()</code> method that can be used to improve performance for specific GPU hardware. More details can be found here. In brief, you simply wrap your <code>model</code> in <code>torch.compile()</code>:</p> <pre><code>        model = PyTorchMLPModel(\n            input_dim=n_features,\n            output_dim=1,\n            **self.model_kwargs\n        )\n        model.to(self.device)\n        model = torch.compile(model)\n</code></pre> <p>Then proceed to use the model as normal. Keep in mind that doing this will remove eager execution, which means errors and tracebacks will not be informative.</p>"},{"location":"freqai-developers/","title":"Development","text":""},{"location":"freqai-developers/#project-architecture","title":"Project architecture","text":"<p>The architecture and functions of FreqAI are generalized to encourages development of unique features, functions, models, etc.</p> <p>The class structure and a detailed algorithmic overview is depicted in the following diagram:</p> <p></p> <p>As shown, there are three distinct objects comprising FreqAI:</p> <ul> <li>IFreqaiModel - A singular persistent object containing all the necessary logic to collect, store, and process data, engineer features, run training, and inference models.</li> <li>FreqaiDataKitchen - A non-persistent object which is created uniquely for each unique asset/model. Beyond metadata, it also contains a variety of data processing tools.</li> <li>FreqaiDataDrawer - A singular persistent object containing all the historical predictions, models, and save/load methods.</li> </ul> <p>There are a variety of built-in prediction models which inherit directly from <code>IFreqaiModel</code>. Each of these models have full access to all methods in <code>IFreqaiModel</code> and can therefore override any of those functions at will. However, advanced users will likely stick to overriding <code>fit()</code>, <code>train()</code>, <code>predict()</code>, and <code>data_cleaning_train/predict()</code>.</p>"},{"location":"freqai-developers/#data-handling","title":"Data handling","text":"<p>FreqAI aims to organize model files, prediction data, and meta data in a way that simplifies post-processing and enhances crash resilience by automatic data reloading. The data is saved in a file structure,<code>user_data_dir/models/</code>, which contains all the data associated with the trainings and backtests. The <code>FreqaiDataKitchen()</code> relies heavily on the file structure for proper training and inferencing and should therefore not be manually modified.</p>"},{"location":"freqai-developers/#file-structure","title":"File structure","text":"<p>The file structure is automatically generated based on the model <code>identifier</code> set in the config. The following structure shows where the data is stored for post processing:</p> Structure Description <code>config_*.json</code> A copy of the model specific configuration file. <code>historic_predictions.pkl</code> A file containing all historic predictions generated during the lifetime of the <code>identifier</code> model during live deployment. <code>historic_predictions.pkl</code> is used to reload the model after a crash or a config change. A backup file is always held in case of corruption on the main file. FreqAI automatically detects corruption and replaces the corrupted file with the backup. <code>pair_dictionary.json</code> A file containing the training queue as well as the on disk location of the most recently trained model. <code>sub-train-*_TIMESTAMP</code> A folder containing all the files associated with a single model, such as:  <code>*_metadata.json</code> - Metadata for the model, such as normalization max/min, expected training feature list, etc.  <code>*_model.*</code> - The model file saved to disk for reloading from a crash. Can be <code>joblib</code> (typical boosting libs), <code>zip</code> (stable_baselines), <code>hd5</code> (keras type), etc.  <code>*_pca_object.pkl</code> - The Principal component analysis (PCA) transform (if <code>principal_component_analysis: True</code> is set in the config) which will be used to transform unseen prediction features.  <code>*_svm_model.pkl</code> - The Support Vector Machine (SVM) model (if <code>use_SVM_to_remove_outliers: True</code> is set in the config) which is used to detect outliers in unseen prediction features.  <code>*_trained_df.pkl</code> - The dataframe containing all the training features used to train the <code>identifier</code> model. This is used for computing the Dissimilarity Index (DI) and can also be used for post-processing.  <code>*_trained_dates.df.pkl</code> - The dates associated with the <code>trained_df.pkl</code>, which is useful for post-processing. <p>The example file structure would look like this:</p> <pre><code>\u251c\u2500\u2500 models\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 unique-id\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 config_freqai.example.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 historic_predictions.backup.pkl\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 historic_predictions.pkl\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 pair_dictionary.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 sub-train-1INCH_1662821319\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 cb_1inch_1662821319_metadata.json\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 cb_1inch_1662821319_model.joblib\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 cb_1inch_1662821319_pca_object.pkl\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 cb_1inch_1662821319_svm_model.joblib\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 cb_1inch_1662821319_trained_dates_df.pkl\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 cb_1inch_1662821319_trained_df.pkl\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 sub-train-1INCH_1662821371\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 cb_1inch_1662821371_metadata.json\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 cb_1inch_1662821371_model.joblib\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 cb_1inch_1662821371_pca_object.pkl\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 cb_1inch_1662821371_svm_model.joblib\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 cb_1inch_1662821371_trained_dates_df.pkl\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 cb_1inch_1662821371_trained_df.pkl\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 sub-train-ADA_1662821344\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 cb_ada_1662821344_metadata.json\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 cb_ada_1662821344_model.joblib\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 cb_ada_1662821344_pca_object.pkl\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 cb_ada_1662821344_svm_model.joblib\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 cb_ada_1662821344_trained_dates_df.pkl\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 cb_ada_1662821344_trained_df.pkl\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 sub-train-ADA_1662821399\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 cb_ada_1662821399_metadata.json\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 cb_ada_1662821399_model.joblib\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 cb_ada_1662821399_pca_object.pkl\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 cb_ada_1662821399_svm_model.joblib\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 cb_ada_1662821399_trained_dates_df.pkl\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 cb_ada_1662821399_trained_df.pkl\n</code></pre>"},{"location":"freqai-feature-engineering/","title":"Feature engineering","text":""},{"location":"freqai-feature-engineering/#defining-the-features","title":"Defining the features","text":"<p>Low level feature engineering is performed in the user strategy within a set of functions called <code>feature_engineering_*</code>. These function set the <code>base features</code> such as, <code>RSI</code>, <code>MFI</code>, <code>EMA</code>, <code>SMA</code>, time of day, volume, etc. The <code>base features</code> can be custom indicators or they can be imported from any technical-analysis library that you can find. FreqAI is equipped with a set of functions to simplify rapid large-scale feature engineering:</p> Function Description <code>feature_engineering_expand_all()</code> This optional function will automatically expand the defined features on the config defined <code>indicator_periods_candles</code>, <code>include_timeframes</code>, <code>include_shifted_candles</code>, and <code>include_corr_pairs</code>. <code>feature_engineering_expand_basic()</code> This optional function will automatically expand the defined features on the config defined <code>include_timeframes</code>, <code>include_shifted_candles</code>, and <code>include_corr_pairs</code>. Note: this function does not expand across <code>indicator_periods_candles</code>. <code>feature_engineering_standard()</code> This optional function will be called once with the dataframe of the base timeframe. This is the final function to be called, which means that the dataframe entering this function will contain all the features and columns from the base asset created by the other <code>feature_engineering_expand</code> functions. This function is a good place to do custom exotic feature extractions (e.g. tsfresh). This function is also a good place for any feature that should not be auto-expanded upon (e.g., day of the week). <code>set_freqai_targets()</code> Required function to set the targets for the model. All targets must be prepended with <code>&amp;</code> to be recognized by the FreqAI internals. <p>Meanwhile, high level feature engineering is handled within <code>\"feature_parameters\":{}</code> in the FreqAI config. Within this file, it is possible to decide large scale feature expansions on top of the <code>base_features</code> such as \"including correlated pairs\" or \"including informative timeframes\" or even \"including recent candles.\"</p> <p>It is advisable to start from the template <code>feature_engineering_*</code> functions in the source provided example strategy (found in <code>templates/FreqaiExampleStrategy.py</code>) to ensure that the feature definitions are following the correct conventions. Here is an example of how to set the indicators and labels in the strategy:</p> <pre><code>    def feature_engineering_expand_all(self, dataframe: DataFrame, period, metadata, **kwargs) -&gt; DataFrame:\n        \"\"\"\n        *Only functional with FreqAI enabled strategies*\n        This function will automatically expand the defined features on the config defined\n        `indicator_periods_candles`, `include_timeframes`, `include_shifted_candles`, and\n        `include_corr_pairs`. In other words, a single feature defined in this function\n        will automatically expand to a total of\n        `indicator_periods_candles` * `include_timeframes` * `include_shifted_candles` *\n        `include_corr_pairs` numbers of features added to the model.\n\n        All features must be prepended with `%` to be recognized by FreqAI internals.\n\n        Access metadata such as the current pair/timeframe/period with:\n\n        `metadata[\"pair\"]` `metadata[\"tf\"]`  `metadata[\"period\"]`\n\n        :param df: strategy dataframe which will receive the features\n        :param period: period of the indicator - usage example:\n        :param metadata: metadata of current pair\n        dataframe[\"%-ema-period\"] = ta.EMA(dataframe, timeperiod=period)\n        \"\"\"\n\n        dataframe[\"%-rsi-period\"] = ta.RSI(dataframe, timeperiod=period)\n        dataframe[\"%-mfi-period\"] = ta.MFI(dataframe, timeperiod=period)\n        dataframe[\"%-adx-period\"] = ta.ADX(dataframe, timeperiod=period)\n        dataframe[\"%-sma-period\"] = ta.SMA(dataframe, timeperiod=period)\n        dataframe[\"%-ema-period\"] = ta.EMA(dataframe, timeperiod=period)\n\n        bollinger = qtpylib.bollinger_bands(\n            qtpylib.typical_price(dataframe), window=period, stds=2.2\n        )\n        dataframe[\"bb_lowerband-period\"] = bollinger[\"lower\"]\n        dataframe[\"bb_middleband-period\"] = bollinger[\"mid\"]\n        dataframe[\"bb_upperband-period\"] = bollinger[\"upper\"]\n\n        dataframe[\"%-bb_width-period\"] = (\n            dataframe[\"bb_upperband-period\"]\n            - dataframe[\"bb_lowerband-period\"]\n        ) / dataframe[\"bb_middleband-period\"]\n        dataframe[\"%-close-bb_lower-period\"] = (\n            dataframe[\"close\"] / dataframe[\"bb_lowerband-period\"]\n        )\n\n        dataframe[\"%-roc-period\"] = ta.ROC(dataframe, timeperiod=period)\n\n        dataframe[\"%-relative_volume-period\"] = (\n            dataframe[\"volume\"] / dataframe[\"volume\"].rolling(period).mean()\n        )\n\n        return dataframe\n\n    def feature_engineering_expand_basic(self, dataframe: DataFrame, metadata, **kwargs) -&gt; DataFrame:\n        \"\"\"\n        *Only functional with FreqAI enabled strategies*\n        This function will automatically expand the defined features on the config defined\n        `include_timeframes`, `include_shifted_candles`, and `include_corr_pairs`.\n        In other words, a single feature defined in this function\n        will automatically expand to a total of\n        `include_timeframes` * `include_shifted_candles` * `include_corr_pairs`\n        numbers of features added to the model.\n\n        Features defined here will *not* be automatically duplicated on user defined\n        `indicator_periods_candles`\n\n        Access metadata such as the current pair/timeframe with:\n\n        `metadata[\"pair\"]` `metadata[\"tf\"]`\n\n        All features must be prepended with `%` to be recognized by FreqAI internals.\n\n        :param df: strategy dataframe which will receive the features\n        :param metadata: metadata of current pair\n        dataframe[\"%-pct-change\"] = dataframe[\"close\"].pct_change()\n        dataframe[\"%-ema-200\"] = ta.EMA(dataframe, timeperiod=200)\n        \"\"\"\n        dataframe[\"%-pct-change\"] = dataframe[\"close\"].pct_change()\n        dataframe[\"%-raw_volume\"] = dataframe[\"volume\"]\n        dataframe[\"%-raw_price\"] = dataframe[\"close\"]\n        return dataframe\n\n    def feature_engineering_standard(self, dataframe: DataFrame, metadata, **kwargs) -&gt; DataFrame:\n        \"\"\"\n        *Only functional with FreqAI enabled strategies*\n        This optional function will be called once with the dataframe of the base timeframe.\n        This is the final function to be called, which means that the dataframe entering this\n        function will contain all the features and columns created by all other\n        freqai_feature_engineering_* functions.\n\n        This function is a good place to do custom exotic feature extractions (e.g. tsfresh).\n        This function is a good place for any feature that should not be auto-expanded upon\n        (e.g. day of the week).\n\n        Access metadata such as the current pair with:\n\n        `metadata[\"pair\"]`\n\n        All features must be prepended with `%` to be recognized by FreqAI internals.\n\n        :param df: strategy dataframe which will receive the features\n        :param metadata: metadata of current pair\n        usage example: dataframe[\"%-day_of_week\"] = (dataframe[\"date\"].dt.dayofweek + 1) / 7\n        \"\"\"\n        dataframe[\"%-day_of_week\"] = (dataframe[\"date\"].dt.dayofweek + 1) / 7\n        dataframe[\"%-hour_of_day\"] = (dataframe[\"date\"].dt.hour + 1) / 25\n        return dataframe\n\n    def set_freqai_targets(self, dataframe: DataFrame, metadata, **kwargs) -&gt; DataFrame:\n        \"\"\"\n        *Only functional with FreqAI enabled strategies*\n        Required function to set the targets for the model.\n        All targets must be prepended with `&amp;` to be recognized by the FreqAI internals.\n\n        Access metadata such as the current pair with:\n\n        `metadata[\"pair\"]`\n\n        :param df: strategy dataframe which will receive the targets\n        :param metadata: metadata of current pair\n        usage example: dataframe[\"&amp;-target\"] = dataframe[\"close\"].shift(-1) / dataframe[\"close\"]\n        \"\"\"\n        dataframe[\"&amp;-s_close\"] = (\n            dataframe[\"close\"]\n            .shift(-self.freqai_info[\"feature_parameters\"][\"label_period_candles\"])\n            .rolling(self.freqai_info[\"feature_parameters\"][\"label_period_candles\"])\n            .mean()\n            / dataframe[\"close\"]\n            - 1\n            )\n\n        return dataframe\n</code></pre> <p>In the presented example, the user does not wish to pass the <code>bb_lowerband</code> as a feature to the model, and has therefore not prepended it with <code>%</code>. The user does, however, wish to pass <code>bb_width</code> to the model for training/prediction and has therefore prepended it with <code>%</code>.</p> <p>After having defined the <code>base features</code>, the next step is to expand upon them using the powerful <code>feature_parameters</code> in the configuration file:</p> <pre><code>    \"freqai\": {\n        //...\n        \"feature_parameters\" : {\n            \"include_timeframes\": [\"5m\",\"15m\",\"4h\"],\n            \"include_corr_pairlist\": [\n                \"ETH/USD\",\n                \"LINK/USD\",\n                \"BNB/USD\"\n            ],\n            \"label_period_candles\": 24,\n            \"include_shifted_candles\": 2,\n            \"indicator_periods_candles\": [10, 20]\n        },\n        //...\n    }\n</code></pre> <p>The <code>include_timeframes</code> in the config above are the timeframes (<code>tf</code>) of each call to <code>feature_engineering_expand_*()</code> in the strategy. In the presented case, the user is asking for the <code>5m</code>, <code>15m</code>, and <code>4h</code> timeframes of the <code>rsi</code>, <code>mfi</code>, <code>roc</code>, and <code>bb_width</code> to be included in the feature set.</p> <p>You can ask for each of the defined features to be included also for informative pairs using the <code>include_corr_pairlist</code>. This means that the feature set will include all the features from <code>feature_engineering_expand_*()</code> on all the <code>include_timeframes</code> for each of the correlated pairs defined in the config (<code>ETH/USD</code>, <code>LINK/USD</code>, and <code>BNB/USD</code> in the presented example).</p> <p><code>include_shifted_candles</code> indicates the number of previous candles to include in the feature set. For example, <code>include_shifted_candles: 2</code> tells FreqAI to include the past 2 candles for each of the features in the feature set.</p> <p>In total, the number of features the user of the presented example strategy has created is: length of <code>include_timeframes</code> * no. features in <code>feature_engineering_expand_*()</code> * length of <code>include_corr_pairlist</code> * no. <code>include_shifted_candles</code> * length of <code>indicator_periods_candles</code> \\(= 3 * 3 * 3 * 2 * 2 = 108\\).</p> <p>!!! note \"Learn more about creative feature engineering\"     Check out our medium article geared toward helping users learn how to creatively engineer features.</p>"},{"location":"freqai-feature-engineering/#gain-finer-control-over-feature_engineering_-functions-with-metadata","title":"Gain finer control over <code>feature_engineering_*</code> functions with <code>metadata</code>","text":"<p>All <code>feature_engineering_*</code> and <code>set_freqai_targets()</code> functions are passed a <code>metadata</code> dictionary which contains information about the <code>pair</code>, <code>tf</code> (timeframe), and <code>period</code> that FreqAI is automating for feature building. As such, a user can use <code>metadata</code> inside <code>feature_engineering_*</code> functions as criteria for blocking/reserving features for certain timeframes, periods, pairs etc.</p> <pre><code>def feature_engineering_expand_all(self, dataframe: DataFrame, period, metadata, **kwargs) -&gt; DataFrame:\n    if metadata[\"tf\"] == \"1h\":\n        dataframe[\"%-roc-period\"] = ta.ROC(dataframe, timeperiod=period)\n</code></pre> <p>This will block <code>ta.ROC()</code> from being added to any timeframes other than <code>\"1h\"</code>.</p>"},{"location":"freqai-feature-engineering/#returning-additional-info-from-training","title":"Returning additional info from training","text":"<p>Important metrics can be returned to the strategy at the end of each model training by assigning them to <code>dk.data['extra_returns_per_train']['my_new_value'] = XYZ</code> inside the custom prediction model class. </p> <p>FreqAI takes the <code>my_new_value</code> assigned in this dictionary and expands it to fit the dataframe that is returned to the strategy. You can then use the returned metrics in your strategy through <code>dataframe['my_new_value']</code>. An example of how return values can be used in FreqAI are the <code>&amp;*_mean</code> and <code>&amp;*_std</code> values that are used to created a dynamic target threshold.</p> <p>Another example, where the user wants to use live metrics from the trade database, is shown below:</p> <pre><code>    \"freqai\": {\n        \"extra_returns_per_train\": {\"total_profit\": 4}\n    }\n</code></pre> <p>You need to set the standard dictionary in the config so that FreqAI can return proper dataframe shapes. These values will likely be overridden by the prediction model, but in the case where the model has yet to set them, or needs a default initial value, the pre-set values are what will be returned.</p>"},{"location":"freqai-feature-engineering/#weighting-features-for-temporal-importance","title":"Weighting features for temporal importance","text":"<p>FreqAI allows you to set a <code>weight_factor</code> to weight recent data more strongly than past data via an exponential function:</p> \\[ W_i = \\exp(\\frac{-i}{\\alpha*n}) \\] <p>where \\(W_i\\) is the weight of data point \\(i\\) in a total set of \\(n\\) data points. Below is a figure showing the effect of different weight factors on the data points in a feature set.</p> <p></p>"},{"location":"freqai-feature-engineering/#building-the-data-pipeline","title":"Building the data pipeline","text":"<p>By default, FreqAI builds a dynamic pipeline based on user configuration settings. The default settings are robust and designed to work with a variety of methods. These two steps are a <code>MinMaxScaler(-1,1)</code> and a <code>VarianceThreshold</code> which removes any column that has 0 variance. Users can activate other steps with more configuration parameters. For example if users add <code>use_SVM_to_remove_outliers: true</code> to the <code>freqai</code> config, then FreqAI will automatically add the <code>SVMOutlierExtractor</code> to the pipeline. Likewise, users can add <code>principal_component_analysis: true</code> to the <code>freqai</code> config to activate PCA. The DissimilarityIndex is activated with <code>DI_threshold: 1</code>. Finally, noise can also be added to the data with <code>noise_standard_deviation: 0.1</code>. Finally, users can add DBSCAN outlier removal with <code>use_DBSCAN_to_remove_outliers: true</code>.</p> <p>More information available</p> <p>Please review the parameter table for more information on these parameters.</p>"},{"location":"freqai-feature-engineering/#customizing-the-pipeline","title":"Customizing the pipeline","text":"<p>Users are encouraged to customize the data pipeline to their needs by building their own data pipeline. This can be done by simply setting <code>dk.feature_pipeline</code> to their desired <code>Pipeline</code> object inside their <code>IFreqaiModel</code> <code>train()</code> function, or if they prefer not to touch the <code>train()</code> function, they can override <code>define_data_pipeline</code>/<code>define_label_pipeline</code> functions in their <code>IFreqaiModel</code>:</p> <p>More information available</p> <p>FreqAI uses the <code>DataSieve</code> pipeline, which follows the SKlearn pipeline API, but adds, among other features, coherence between the X, y, and sample_weight vector point removals, feature removal, feature name following. </p> <pre><code>from datasieve.transforms import SKLearnWrapper, DissimilarityIndex\nfrom datasieve.pipeline import Pipeline\nfrom sklearn.preprocessing import QuantileTransformer, StandardScaler\nfrom freqai.base_models import BaseRegressionModel\n\n\nclass MyFreqaiModel(BaseRegressionModel):\n    \"\"\"\n    Some cool custom model\n    \"\"\"\n    def fit(self, data_dictionary: Dict, dk: FreqaiDataKitchen, **kwargs) -&gt; Any:\n        \"\"\"\n        My custom fit function\n        \"\"\"\n        model = cool_model.fit()\n        return model\n\n    def define_data_pipeline(self) -&gt; Pipeline:\n        \"\"\"\n        User defines their custom feature pipeline here (if they wish)\n        \"\"\"\n        feature_pipeline = Pipeline([\n            ('qt', SKLearnWrapper(QuantileTransformer(output_distribution='normal'))),\n            ('di', ds.DissimilarityIndex(di_threshold=1))\n        ])\n\n        return feature_pipeline\n\n    def define_label_pipeline(self) -&gt; Pipeline:\n        \"\"\"\n        User defines their custom label pipeline here (if they wish)\n        \"\"\"\n        label_pipeline = Pipeline([\n            ('qt', SKLearnWrapper(StandardScaler())),\n        ])\n\n        return label_pipeline\n</code></pre> <p>Here, you are defining the exact pipeline that will be used for your feature set during training and prediction. You can use most SKLearn transformation steps by wrapping them in the <code>SKLearnWrapper</code> class as shown above. In addition, you can use any of the transformations available in the <code>DataSieve</code> library. </p> <p>You can easily add your own transformation by creating a class that inherits from the datasieve <code>BaseTransform</code> and implementing your <code>fit()</code>, <code>transform()</code> and <code>inverse_transform()</code> methods:</p> <pre><code>from datasieve.transforms.base_transform import BaseTransform\n# import whatever else you need\n\nclass MyCoolTransform(BaseTransform):\n    def __init__(self, **kwargs):\n        self.param1 = kwargs.get('param1', 1)\n\n    def fit(self, X, y=None, sample_weight=None, feature_list=None, **kwargs):\n        # do something with X, y, sample_weight, or/and feature_list\n        return X, y, sample_weight, feature_list\n\n    def transform(self, X, y=None, sample_weight=None,\n                  feature_list=None, outlier_check=False, **kwargs):\n        # do something with X, y, sample_weight, or/and feature_list\n        return X, y, sample_weight, feature_list\n\n    def inverse_transform(self, X, y=None, sample_weight=None, feature_list=None, **kwargs):\n        # do/dont do something with X, y, sample_weight, or/and feature_list\n        return X, y, sample_weight, feature_list\n</code></pre> <p>Hint</p> <p>You can define this custom class in the same file as your <code>IFreqaiModel</code>.</p>"},{"location":"freqai-feature-engineering/#migrating-a-custom-ifreqaimodel-to-the-new-pipeline","title":"Migrating a custom <code>IFreqaiModel</code> to the new Pipeline","text":"<p>If you have created your own custom <code>IFreqaiModel</code> with a custom <code>train()</code>/<code>predict()</code> function, and you still rely on <code>data_cleaning_train/predict()</code>, then you will need to migrate to the new pipeline. If your model does not rely on <code>data_cleaning_train/predict()</code>, then you do not need to worry about this migration.</p> <p>More details about the migration can be found here.</p>"},{"location":"freqai-feature-engineering/#outlier-detection","title":"Outlier detection","text":"<p>Equity and crypto markets suffer from a high level of non-patterned noise in the form of outlier data points. FreqAI implements a variety of methods to identify such outliers and hence mitigate risk.</p>"},{"location":"freqai-feature-engineering/#identifying-outliers-with-the-dissimilarity-index-di","title":"Identifying outliers with the Dissimilarity Index (DI)","text":"<p>The Dissimilarity Index (DI) aims to quantify the uncertainty associated with each prediction made by the model. </p> <p>You can tell FreqAI to remove outlier data points from the training/test data sets using the DI by including the following statement in the config:</p> <pre><code>    \"freqai\": {\n        \"feature_parameters\" : {\n            \"DI_threshold\": 1\n        }\n    }\n</code></pre> <p>Which will add <code>DissimilarityIndex</code> step to your <code>feature_pipeline</code> and set the threshold to 1. The DI allows predictions which are outliers (not existent in the model feature space) to be thrown out due to low levels of certainty. To do so, FreqAI measures the distance between each training data point (feature vector), \\(X_{a}\\), and all other training data points:</p> \\[ d_{ab} = \\sqrt{\\sum_{j=1}^p(X_{a,j}-X_{b,j})^2} \\] <p>where \\(d_{ab}\\) is the distance between the normalized points \\(a\\) and \\(b\\), and \\(p\\) is the number of features, i.e., the length of the vector \\(X\\). The characteristic distance, \\(\\overline{d}\\), for a set of training data points is simply the mean of the average distances:</p> \\[ \\overline{d} = \\sum_{a=1}^n(\\sum_{b=1}^n(d_{ab}/n)/n) \\] <p>\\(\\overline{d}\\) quantifies the spread of the training data, which is compared to the distance between a new prediction feature vectors, \\(X_k\\) and all the training data:</p> \\[ d_k = \\arg \\min d_{k,i} \\] <p>This enables the estimation of the Dissimilarity Index as:</p> \\[ DI_k = d_k/\\overline{d} \\] <p>You can tweak the DI through the <code>DI_threshold</code> to increase or decrease the extrapolation of the trained model. A higher <code>DI_threshold</code> means that the DI is more lenient and allows predictions further away from the training data to be used whilst a lower <code>DI_threshold</code> has the opposite effect and hence discards more predictions.</p> <p>Below is a figure that describes the DI for a 3D data set.</p> <p></p>"},{"location":"freqai-feature-engineering/#identifying-outliers-using-a-support-vector-machine-svm","title":"Identifying outliers using a Support Vector Machine (SVM)","text":"<p>You can tell FreqAI to remove outlier data points from the training/test data sets using a Support Vector Machine (SVM) by including the following statement in the config:</p> <pre><code>    \"freqai\": {\n        \"feature_parameters\" : {\n            \"use_SVM_to_remove_outliers\": true\n        }\n    }\n</code></pre> <p>Which will add <code>SVMOutlierExtractor</code> step to your <code>feature_pipeline</code>. The SVM will be trained on the training data and any data point that the SVM deems to be beyond the feature space will be removed.</p> <p>You can elect to provide additional parameters for the SVM, such as <code>shuffle</code>, and <code>nu</code> via the <code>feature_parameters.svm_params</code> dictionary in the config.</p> <p>The parameter <code>shuffle</code> is by default set to <code>False</code> to ensure consistent results. If it is set to <code>True</code>, running the SVM multiple times on the same data set might result in different outcomes due to <code>max_iter</code> being to low for the algorithm to reach the demanded <code>tol</code>. Increasing <code>max_iter</code> solves this issue but causes the procedure to take longer time.</p> <p>The parameter <code>nu</code>, very broadly, is the amount of data points that should be considered outliers and should be between 0 and 1.</p>"},{"location":"freqai-feature-engineering/#identifying-outliers-with-dbscan","title":"Identifying outliers with DBSCAN","text":"<p>You can configure FreqAI to use DBSCAN to cluster and remove outliers from the training/test data set or incoming outliers from predictions, by activating <code>use_DBSCAN_to_remove_outliers</code> in the config:</p> <pre><code>    \"freqai\": {\n        \"feature_parameters\" : {\n            \"use_DBSCAN_to_remove_outliers\": true\n        }\n    }\n</code></pre> <p>Which will add the <code>DataSieveDBSCAN</code> step to your <code>feature_pipeline</code>. This is an unsupervised machine learning algorithm that clusters data without needing to know how many clusters there should be.</p> <p>Given a number of data points \\(N\\), and a distance \\(\\varepsilon\\), DBSCAN clusters the data set by setting all data points that have \\(N-1\\) other data points within a distance of \\(\\varepsilon\\) as core points. A data point that is within a distance of \\(\\varepsilon\\) from a core point but that does not have \\(N-1\\) other data points within a distance of \\(\\varepsilon\\) from itself is considered an edge point. A cluster is then the collection of core points and edge points. Data points that have no other data points at a distance \\(&lt;\\varepsilon\\) are considered outliers. The figure below shows a cluster with \\(N = 3\\).</p> <p></p> <p>FreqAI uses <code>sklearn.cluster.DBSCAN</code> (details are available on scikit-learn's webpage here (external website)) with <code>min_samples</code> (\\(N\\)) taken as \u00bc of the no. of time points (candles) in the feature set. <code>eps</code> (\\(\\varepsilon\\)) is computed automatically as the elbow point in the k-distance graph computed from the nearest neighbors in the pairwise distances of all data points in the feature set.</p>"},{"location":"freqai-feature-engineering/#data-dimensionality-reduction-with-principal-component-analysis","title":"Data dimensionality reduction with Principal Component Analysis","text":"<p>You can reduce the dimensionality of your features by activating the principal_component_analysis in the config:</p> <pre><code>    \"freqai\": {\n        \"feature_parameters\" : {\n            \"principal_component_analysis\": true\n        }\n    }\n</code></pre> <p>This will perform PCA on the features and reduce their dimensionality so that the explained variance of the data set is &gt;= 0.999. Reducing data dimensionality makes training the model faster and hence allows for more up-to-date models.</p>"},{"location":"freqai-parameter-table/","title":"Parameter table","text":"<p>The table below will list all configuration parameters available for FreqAI. Some of the parameters are exemplified in <code>config_examples/config_freqai.example.json</code>.</p> <p>Mandatory parameters are marked as Required and have to be set in one of the suggested ways.</p>"},{"location":"freqai-parameter-table/#general-configuration-parameters","title":"General configuration parameters","text":"Parameter Description General configuration parameters within the <code>config.freqai</code> tree <code>freqai</code> Required.  The parent dictionary containing all the parameters for controlling FreqAI.  Datatype: Dictionary. <code>train_period_days</code> Required.  Number of days to use for the training data (width of the sliding window).  Datatype: Positive integer. <code>backtest_period_days</code> Required.  Number of days to inference from the trained model before sliding the <code>train_period_days</code> window defined above, and retraining the model during backtesting (more info here). This can be fractional days, but beware that the provided <code>timerange</code> will be divided by this number to yield the number of trainings necessary to complete the backtest.  Datatype: Float. <code>identifier</code> Required.  A unique ID for the current model. If models are saved to disk, the <code>identifier</code> allows for reloading specific pre-trained models/data.  Datatype: String. <code>live_retrain_hours</code> Frequency of retraining during dry/live runs.  Datatype: Float &gt; 0.  Default: <code>0</code> (models retrain as often as possible). <code>expiration_hours</code> Avoid making predictions if a model is more than <code>expiration_hours</code> old.  Datatype: Positive integer.  Default: <code>0</code> (models never expire). <code>purge_old_models</code> Number of models to keep on disk (not relevant to backtesting). Default is 2, which means that dry/live runs will keep the latest 2 models on disk. Setting to 0 keeps all models. This parameter also accepts a boolean to maintain backwards compatibility.  Datatype: Integer.  Default: <code>2</code>. <code>save_backtest_models</code> Save models to disk when running backtesting. Backtesting operates most efficiently by saving the prediction data and reusing them directly for subsequent runs (when you wish to tune entry/exit parameters). Saving backtesting models to disk also allows to use the same model files for starting a dry/live instance with the same model <code>identifier</code>.  Datatype: Boolean.  Default: <code>False</code> (no models are saved). <code>fit_live_predictions_candles</code> Number of historical candles to use for computing target (label) statistics from prediction data, instead of from the training dataset (more information can be found here).  Datatype: Positive integer. <code>continual_learning</code> Use the final state of the most recently trained model as starting point for the new model, allowing for incremental learning (more information can be found here). Beware that this is currently a naive approach to incremental learning, and it has a high probability of overfitting/getting stuck in local minima while the market moves away from your model. We have the connections here primarily for experimental purposes and so that it is ready for more mature approaches to continual learning in chaotic systems like the crypto market.  Datatype: Boolean.  Default: <code>False</code>. <code>write_metrics_to_disk</code> Collect train timings, inference timings and cpu usage in json file.  Datatype: Boolean.  Default: <code>False</code> <code>data_kitchen_thread_count</code>  Designate the number of threads you want to use for data processing (outlier methods, normalization, etc.). This has no impact on the number of threads used for training. If user does not set it (default), FreqAI will use max number of threads - 2 (leaving 1 physical core available for Freqtrade bot and FreqUI)  Datatype: Positive integer. <code>activate_tensorboard</code>  Indicate whether or not to activate tensorboard for the tensorboard enabled modules (currently Reinforcment Learning, XGBoost, Catboost, and PyTorch). Tensorboard needs Torch installed, which means you will need the torch/RL docker image or you need to answer \"yes\" to the install question about whether or not you wish to install Torch.  Datatype: Boolean.  Default: <code>True</code>."},{"location":"freqai-parameter-table/#feature-parameters","title":"Feature parameters","text":"Parameter Description Feature parameters within the <code>freqai.feature_parameters</code> sub dictionary <code>feature_parameters</code> A dictionary containing the parameters used to engineer the feature set. Details and examples are shown here.  Datatype: Dictionary. <code>include_timeframes</code> A list of timeframes that all indicators in <code>feature_engineering_expand_*()</code> will be created for. The list is added as features to the base indicators dataset.  Datatype: List of timeframes (strings). <code>include_corr_pairlist</code> A list of correlated coins that FreqAI will add as additional features to all <code>pair_whitelist</code> coins. All indicators set in <code>feature_engineering_expand_*()</code> during feature engineering (see details here) will be created for each correlated coin. The correlated coins features are added to the base indicators dataset.  Datatype: List of assets (strings). <code>label_period_candles</code> Number of candles into the future that the labels are created for. This can be used in <code>set_freqai_targets()</code> (see <code>templates/FreqaiExampleStrategy.py</code> for detailed usage). This parameter is not necessarily required, you can create custom labels and choose whether to make use of this parameter or not. Please see <code>templates/FreqaiExampleStrategy.py</code> to see the example usage.  Datatype: Positive integer. <code>include_shifted_candles</code> Add features from previous candles to subsequent candles with the intent of adding historical information. If used, FreqAI will duplicate and shift all features from the <code>include_shifted_candles</code> previous candles so that the information is available for the subsequent candle.  Datatype: Positive integer. <code>weight_factor</code> Weight training data points according to their recency (see details here).  Datatype: Positive float (typically &lt; 1). <code>indicator_max_period_candles</code> No longer used (#7325). Replaced by <code>startup_candle_count</code> which is set in the strategy. <code>startup_candle_count</code> is timeframe independent and defines the maximum period used in <code>feature_engineering_*()</code> for indicator creation. FreqAI uses this parameter together with the maximum timeframe in <code>include_time_frames</code> to calculate how many data points to download such that the first data point does not include a NaN.  Datatype: Positive integer. <code>indicator_periods_candles</code> Time periods to calculate indicators for. The indicators are added to the base indicator dataset.  Datatype: List of positive integers. <code>principal_component_analysis</code> Automatically reduce the dimensionality of the data set using Principal Component Analysis. See details about how it works here Datatype: Boolean.  Default: <code>False</code>. <code>plot_feature_importances</code> Create a feature importance plot for each model for the top/bottom <code>plot_feature_importances</code> number of features. Plot is stored in <code>user_data/models/&lt;identifier&gt;/sub-train-&lt;COIN&gt;_&lt;timestamp&gt;.html</code>.  Datatype: Integer.  Default: <code>0</code>. <code>DI_threshold</code> Activates the use of the Dissimilarity Index for outlier detection when set to &gt; 0. See details about how it works here.  Datatype: Positive float (typically &lt; 1). <code>use_SVM_to_remove_outliers</code> Train a support vector machine to detect and remove outliers from the training dataset, as well as from incoming data points. See details about how it works here.  Datatype: Boolean. <code>svm_params</code> All parameters available in Sklearn's <code>SGDOneClassSVM()</code>. See details about some select parameters here.  Datatype: Dictionary. <code>use_DBSCAN_to_remove_outliers</code> Cluster data using the DBSCAN algorithm to identify and remove outliers from training and prediction data. See details about how it works here.  Datatype: Boolean. <code>noise_standard_deviation</code> If set, FreqAI adds noise to the training features with the aim of preventing overfitting. FreqAI generates random deviates from a gaussian distribution with a standard deviation of <code>noise_standard_deviation</code> and adds them to all data points. <code>noise_standard_deviation</code> should be kept relative to the normalized space, i.e., between -1 and 1. In other words, since data in FreqAI is always normalized to be between -1 and 1, <code>noise_standard_deviation: 0.05</code> would result in 32% of the data being randomly increased/decreased by more than 2.5% (i.e., the percent of data falling within the first standard deviation).  Datatype: Integer.  Default: <code>0</code>. <code>outlier_protection_percentage</code> Enable to prevent outlier detection methods from discarding too much data. If more than <code>outlier_protection_percentage</code> % of points are detected as outliers by the SVM or DBSCAN, FreqAI will log a warning message and ignore outlier detection, i.e., the original dataset will be kept intact. If the outlier protection is triggered, no predictions will be made based on the training dataset.  Datatype: Float.  Default: <code>30</code>. <code>reverse_train_test_order</code> Split the feature dataset (see below) and use the latest data split for training and test on historical split of the data. This allows the model to be trained up to the most recent data point, while avoiding overfitting. However, you should be careful to understand the unorthodox nature of this parameter before employing it.  Datatype: Boolean.  Default: <code>False</code> (no reversal). <code>shuffle_after_split</code> Split the data into train and test sets, and then shuffle both sets individually.  Datatype: Boolean.  Default: <code>False</code>. <code>buffer_train_data_candles</code> Cut <code>buffer_train_data_candles</code> off the beginning and end of the training data after the indicators were populated. The main example use is when predicting maxima and minima, the argrelextrema function  cannot know the maxima/minima at the edges of the timerange. To improve model accuracy, it is best to compute argrelextrema on the full timerange and then use this function to cut off the edges (buffer) by the kernel. In another case, if the targets are set to a shifted price movement, this buffer is unnecessary because the shifted candles at the end of the timerange will be NaN and FreqAI will automatically cut those off of the training dataset. Datatype: Integer.  Default: <code>0</code>."},{"location":"freqai-parameter-table/#data-split-parameters","title":"Data split parameters","text":"Parameter Description Data split parameters within the <code>freqai.data_split_parameters</code> sub dictionary <code>data_split_parameters</code> Include any additional parameters available from scikit-learn <code>test_train_split()</code>, which are shown here (external website).  Datatype: Dictionary. <code>test_size</code> The fraction of data that should be used for testing instead of training.  Datatype: Positive float &lt; 1. <code>shuffle</code> Shuffle the training data points during training. Typically, to not remove the chronological order of data in time-series forecasting, this is set to <code>False</code>.  Datatype: Boolean.  Default: <code>False</code>."},{"location":"freqai-parameter-table/#model-training-parameters","title":"Model training parameters","text":"Parameter Description Model training parameters within the <code>freqai.model_training_parameters</code> sub dictionary <code>model_training_parameters</code> A flexible dictionary that includes all parameters available by the selected model library. For example, if you use <code>LightGBMRegressor</code>, this dictionary can contain any parameter available by the <code>LightGBMRegressor</code> here (external website). If you select a different model, this dictionary can contain any parameter from that model. A list of the currently available models can be found here.   Datatype: Dictionary. <code>n_estimators</code> The number of boosted trees to fit in the training of the model.  Datatype: Integer. <code>learning_rate</code> Boosting learning rate during training of the model.  Datatype: Float. <code>n_jobs</code>, <code>thread_count</code>, <code>task_type</code> Set the number of threads for parallel processing and the <code>task_type</code> (<code>gpu</code> or <code>cpu</code>). Different model libraries use different parameter names.  Datatype: Float."},{"location":"freqai-parameter-table/#reinforcement-learning-parameters","title":"Reinforcement Learning parameters","text":"Parameter Description Reinforcement Learning Parameters within the <code>freqai.rl_config</code> sub dictionary <code>rl_config</code> A dictionary containing the control parameters for a Reinforcement Learning model.  Datatype: Dictionary. <code>train_cycles</code> Training time steps will be set based on the `train_cycles * number of training data points.  Datatype: Integer. <code>max_trade_duration_candles</code> Guides the agent training to keep trades below desired length. Example usage shown in <code>prediction_models/ReinforcementLearner.py</code> within the customizable <code>calculate_reward()</code> function.  Datatype: int. <code>model_type</code> Model string from stable_baselines3 or SBcontrib. Available strings include: <code>'TRPO', 'ARS', 'RecurrentPPO', 'MaskablePPO', 'PPO', 'A2C', 'DQN'</code>. User should ensure that <code>model_training_parameters</code> match those available to the corresponding stable_baselines3 model by visiting their documentation. PPO doc (external website)  Datatype: string. <code>policy_type</code> One of the available policy types from stable_baselines3  Datatype: string. <code>max_training_drawdown_pct</code> The maximum drawdown that the agent is allowed to experience during training.  Datatype: float.  Default: 0.8 <code>cpu_count</code> Number of threads/cpus to dedicate to the Reinforcement Learning training process (depending on if <code>ReinforcementLearning_multiproc</code> is selected or not). Recommended to leave this untouched, by default, this value is set to the total number of physical cores minus 1.  Datatype: int. <code>model_reward_parameters</code> Parameters used inside the customizable <code>calculate_reward()</code> function in <code>ReinforcementLearner.py</code> Datatype: int. <code>add_state_info</code> Tell FreqAI to include state information in the feature set for training and inferencing. The current state variables include trade duration, current profit, trade position. This is only available in dry/live runs, and is automatically switched to false for backtesting.  Datatype: bool.  Default: <code>False</code>. <code>net_arch</code> Network architecture which is well described in <code>stable_baselines3</code> doc. In summary: <code>[&lt;shared layers&gt;, dict(vf=[&lt;non-shared value network layers&gt;], pi=[&lt;non-shared policy network layers&gt;])]</code>. By default this is set to <code>[128, 128]</code>, which defines 2 shared hidden layers with 128 units each. <code>randomize_starting_position</code> Randomize the starting point of each episode to avoid overfitting.  Datatype: bool.  Default: <code>False</code>. <code>drop_ohlc_from_features</code> Do not include the normalized ohlc data in the feature set passed to the agent during training (ohlc will still be used for driving the environment in all cases)  Datatype: Boolean.  Default: <code>False</code> <code>progress_bar</code> Display a progress bar with the current progress, elapsed time and estimated remaining time.  Datatype: Boolean.  Default: <code>False</code>."},{"location":"freqai-parameter-table/#pytorch-parameters","title":"PyTorch parameters","text":""},{"location":"freqai-parameter-table/#general","title":"general","text":"Parameter Description Model training parameters within the <code>freqai.model_training_parameters</code> sub dictionary <code>learning_rate</code> Learning rate to be passed to the optimizer.  Datatype: float.  Default: <code>3e-4</code>. <code>model_kwargs</code> Parameters to be passed to the model class.  Datatype: dict.  Default: <code>{}</code>. <code>trainer_kwargs</code> Parameters to be passed to the trainer class.  Datatype: dict.  Default: <code>{}</code>."},{"location":"freqai-parameter-table/#trainer_kwargs","title":"trainer_kwargs","text":"Parameter Description Model training parameters within the <code>freqai.model_training_parameters.model_kwargs</code> sub dictionary <code>n_epochs</code> The <code>n_epochs</code> parameter is a crucial setting in the PyTorch training loop that determines the number of times the entire training dataset will be used to update the model's parameters. An epoch represents one full pass through the entire training dataset. Overrides <code>n_steps</code>. Either <code>n_epochs</code> or <code>n_steps</code> must be set.  Datatype: int. optional.  Default: <code>10</code>. <code>n_steps</code> An alternative way of setting <code>n_epochs</code> -  the number of training iterations to run. Iteration here refer to the number of times we call <code>optimizer.step()</code>. Ignored if <code>n_epochs</code> is set. A simplified version of the function:  n_epochs = n_steps / (n_obs / batch_size)  The motivation here is that <code>n_steps</code> is easier to optimize and keep stable across different n_obs - the number of data points.   Datatype: int. optional.  Default: <code>None</code>. <code>batch_size</code> The size of the batches to use during training.  Datatype: int.  Default: <code>64</code>."},{"location":"freqai-parameter-table/#additional-parameters","title":"Additional parameters","text":"Parameter Description Extraneous parameters <code>freqai.keras</code> If the selected model makes use of Keras (typical for TensorFlow-based prediction models), this flag needs to be activated so that the model save/loading follows Keras standards.  Datatype: Boolean.  Default: <code>False</code>. <code>freqai.conv_width</code> The width of a neural network input tensor. This replaces the need for shifting candles (<code>include_shifted_candles</code>) by feeding in historical data points as the second dimension of the tensor. Technically, this parameter can also be used for regressors, but it only adds computational overhead and does not change the model training/prediction.  Datatype: Integer.  Default: <code>2</code>. <code>freqai.reduce_df_footprint</code> Recast all numeric columns to float32/int32, with the objective of reducing ram/disk usage and decreasing train/inference timing. This parameter is set in the main level of the Freqtrade configuration file (not inside FreqAI).  Datatype: Boolean.  Default: <code>False</code>."},{"location":"freqai-reinforcement-learning/","title":"Reinforcement Learning","text":"<p>Installation size</p> <p>Reinforcement learning dependencies include large packages such as <code>torch</code>, which should be explicitly requested during <code>./setup.sh -i</code> by answering \"y\" to the question \"Do you also want dependencies for freqai-rl (~700mb additional space required) [y/N]?\". Users who prefer docker should ensure they use the docker image appended with <code>_freqairl</code>.</p>"},{"location":"freqai-reinforcement-learning/#background-and-terminology","title":"Background and terminology","text":""},{"location":"freqai-reinforcement-learning/#what-is-rl-and-why-does-freqai-need-it","title":"What is RL and why does FreqAI need it?","text":"<p>Reinforcement learning involves two important components, the agent and the training environment. During agent training, the agent moves through historical data candle by candle, always making 1 of a set of actions: Long entry, long exit, short entry, short exit, neutral). During this training process, the environment tracks the performance of these actions and rewards the agent according to a custom user made <code>calculate_reward()</code> (here we offer a default reward for users to build on if they wish details here). The reward is used to train weights in a neural network.</p> <p>A second important component of the FreqAI RL implementation is the use of state information. State information is fed into the network at each step, including current profit, current position, and current trade duration. These are used to train the agent in the training environment, and to reinforce the agent in dry/live (this functionality is not available in backtesting). FreqAI + Freqtrade is a perfect match for this reinforcing mechanism since this information is readily available in live deployments.</p> <p>Reinforcement learning is a natural progression for FreqAI, since it adds a new layer of adaptivity and market reactivity that Classifiers and Regressors cannot match. However, Classifiers and Regressors have strengths that RL does not have such as robust predictions. Improperly trained RL agents may find \"cheats\" and \"tricks\" to maximize reward without actually winning any trades. For this reason, RL is more complex and demands a higher level of understanding than typical Classifiers and Regressors.</p>"},{"location":"freqai-reinforcement-learning/#the-rl-interface","title":"The RL interface","text":"<p>With the current framework, we aim to expose the training environment via the common \"prediction model\" file, which is a user inherited <code>BaseReinforcementLearner</code> object (e.g. <code>freqai/prediction_models/ReinforcementLearner</code>). Inside this user class, the RL environment is available and customized via <code>MyRLEnv</code> as shown below.</p> <p>We envision the majority of users focusing their effort on creative design of the <code>calculate_reward()</code> function details here, while leaving the rest of the environment untouched. Other users may not touch the environment at all, and they will only play with the configuration settings and the powerful feature engineering that already exists in FreqAI. Meanwhile, we enable advanced users to create their own model classes entirely.</p> <p>The framework is built on stable_baselines3 (torch) and OpenAI gym for the base environment class. But generally speaking, the model class is well isolated. Thus, the addition of competing libraries can be easily integrated into the existing framework. For the environment, it is inheriting from <code>gym.Env</code> which means that it is necessary to write an entirely new environment in order to switch to a different library.</p>"},{"location":"freqai-reinforcement-learning/#important-considerations","title":"Important considerations","text":"<p>As explained above, the agent is \"trained\" in an artificial trading \"environment\". In our case, that environment may seem quite similar to a real Freqtrade backtesting environment, but it is NOT. In fact, the RL training environment is much more simplified. It does not incorporate any of the complicated strategy logic, such as callbacks like <code>custom_exit</code>, <code>custom_stoploss</code>, leverage controls, etc. The RL environment is instead a very \"raw\" representation of the true market, where the agent has free will to learn the policy (read: stoploss, take profit, etc.) which is enforced by the <code>calculate_reward()</code>. Thus, it is important to consider that the agent training environment is not identical to the real world.</p>"},{"location":"freqai-reinforcement-learning/#running-reinforcement-learning","title":"Running Reinforcement Learning","text":"<p>Setting up and running a Reinforcement Learning model is the same as running a Regressor or Classifier. The same two flags, <code>--freqaimodel</code> and <code>--strategy</code>, must be defined on the command line:</p> <pre><code>freqtrade trade --freqaimodel ReinforcementLearner --strategy MyRLStrategy --config config.json\n</code></pre> <p>where <code>ReinforcementLearner</code> will use the templated <code>ReinforcementLearner</code> from <code>freqai/prediction_models/ReinforcementLearner</code> (or a custom user defined one located in <code>user_data/freqaimodels</code>). The strategy, on the other hand, follows the same base feature engineering with <code>feature_engineering_*</code> as a typical Regressor. The difference lies in the creation of the targets, Reinforcement Learning doesn't require them. However, FreqAI requires a default (neutral) value to be set in the action column:</p> <pre><code>    def set_freqai_targets(self, dataframe, **kwargs) -&gt; DataFrame:\n        \"\"\"\n        *Only functional with FreqAI enabled strategies*\n        Required function to set the targets for the model.\n        All targets must be prepended with `&amp;` to be recognized by the FreqAI internals.\n\n        More details about feature engineering available:\n\n        https://www.freqtrade.io/en/latest/freqai-feature-engineering\n\n        :param df: strategy dataframe which will receive the targets\n        usage example: dataframe[\"&amp;-target\"] = dataframe[\"close\"].shift(-1) / dataframe[\"close\"]\n        \"\"\"\n        # For RL, there are no direct targets to set. This is filler (neutral)\n        # until the agent sends an action.\n        dataframe[\"&amp;-action\"] = 0\n        return dataframe\n</code></pre> <p>Most of the function remains the same as for typical Regressors, however, the function below shows how the strategy must pass the raw price data to the agent so that it has access to raw OHLCV in the training environment:</p> <pre><code>    def feature_engineering_standard(self, dataframe: DataFrame, **kwargs) -&gt; DataFrame:\n        # The following features are necessary for RL models\n        dataframe[f\"%-raw_close\"] = dataframe[\"close\"]\n        dataframe[f\"%-raw_open\"] = dataframe[\"open\"]\n        dataframe[f\"%-raw_high\"] = dataframe[\"high\"]\n        dataframe[f\"%-raw_low\"] = dataframe[\"low\"]\n    return dataframe\n</code></pre> <p>Finally, there is no explicit \"label\" to make - instead it is necessary to assign the <code>&amp;-action</code> column which will contain the agent's actions when accessed in <code>populate_entry/exit_trends()</code>. In the present example, the neutral action to 0. This value should align with the environment used. FreqAI provides two environments, both use 0 as the neutral action.</p> <p>After users realize there are no labels to set, they will soon understand that the agent is making its \"own\" entry and exit decisions. This makes strategy construction rather simple. The entry and exit signals come from the agent in the form of an integer - which are used directly to decide entries and exits in the strategy:</p> <pre><code>    def populate_entry_trend(self, df: DataFrame, metadata: dict) -&gt; DataFrame:\n\n        enter_long_conditions = [df[\"do_predict\"] == 1, df[\"&amp;-action\"] == 1]\n\n        if enter_long_conditions:\n            df.loc[\n                reduce(lambda x, y: x &amp; y, enter_long_conditions), [\"enter_long\", \"enter_tag\"]\n            ] = (1, \"long\")\n\n        enter_short_conditions = [df[\"do_predict\"] == 1, df[\"&amp;-action\"] == 3]\n\n        if enter_short_conditions:\n            df.loc[\n                reduce(lambda x, y: x &amp; y, enter_short_conditions), [\"enter_short\", \"enter_tag\"]\n            ] = (1, \"short\")\n\n        return df\n\n    def populate_exit_trend(self, df: DataFrame, metadata: dict) -&gt; DataFrame:\n        exit_long_conditions = [df[\"do_predict\"] == 1, df[\"&amp;-action\"] == 2]\n        if exit_long_conditions:\n            df.loc[reduce(lambda x, y: x &amp; y, exit_long_conditions), \"exit_long\"] = 1\n\n        exit_short_conditions = [df[\"do_predict\"] == 1, df[\"&amp;-action\"] == 4]\n        if exit_short_conditions:\n            df.loc[reduce(lambda x, y: x &amp; y, exit_short_conditions), \"exit_short\"] = 1\n\n        return df\n</code></pre> <p>It is important to consider that <code>&amp;-action</code> depends on which environment they choose to use. The example above shows 5 actions, where 0 is neutral, 1 is enter long, 2 is exit long, 3 is enter short and 4 is exit short.</p>"},{"location":"freqai-reinforcement-learning/#configuring-the-reinforcement-learner","title":"Configuring the Reinforcement Learner","text":"<p>In order to configure the <code>Reinforcement Learner</code> the following dictionary must exist in the <code>freqai</code> config:</p> <pre><code>        \"rl_config\": {\n            \"train_cycles\": 25,\n            \"add_state_info\": true,\n            \"max_trade_duration_candles\": 300,\n            \"max_training_drawdown_pct\": 0.02,\n            \"cpu_count\": 8,\n            \"model_type\": \"PPO\",\n            \"policy_type\": \"MlpPolicy\",\n            \"model_reward_parameters\": {\n                \"rr\": 1,\n                \"profit_aim\": 0.025\n            }\n        }\n</code></pre> <p>Parameter details can be found here, but in general the <code>train_cycles</code> decides how many times the agent should cycle through the candle data in its artificial environment to train weights in the model. <code>model_type</code> is a string which selects one of the available models in stable_baselines(external link).</p> <p>Note</p> <p>If you would like to experiment with <code>continual_learning</code>, then you should set that value to <code>true</code> in the main <code>freqai</code> configuration dictionary. This will tell the Reinforcement Learning library to continue training new models from the final state of previous models, instead of retraining new models from scratch each time a retrain is initiated.</p> <p>Note</p> <p>Remember that the general <code>model_training_parameters</code> dictionary should contain all the model hyperparameter customizations for the particular <code>model_type</code>. For example, <code>PPO</code> parameters can be found here.</p>"},{"location":"freqai-reinforcement-learning/#creating-a-custom-reward-function","title":"Creating a custom reward function","text":"<p>Not for production</p> <p>Warning! The reward function provided with the Freqtrade source code is a showcase of functionality designed to show/test as many possible environment control features as possible. It is also designed to run quickly on small computers. This is a benchmark, it is not for live production. Please beware that you will need to create your own custom_reward() function or use a template built by other users outside of the Freqtrade source code.</p> <p>As you begin to modify the strategy and the prediction model, you will quickly realize some important differences between the Reinforcement Learner and the Regressors/Classifiers. Firstly, the strategy does not set a target value (no labels!). Instead, you set the <code>calculate_reward()</code> function inside the <code>MyRLEnv</code> class (see below). A default <code>calculate_reward()</code> is provided inside <code>prediction_models/ReinforcementLearner.py</code> to demonstrate the necessary building blocks for creating rewards, but this is not designed for production. Users must create their own custom reinforcement learning model class or use a pre-built one from outside the Freqtrade source code and save it to <code>user_data/freqaimodels</code>. It is inside the <code>calculate_reward()</code> where creative theories about the market can be expressed. For example, you can reward your agent when it makes a winning trade, and penalize the agent when it makes a losing trade. Or perhaps, you wish to reward the agent for entering trades, and penalize the agent for sitting in trades too long. Below we show examples of how these rewards are all calculated:</p> <p>Hint</p> <p>The best reward functions are ones that are continuously differentiable, and well scaled. In other words, adding a single large negative penalty to a rare event is not a good idea, and the neural net will not be able to learn that function. Instead, it is better to add a small negative penalty to a common event. This will help the agent learn faster. Not only this, but you can help improve the continuity of your rewards/penalties by having them scale with severity according to some linear/exponential functions. In other words, you'd slowly scale the penalty as the duration of the trade increases. This is better than a single large penalty occurring at a single point in time.</p> <pre><code>from freqtrade.freqai.prediction_models.ReinforcementLearner import ReinforcementLearner\nfrom freqtrade.freqai.RL.Base5ActionRLEnv import Actions, Base5ActionRLEnv, Positions\n\n\nclass MyCoolRLModel(ReinforcementLearner):\n    \"\"\"\n    User created RL prediction model.\n\n    Save this file to `freqtrade/user_data/freqaimodels`\n\n    then use it with:\n\n    freqtrade trade --freqaimodel MyCoolRLModel --config config.json --strategy SomeCoolStrat\n\n    Here the users can override any of the functions\n    available in the `IFreqaiModel` inheritance tree. Most importantly for RL, this\n    is where the user overrides `MyRLEnv` (see below), to define custom\n    `calculate_reward()` function, or to override any other parts of the environment.\n\n    This class also allows users to override any other part of the IFreqaiModel tree.\n    For example, the user can override `def fit()` or `def train()` or `def predict()`\n    to take fine-tuned control over these processes.\n\n    Another common override may be `def data_cleaning_predict()` where the user can\n    take fine-tuned control over the data handling pipeline.\n    \"\"\"\n    class MyRLEnv(Base5ActionRLEnv):\n        \"\"\"\n        User made custom environment. This class inherits from BaseEnvironment and gym.Env.\n        Users can override any functions from those parent classes. Here is an example\n        of a user customized `calculate_reward()` function.\n\n        Warning!\n        This is function is a showcase of functionality designed to show as many possible\n        environment control features as possible. It is also designed to run quickly\n        on small computers. This is a benchmark, it is *not* for live production.\n        \"\"\"\n        def calculate_reward(self, action: int) -&gt; float:\n            # first, penalize if the action is not valid\n            if not self._is_valid(action):\n                return -2\n            pnl = self.get_unrealized_profit()\n\n            factor = 100\n\n            pair = self.pair.replace(':', '')\n\n            # you can use feature values from dataframe\n            # Assumes the shifted RSI indicator has been generated in the strategy.\n            rsi_now = self.raw_features[f\"%-rsi-period_10_shift-1_{pair}_\"\n                            f\"{self.config['timeframe']}\"].iloc[self._current_tick]\n\n            # reward agent for entering trades\n            if (action in (Actions.Long_enter.value, Actions.Short_enter.value)\n                    and self._position == Positions.Neutral):\n                if rsi_now &lt; 40:\n                    factor = 40 / rsi_now\n                else:\n                    factor = 1\n                return 25 * factor\n\n            # discourage agent from not entering trades\n            if action == Actions.Neutral.value and self._position == Positions.Neutral:\n                return -1\n            max_trade_duration = self.rl_config.get('max_trade_duration_candles', 300)\n            trade_duration = self._current_tick - self._last_trade_tick\n            if trade_duration &lt;= max_trade_duration:\n                factor *= 1.5\n            elif trade_duration &gt; max_trade_duration:\n                factor *= 0.5\n            # discourage sitting in position\n            if self._position in (Positions.Short, Positions.Long) and \\\n            action == Actions.Neutral.value:\n                return -1 * trade_duration / max_trade_duration\n            # close long\n            if action == Actions.Long_exit.value and self._position == Positions.Long:\n                if pnl &gt; self.profit_aim * self.rr:\n                    factor *= self.rl_config['model_reward_parameters'].get('win_reward_factor', 2)\n                return float(pnl * factor)\n            # close short\n            if action == Actions.Short_exit.value and self._position == Positions.Short:\n                if pnl &gt; self.profit_aim * self.rr:\n                    factor *= self.rl_config['model_reward_parameters'].get('win_reward_factor', 2)\n                return float(pnl * factor)\n            return 0.\n</code></pre>"},{"location":"freqai-reinforcement-learning/#using-tensorboard","title":"Using Tensorboard","text":"<p>Reinforcement Learning models benefit from tracking training metrics. FreqAI has integrated Tensorboard to allow users to track training and evaluation performance across all coins and across all retrainings. Tensorboard is activated via the following command:</p> <pre><code>tensorboard --logdir user_data/models/unique-id\n</code></pre> <p>where <code>unique-id</code> is the <code>identifier</code> set in the <code>freqai</code> configuration file. This command must be run in a separate shell to view the output in the browser at 127.0.0.1:6006 (6006 is the default port used by Tensorboard).</p> <p></p>"},{"location":"freqai-reinforcement-learning/#custom-logging","title":"Custom logging","text":"<p>FreqAI also provides a built in episodic summary logger called <code>self.tensorboard_log</code> for adding custom information to the Tensorboard log. By default, this function is already called once per step inside the environment to record the agent actions. All values accumulated for all steps in a single episode are reported at the conclusion of each episode, followed by a full reset of all metrics to 0 in preparation for the subsequent episode.</p> <p><code>self.tensorboard_log</code> can also be used anywhere inside the environment, for example, it can be added to the <code>calculate_reward</code> function to collect more detailed information about how often various parts of the reward were called:</p> <pre><code>    class MyRLEnv(Base5ActionRLEnv):\n        \"\"\"\n        User made custom environment. This class inherits from BaseEnvironment and gym.Env.\n        Users can override any functions from those parent classes. Here is an example\n        of a user customized `calculate_reward()` function.\n        \"\"\"\n        def calculate_reward(self, action: int) -&gt; float:\n            if not self._is_valid(action):\n                self.tensorboard_log(\"invalid\")\n                return -2\n</code></pre> <p>Note</p> <p>The <code>self.tensorboard_log()</code> function is designed for tracking incremented objects only i.e. events, actions inside the training environment. If the event of interest is a float, the float can be passed as the second argument e.g. <code>self.tensorboard_log(\"float_metric1\", 0.23)</code>. In this case the metric values are not incremented.</p>"},{"location":"freqai-reinforcement-learning/#choosing-a-base-environment","title":"Choosing a base environment","text":"<p>FreqAI provides three base environments, <code>Base3ActionRLEnvironment</code>, <code>Base4ActionEnvironment</code> and <code>Base5ActionEnvironment</code>. As the names imply, the environments are customized for agents that can select from 3, 4 or 5 actions. The <code>Base3ActionEnvironment</code> is the simplest, the agent can select from hold, long, or short. This environment can also be used for long-only bots (it automatically follows the <code>can_short</code> flag from the strategy), where long is the enter condition and short is the exit condition. Meanwhile, in the <code>Base4ActionEnvironment</code>, the agent can enter long, enter short, hold neutral, or exit position. Finally, in the <code>Base5ActionEnvironment</code>, the agent has the same actions as Base4, but instead of a single exit action, it separates exit long and exit short. The main changes stemming from the environment selection include:</p> <ul> <li>the actions available in the <code>calculate_reward</code></li> <li>the actions consumed by the user strategy</li> </ul> <p>All of the FreqAI provided environments inherit from an action/position agnostic environment object called the <code>BaseEnvironment</code>, which contains all shared logic. The architecture is designed to be easily customized. The simplest customization is the <code>calculate_reward()</code> (see details here). However, the customizations can be further extended into any of the functions inside the environment. You can do this by simply overriding those functions inside your <code>MyRLEnv</code> in the prediction model file. Or for more advanced customizations, it is encouraged to create an entirely new environment inherited from <code>BaseEnvironment</code>.</p> <p>Note</p> <p>Only the <code>Base3ActionRLEnv</code> can do long-only training/trading (set the user strategy attribute <code>can_short = False</code>).</p>"},{"location":"freqai-running/","title":"Running FreqAI","text":"<p>There are two ways to train and deploy an adaptive machine learning model - live deployment and historical backtesting. In both cases, FreqAI runs/simulates periodic retraining of models as shown in the following figure:</p> <p></p>"},{"location":"freqai-running/#live-deployments","title":"Live deployments","text":"<p>FreqAI can be run dry/live using the following command:</p> <pre><code>freqtrade trade --strategy FreqaiExampleStrategy --config config_freqai.example.json --freqaimodel LightGBMRegressor\n</code></pre> <p>When launched, FreqAI will start training a new model, with a new <code>identifier</code>, based on the config settings. Following training, the model will be used to make predictions on incoming candles until a new model is available. New models are typically generated as often as possible, with FreqAI managing an internal queue of the coin pairs to try to keep all models equally up to date. FreqAI will always use the most recently trained model to make predictions on incoming live data. If you do not want FreqAI to retrain new models as often as possible, you can set <code>live_retrain_hours</code> to tell FreqAI to wait at least that number of hours before training a new model. Additionally, you can set <code>expired_hours</code> to tell FreqAI to avoid making predictions on models that are older than that number of hours.</p> <p>Trained models are by default saved to disk to allow for reuse during backtesting or after a crash. You can opt to purge old models to save disk space by setting <code>\"purge_old_models\": true</code> in the config.</p> <p>To start a dry/live run from a saved backtest model (or from a previously crashed dry/live session), you only need to specify the <code>identifier</code> of the specific model:</p> <pre><code>    \"freqai\": {\n        \"identifier\": \"example\",\n        \"live_retrain_hours\": 0.5\n    }\n</code></pre> <p>In this case, although FreqAI will initiate with a pre-trained model, it will still check to see how much time has elapsed since the model was trained. If a full <code>live_retrain_hours</code> has elapsed since the end of the loaded model, FreqAI will start training a new model.</p>"},{"location":"freqai-running/#automatic-data-download","title":"Automatic data download","text":"<p>FreqAI automatically downloads the proper amount of data needed to ensure training of a model through the defined <code>train_period_days</code> and <code>startup_candle_count</code> (see the parameter table for detailed descriptions of these parameters). </p>"},{"location":"freqai-running/#saving-prediction-data","title":"Saving prediction data","text":"<p>All predictions made during the lifetime of a specific <code>identifier</code> model are stored in <code>historic_predictions.pkl</code> to allow for reloading after a crash or changes made to the config.</p>"},{"location":"freqai-running/#purging-old-model-data","title":"Purging old model data","text":"<p>FreqAI stores new model files after each successful training. These files become obsolete as new models are generated to adapt to new market conditions. If you are planning to leave FreqAI running for extended periods of time with high frequency retraining, you should enable <code>purge_old_models</code> in the config:</p> <pre><code>    \"freqai\": {\n        \"purge_old_models\": 4,\n    }\n</code></pre> <p>This will automatically purge all models older than the four most recently trained ones to save disk space. Inputing \"0\" will never purge any models.</p>"},{"location":"freqai-running/#backtesting","title":"Backtesting","text":"<p>The FreqAI backtesting module can be executed with the following command:</p> <pre><code>freqtrade backtesting --strategy FreqaiExampleStrategy --strategy-path freqtrade/templates --config config_examples/config_freqai.example.json --freqaimodel LightGBMRegressor --timerange 20210501-20210701\n</code></pre> <p>If this command has never been executed with the existing config file, FreqAI will train a new model for each pair, for each backtesting window within the expanded <code>--timerange</code>.</p> <p>Backtesting mode requires downloading the necessary data before deployment (unlike in dry/live mode where FreqAI handles the data downloading automatically). You should be careful to consider that the time range of the downloaded data is more than the backtesting time range. This is because FreqAI needs data prior to the desired backtesting time range in order to train a model to be ready to make predictions on the first candle of the set backtesting time range. More details on how to calculate the data to download can be found here.</p> <p>Model reuse</p> <p>Once the training is completed, you can execute the backtesting again with the same config file and FreqAI will find the trained models and load them instead of spending time training. This is useful if you want to tweak (or even hyperopt) buy and sell criteria inside the strategy. If you want to retrain a new model with the same config file, you should simply change the <code>identifier</code>. This way, you can return to using any model you wish by simply specifying the <code>identifier</code>.</p> <p>Note</p> <p>Backtesting calls <code>set_freqai_targets()</code> one time for each backtest window (where the number of windows is the full backtest timerange divided by the <code>backtest_period_days</code> parameter). Doing this means that the targets simulate dry/live behavior without look ahead bias. However, the definition of the features in <code>feature_engineering_*()</code> is performed once on the entire training timerange. This means that you should be sure that features do not look-ahead into the future. More details about look-ahead bias can be found in Common Mistakes.</p>"},{"location":"freqai-running/#saving-prediction-data_1","title":"Saving prediction data","text":"<p>To allow for tweaking your strategy (not the features!), FreqAI will automatically save the predictions during backtesting so that they can be reused for future backtests and live runs using the same <code>identifier</code> model. This provides a performance enhancement geared towards enabling high-level hyperopting of entry/exit criteria.</p> <p>An additional directory called <code>backtesting_predictions</code>, which contains all the predictions stored in <code>hdf</code> format, will be created in the <code>unique-id</code> folder.</p> <p>To change your features, you must set a new <code>identifier</code> in the config to signal to FreqAI to train new models.</p> <p>To save the models generated during a particular backtest so that you can start a live deployment from one of them instead of training a new model, you must set <code>save_backtest_models</code> to <code>True</code> in the config.</p>"},{"location":"freqai-running/#backtest-live-collected-predictions","title":"Backtest live collected predictions","text":"<p>FreqAI allow you to reuse live historic predictions through the backtest parameter <code>--freqai-backtest-live-models</code>. This can be useful when you want to reuse predictions generated in dry/run for comparison or other study.</p> <p>The <code>--timerange</code> parameter must not be informed, as it will be automatically calculated through the data in the historic predictions file.</p>"},{"location":"freqai-running/#downloading-data-to-cover-the-full-backtest-period","title":"Downloading data to cover the full backtest period","text":"<p>For live/dry deployments, FreqAI will download the necessary data automatically. However, to use backtesting functionality, you need to download the necessary data using <code>download-data</code> (details here). You need to pay careful attention to understanding how much additional data needs to be downloaded to ensure that there is a sufficient amount of training data before the start of the backtesting time range. The amount of additional data can be roughly estimated by moving the start date of the time range backwards by <code>train_period_days</code> and the <code>startup_candle_count</code> (see the parameter table for detailed descriptions of these parameters) from the beginning of the desired backtesting time range. </p> <p>As an example, to backtest the <code>--timerange 20210501-20210701</code> using the example config which sets <code>train_period_days</code> to 30, together with <code>startup_candle_count: 40</code> on a maximum <code>include_timeframes</code> of 1h, the start date for the downloaded data needs to be <code>20210501</code> - 30 days - 40 * 1h / 24 hours = 20210330 (31.7 days earlier than the start of the desired training time range).</p>"},{"location":"freqai-running/#deciding-the-size-of-the-sliding-training-window-and-backtesting-duration","title":"Deciding the size of the sliding training window and backtesting duration","text":"<p>The backtesting time range is defined with the typical <code>--timerange</code> parameter in the configuration file. The duration of the sliding training window is set by <code>train_period_days</code>, whilst <code>backtest_period_days</code> is the sliding backtesting window, both in number of days (<code>backtest_period_days</code> can be a float to indicate sub-daily retraining in live/dry mode). In the presented example config (found in <code>config_examples/config_freqai.example.json</code>), the user is asking FreqAI to use a training period of 30 days and backtest on the subsequent 7 days. After the training of the model, FreqAI will backtest the subsequent 7 days. The \"sliding window\" then moves one week forward (emulating FreqAI retraining once per week in live mode) and the new model uses the previous 30 days (including the 7 days used for backtesting by the previous model) to train. This is repeated until the end of <code>--timerange</code>.  This means that if you set <code>--timerange 20210501-20210701</code>, FreqAI will have trained 8 separate models at the end of <code>--timerange</code> (because the full range comprises 8 weeks).</p> <p>Note</p> <p>Although fractional <code>backtest_period_days</code> is allowed, you should be aware that the <code>--timerange</code> is divided by this value to determine the number of models that FreqAI will need to train in order to backtest the full range. For example, by setting a <code>--timerange</code> of 10 days, and a <code>backtest_period_days</code> of 0.1, FreqAI will need to train 100 models per pair to complete the full backtest. Because of this, a true backtest of FreqAI adaptive training would take a very long time. The best way to fully test a model is to run it dry and let it train constantly. In this case, backtesting would take the exact same amount of time as a dry run.</p>"},{"location":"freqai-running/#defining-model-expirations","title":"Defining model expirations","text":"<p>During dry/live mode, FreqAI trains each coin pair sequentially (on separate threads/GPU from the main Freqtrade bot). This means that there is always an age discrepancy between models. If you are training on 50 pairs, and each pair requires 5 minutes to train, the oldest model will be over 4 hours old. This may be undesirable if the characteristic time scale (the trade duration target) for a strategy is less than 4 hours. You can decide to only make trade entries if the model is less than a certain number of hours old by setting the <code>expiration_hours</code> in the config file:</p> <pre><code>    \"freqai\": {\n        \"expiration_hours\": 0.5,\n    }\n</code></pre> <p>In the presented example config, the user will only allow predictions on models that are less than \u00bd hours old.</p>"},{"location":"freqai-running/#controlling-the-model-learning-process","title":"Controlling the model learning process","text":"<p>Model training parameters are unique to the selected machine learning library. FreqAI allows you to set any parameter for any library using the <code>model_training_parameters</code> dictionary in the config. The example config (found in <code>config_examples/config_freqai.example.json</code>) shows some of the example parameters associated with <code>Catboost</code> and <code>LightGBM</code>, but you can add any parameters available in those libraries or any other machine learning library you choose to implement.</p> <p>Data split parameters are defined in <code>data_split_parameters</code> which can be any parameters associated with scikit-learn's <code>train_test_split()</code> function. <code>train_test_split()</code> has a parameters called <code>shuffle</code> which allows to shuffle the data or keep it unshuffled. This is particularly useful to avoid biasing training with temporally auto-correlated data. More details about these parameters can be found the scikit-learn website (external website).</p> <p>The FreqAI specific parameter <code>label_period_candles</code> defines the offset (number of candles into the future) used for the <code>labels</code>. In the presented example config, the user is asking for <code>labels</code> that are 24 candles in the future.</p>"},{"location":"freqai-running/#continual-learning","title":"Continual learning","text":"<p>You can choose to adopt a continual learning scheme by setting <code>\"continual_learning\": true</code> in the config. By enabling <code>continual_learning</code>, after training an initial model from scratch, subsequent trainings will start from the final model state of the preceding training. This gives the new model a \"memory\" of the previous state. By default, this is set to <code>False</code> which means that all new models are trained from scratch, without input from previous models.</p> Continual learning enforces a constant parameter space <p>Since <code>continual_learning</code> means that the model parameter space cannot change between trainings, <code>principal_component_analysis</code> is automatically disabled when <code>continual_learning</code> is enabled. Hint: PCA changes the parameter space and the number of features, learn more about PCA here.</p> Experimental functionality <p>Beware that this is currently a naive approach to incremental learning, and it has a high probability of overfitting/getting stuck in local minima while the market moves away from your model. We have the mechanics available in FreqAI primarily for experimental purposes and so that it is ready for more mature approaches to continual learning in chaotic systems like the crypto market.</p>"},{"location":"freqai-running/#hyperopt","title":"Hyperopt","text":"<p>You can hyperopt using the same command as for typical Freqtrade hyperopt:</p> <pre><code>freqtrade hyperopt --hyperopt-loss SharpeHyperOptLoss --strategy FreqaiExampleStrategy --freqaimodel LightGBMRegressor --strategy-path freqtrade/templates --config config_examples/config_freqai.example.json --timerange 20220428-20220507\n</code></pre> <p><code>hyperopt</code> requires you to have the data pre-downloaded in the same fashion as if you were doing backtesting. In addition, you must consider some restrictions when trying to hyperopt FreqAI strategies:</p> <ul> <li>The <code>--analyze-per-epoch</code> hyperopt parameter is not compatible with FreqAI.</li> <li>It's not possible to hyperopt indicators in the <code>feature_engineering_*()</code> and <code>set_freqai_targets()</code> functions. This means that you cannot optimize model parameters using hyperopt. Apart from this exception, it is possible to optimize all other spaces.</li> <li>The backtesting instructions also apply to hyperopt.</li> </ul> <p>The best method for combining hyperopt and FreqAI is to focus on hyperopting entry/exit thresholds/criteria. You need to focus on hyperopting parameters that are not used in your features. For example, you should not try to hyperopt rolling window lengths in the feature creation, or any part of the FreqAI config which changes predictions. In order to efficiently hyperopt the FreqAI strategy, FreqAI stores predictions as dataframes and reuses them. Hence the requirement to hyperopt entry/exit thresholds/criteria only.</p> <p>A good example of a hyperoptable parameter in FreqAI is a threshold for the Dissimilarity Index (DI) <code>DI_values</code> beyond which we consider data points as outliers:</p> <pre><code>di_max = IntParameter(low=1, high=20, default=10, space='buy', optimize=True, load=True)\ndataframe['outlier'] = np.where(dataframe['DI_values'] &gt; self.di_max.value/10, 1, 0)\n</code></pre> <p>This specific hyperopt would help you understand the appropriate <code>DI_values</code> for your particular parameter space.</p>"},{"location":"freqai-running/#using-tensorboard","title":"Using Tensorboard","text":"<p>Availability</p> <p>FreqAI includes tensorboard for a variety of models, including XGBoost, all PyTorch models, Reinforcement Learning, and Catboost. If you would like to see Tensorboard integrated into another model type, please open an issue on the Freqtrade GitHub</p> <p>Requirements</p> <p>Tensorboard logging requires the FreqAI torch installation/docker image.</p> <p>The easiest way to use tensorboard is to ensure <code>freqai.activate_tensorboard</code> is set to <code>True</code> (default setting) in your configuration file, run FreqAI, then open a separate shell and run:</p> <pre><code>cd freqtrade\ntensorboard --logdir user_data/models/unique-id\n</code></pre> <p>where <code>unique-id</code> is the <code>identifier</code> set in the <code>freqai</code> configuration file. This command must be run in a separate shell if you wish to view the output in your browser at 127.0.0.1:6060 (6060 is the default port used by Tensorboard).</p> <p></p> <p>Deactivate for improved performance</p> <p>Tensorboard logging can slow down training and should be deactivated for production use.</p>"},{"location":"freqai/","title":"Introduction","text":""},{"location":"freqai/#freqai","title":"FreqAI","text":""},{"location":"freqai/#introduction","title":"Introduction","text":"<p>FreqAI is a software designed to automate a variety of tasks associated with training a predictive machine learning model to generate market forecasts given a set of input signals. In general, FreqAI aims to be a sandbox for easily deploying robust machine learning libraries on real-time data (details).</p> <p>Note</p> <p>FreqAI is, and always will be, a not-for-profit, open-source project. FreqAI does not have a crypto token, FreqAI does not sell signals, and FreqAI does not have a domain besides the present freqtrade documentation.</p> <p>Features include:</p> <ul> <li>Self-adaptive retraining - Retrain models during live deployments to self-adapt to the market in a supervised manner</li> <li>Rapid feature engineering - Create large rich feature sets (10k+ features) based on simple user-created strategies</li> <li>High performance - Threading allows for adaptive model retraining on a separate thread (or on GPU if available) from model inferencing (prediction) and bot trade operations. Newest models and data are kept in RAM for rapid inferencing</li> <li>Realistic backtesting - Emulate self-adaptive training on historic data with a backtesting module that automates retraining</li> <li>Extensibility - The generalized and robust architecture allows for incorporating any machine learning library/method available in Python. Eight examples are currently available, including classifiers, regressors, and a convolutional neural network</li> <li>Smart outlier removal - Remove outliers from training and prediction data sets using a variety of outlier detection techniques</li> <li>Crash resilience - Store trained models to disk to make reloading from a crash fast and easy, and purge obsolete files for sustained dry/live runs</li> <li>Automatic data normalization - Normalize the data in a smart and statistically safe way</li> <li>Automatic data download - Compute timeranges for data downloads and update historic data (in live deployments)</li> <li>Cleaning of incoming data - Handle NaNs safely before training and model inferencing</li> <li>Dimensionality reduction - Reduce the size of the training data via Principal Component Analysis</li> <li>Deploying bot fleets - Set one bot to train models while a fleet of consumers use signals.</li> </ul>"},{"location":"freqai/#quick-start","title":"Quick start","text":"<p>The easiest way to quickly test FreqAI is to run it in dry mode with the following command:</p> <pre><code>freqtrade trade --config config_examples/config_freqai.example.json --strategy FreqaiExampleStrategy --freqaimodel LightGBMRegressor --strategy-path freqtrade/templates\n</code></pre> <p>You will see the boot-up process of automatic data downloading, followed by simultaneous training and trading. </p> <p>Not for production</p> <p>The example strategy provided with the Freqtrade source code is designed for showcasing/testing a wide variety of FreqAI features. It is also designed to run on small computers so that it can be used as a benchmark between developers and users. It is not designed to be run in production.</p> <p>An example strategy, prediction model, and config to use as a starting points can be found in <code>freqtrade/templates/FreqaiExampleStrategy.py</code>, <code>freqtrade/freqai/prediction_models/LightGBMRegressor.py</code>, and <code>config_examples/config_freqai.example.json</code>, respectively.</p>"},{"location":"freqai/#general-approach","title":"General approach","text":"<p>You provide FreqAI with a set of custom base indicators (the same way as in a typical Freqtrade strategy) as well as target values (labels). For each pair in the whitelist, FreqAI trains a model to predict the target values based on the input of custom indicators. The models are then consistently retrained, with a predetermined frequency, to adapt to market conditions. FreqAI offers the ability to both backtest strategies (emulating reality with periodic retraining on historic data) and deploy dry/live runs. In dry/live conditions, FreqAI can be set to constant retraining in a background thread to keep models as up to date as possible.</p> <p>An overview of the algorithm, explaining the data processing pipeline and model usage, is shown below.</p> <p></p>"},{"location":"freqai/#important-machine-learning-vocabulary","title":"Important machine learning vocabulary","text":"<p>Features - the parameters, based on historic data, on which a model is trained. All features for a single candle are stored as a vector. In FreqAI, you build a feature data set from anything you can construct in the strategy.</p> <p>Labels - the target values that the model is trained toward. Each feature vector is associated with a single label that is defined by you within the strategy. These labels intentionally look into the future and are what you are training the model to be able to predict.</p> <p>Training - the process of \"teaching\" the model to match the feature sets to the associated labels. Different types of models \"learn\" in different ways which means that one might be better than another for a specific application. More information about the different models that are already implemented in FreqAI can be found here.</p> <p>Train data - a subset of the feature data set that is fed to the model during training to \"teach\" the model how to predict the targets. This data directly influences weight connections in the model.</p> <p>Test data - a subset of the feature data set that is used to evaluate the performance of the model after training. This data does not influence nodal weights within the model.</p> <p>Inferencing - the process of feeding a trained model new unseen data on which it will make a prediction. </p>"},{"location":"freqai/#install-prerequisites","title":"Install prerequisites","text":"<p>The normal Freqtrade install process will ask if you wish to install FreqAI dependencies. You should reply \"yes\" to this question if you wish to use FreqAI. If you did not reply yes, you can manually install these dependencies after the install with:</p> <pre><code>pip install -r requirements-freqai.txt\n</code></pre> <p>Note</p> <p>Catboost will not be installed on low-powered arm devices (raspberry), since it does not provide wheels for this platform.</p>"},{"location":"freqai/#usage-with-docker","title":"Usage with docker","text":"<p>If you are using docker, a dedicated tag with FreqAI dependencies is available as <code>:freqai</code>. As such - you can replace the image line in your docker compose file with <code>image: freqtradeorg/freqtrade:develop_freqai</code>. This image contains the regular FreqAI dependencies. Similar to native installs, Catboost will not be available on ARM based devices. If you would like to use PyTorch or Reinforcement learning, you should use the torch or RL tags, <code>image: freqtradeorg/freqtrade:develop_freqaitorch</code>, <code>image: freqtradeorg/freqtrade:develop_freqairl</code>.</p> <p>docker-compose-freqai.yml</p> <p>We do provide an explicit docker-compose file for this in <code>docker/docker-compose-freqai.yml</code> - which can be used via <code>docker compose -f docker/docker-compose-freqai.yml run ...</code> - or can be copied to replace the original docker file. This docker-compose file also contains a (disabled) section to enable GPU resources within docker containers. This obviously assumes the system has GPU resources available.</p>"},{"location":"freqai/#freqai-position-in-open-source-machine-learning-landscape","title":"FreqAI position in open-source machine learning landscape","text":"<p>Forecasting chaotic time-series based systems, such as equity/cryptocurrency markets, requires a broad set of tools geared toward testing a wide range of hypotheses. Fortunately, a recent maturation of robust machine learning libraries (e.g. <code>scikit-learn</code>) has opened up a wide range of research possibilities. Scientists from a diverse range of fields can now easily prototype their studies on an abundance of established machine learning algorithms. Similarly, these user-friendly libraries enable \"citzen scientists\" to use their basic Python skills for data exploration. However, leveraging these machine learning libraries on historical and live chaotic data sources can be logistically difficult and expensive. Additionally, robust data collection, storage, and handling presents a disparate challenge. <code>FreqAI</code> aims to provide a generalized and extensible open-sourced framework geared toward live deployments of adaptive modeling for market forecasting. The <code>FreqAI</code> framework is effectively a sandbox for the rich world of open-source machine learning libraries. Inside the <code>FreqAI</code> sandbox, users find they can combine a wide variety of third-party libraries to test creative hypotheses on a free live 24/7 chaotic data source - cryptocurrency exchange data. </p>"},{"location":"freqai/#citing-freqai","title":"Citing FreqAI","text":"<p>FreqAI is published in the Journal of Open Source Software. If you find FreqAI useful in your research, please use the following citation:</p> <pre><code>@article{Caulk2022, \n    doi = {10.21105/joss.04864},\n    url = {https://doi.org/10.21105/joss.04864},\n    year = {2022}, publisher = {The Open Journal},\n    volume = {7}, number = {80}, pages = {4864},\n    author = {Robert A. Caulk and Elin T\u00f6rnquist and Matthias Voppichler and Andrew R. Lawless and Ryan McMullan and Wagner Costa Santos and Timothy C. Pogue and Johan van der Vlugt and Stefan P. Gehring and Pascal Schmidt},\n    title = {FreqAI: generalizing adaptive modeling for chaotic time-series market forecasts},\n    journal = {Journal of Open Source Software} } \n</code></pre>"},{"location":"freqai/#common-pitfalls","title":"Common pitfalls","text":"<p>FreqAI cannot be combined with dynamic <code>VolumePairlists</code> (or any pairlist filter that adds and removes pairs dynamically). This is for performance reasons - FreqAI relies on making quick predictions/retrains. To do this effectively, it needs to download all the training data at the beginning of a dry/live instance. FreqAI stores and appends new candles automatically for future retrains. This means that if new pairs arrive later in the dry run due to a volume pairlist, it will not have the data ready. However, FreqAI does work with the <code>ShufflePairlist</code> or a <code>VolumePairlist</code> which keeps the total pairlist constant (but reorders the pairs according to volume).</p>"},{"location":"freqai/#additional-learning-materials","title":"Additional learning materials","text":"<p>Here we compile some external materials that provide deeper looks into various components of FreqAI:</p> <ul> <li>Real-time head-to-head: Adaptive modeling of financial market data using XGBoost and CatBoost</li> <li>FreqAI - from price to prediction</li> </ul>"},{"location":"freqai/#support","title":"Support","text":"<p>You can find support for FreqAI in a variety of places, including the Freqtrade discord, the dedicated FreqAI discord, and in github issues.</p>"},{"location":"freqai/#credits","title":"Credits","text":"<p>FreqAI is developed by a group of individuals who all contribute specific skillsets to the project.</p> <p>Conception and software development: Robert Caulk @robcaulk</p> <p>Theoretical brainstorming and data analysis: Elin T\u00f6rnquist @th0rntwig</p> <p>Code review and software architecture brainstorming: @xmatthias</p> <p>Software development: Wagner Costa @wagnercosta Emre Suzen @aemr3 Timothy Pogue @wizrds</p> <p>Beta testing and bug reporting: Stefan Gehring @bloodhunter4rc, @longyu, Andrew Lawless @paranoidandy, Pascal Schmidt @smidelis, Ryan McMullan @smarmau, Juha Nyk\u00e4nen @suikula, Johan van der Vlugt @jooopiert, Rich\u00e1rd J\u00f3zsa @richardjosza</p>"},{"location":"hyperopt/","title":"Hyperopt","text":"<p>This page explains how to tune your strategy by finding the optimal parameters, a process called hyperparameter optimization. The bot uses algorithms included in the <code>scikit-optimize</code> package to accomplish this. The search will burn all your CPU cores, make your laptop sound like a fighter jet and still take a long time.</p> <p>In general, the search for best parameters starts with a few random combinations (see below for more details) and then uses Bayesian search with a ML regressor algorithm (currently ExtraTreesRegressor) to quickly find a combination of parameters in the search hyperspace that minimizes the value of the loss function.</p> <p>Hyperopt requires historic data to be available, just as backtesting does (hyperopt runs backtesting many times with different parameters). To learn how to get data for the pairs and exchange you're interested in, head over to the Data Downloading section of the documentation.</p> <p>Bug</p> <p>Hyperopt can crash when used with only 1 CPU Core as found out in Issue #1133</p> <p>Note</p> <p>Since 2021.4 release you no longer have to write a separate hyperopt class, but can configure the parameters directly in the strategy. The legacy method was supported up to 2021.8 and has been removed in 2021.9.</p>"},{"location":"hyperopt/#install-hyperopt-dependencies","title":"Install hyperopt dependencies","text":"<p>Since Hyperopt dependencies are not needed to run the bot itself, are heavy, can not be easily built on some platforms (like Raspberry PI), they are not installed by default. Before you run Hyperopt, you need to install the corresponding dependencies, as described in this section below.</p> <p>Note</p> <p>Since Hyperopt is a resource intensive process, running it on a Raspberry Pi is not recommended nor supported.</p>"},{"location":"hyperopt/#docker","title":"Docker","text":"<p>The docker-image includes hyperopt dependencies, no further action needed.</p>"},{"location":"hyperopt/#easy-installation-script-setupsh-manual-installation","title":"Easy installation script (setup.sh) / Manual installation","text":"<pre><code>source .venv/bin/activate\npip install -r requirements-hyperopt.txt\n</code></pre>"},{"location":"hyperopt/#hyperopt-command-reference","title":"Hyperopt command reference","text":"<pre><code>usage: freqtrade hyperopt [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH]\n                          [--userdir PATH] [-s NAME] [--strategy-path PATH]\n                          [--recursive-strategy-search] [--freqaimodel NAME]\n                          [--freqaimodel-path PATH] [-i TIMEFRAME]\n                          [--timerange TIMERANGE]\n                          [--data-format-ohlcv {json,jsongz,hdf5}]\n                          [--max-open-trades INT]\n                          [--stake-amount STAKE_AMOUNT] [--fee FLOAT]\n                          [-p PAIRS [PAIRS ...]] [--hyperopt-path PATH]\n                          [--eps] [--dmmp] [--enable-protections]\n                          [--dry-run-wallet DRY_RUN_WALLET]\n                          [--timeframe-detail TIMEFRAME_DETAIL] [-e INT]\n                          [--spaces {all,buy,sell,roi,stoploss,trailing,protection,trades,default} [{all,buy,sell,roi,stoploss,trailing,protection,trades,default} ...]]\n                          [--print-all] [--no-color] [--print-json] [-j JOBS]\n                          [--random-state INT] [--min-trades INT]\n                          [--hyperopt-loss NAME] [--disable-param-export]\n                          [--ignore-missing-spaces] [--analyze-per-epoch]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -i TIMEFRAME, --timeframe TIMEFRAME\n                        Specify timeframe (`1m`, `5m`, `30m`, `1h`, `1d`).\n  --timerange TIMERANGE\n                        Specify what timerange of data to use.\n  --data-format-ohlcv {json,jsongz,hdf5}\n                        Storage format for downloaded candle (OHLCV) data.\n                        (default: `json`).\n  --max-open-trades INT\n                        Override the value of the `max_open_trades`\n                        configuration setting.\n  --stake-amount STAKE_AMOUNT\n                        Override the value of the `stake_amount` configuration\n                        setting.\n  --fee FLOAT           Specify fee ratio. Will be applied twice (on trade\n                        entry and exit).\n  -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...]\n                        Limit command to these pairs. Pairs are space-\n                        separated.\n  --hyperopt-path PATH  Specify additional lookup path for Hyperopt Loss\n                        functions.\n  --eps, --enable-position-stacking\n                        Allow buying the same pair multiple times (position\n                        stacking).\n  --dmmp, --disable-max-market-positions\n                        Disable applying `max_open_trades` during backtest\n                        (same as setting `max_open_trades` to a very high\n                        number).\n  --enable-protections, --enableprotections\n                        Enable protections for backtesting.Will slow\n                        backtesting down by a considerable amount, but will\n                        include configured protections\n  --dry-run-wallet DRY_RUN_WALLET, --starting-balance DRY_RUN_WALLET\n                        Starting balance, used for backtesting / hyperopt and\n                        dry-runs.\n  --timeframe-detail TIMEFRAME_DETAIL\n                        Specify detail timeframe for backtesting (`1m`, `5m`,\n                        `30m`, `1h`, `1d`).\n  -e INT, --epochs INT  Specify number of epochs (default: 100).\n  --spaces {all,buy,sell,roi,stoploss,trailing,protection,trades,default} [{all,buy,sell,roi,stoploss,trailing,protection,trades,default} ...]\n                        Specify which parameters to hyperopt. Space-separated\n                        list.\n  --print-all           Print all results, not only the best ones.\n  --no-color            Disable colorization of hyperopt results. May be\n                        useful if you are redirecting output to a file.\n  --print-json          Print output in JSON format.\n  -j JOBS, --job-workers JOBS\n                        The number of concurrently running jobs for\n                        hyperoptimization (hyperopt worker processes). If -1\n                        (default), all CPUs are used, for -2, all CPUs but one\n                        are used, etc. If 1 is given, no parallel computing\n                        code is used at all.\n  --random-state INT    Set random state to some positive integer for\n                        reproducible hyperopt results.\n  --min-trades INT      Set minimal desired number of trades for evaluations\n                        in the hyperopt optimization path (default: 1).\n  --hyperopt-loss NAME, --hyperoptloss NAME\n                        Specify the class name of the hyperopt loss function\n                        class (IHyperOptLoss). Different functions can\n                        generate completely different results, since the\n                        target for optimization is different. Built-in\n                        Hyperopt-loss-functions are:\n                        ShortTradeDurHyperOptLoss, OnlyProfitHyperOptLoss,\n                        SharpeHyperOptLoss, SharpeHyperOptLossDaily,\n                        SortinoHyperOptLoss, SortinoHyperOptLossDaily,\n                        CalmarHyperOptLoss, MaxDrawDownHyperOptLoss,\n                        MaxDrawDownRelativeHyperOptLoss,\n                        ProfitDrawDownHyperOptLoss\n  --disable-param-export\n                        Disable automatic hyperopt parameter export.\n  --ignore-missing-spaces, --ignore-unparameterized-spaces\n                        Suppress errors for any requested Hyperopt spaces that\n                        do not contain any parameters.\n  --analyze-per-epoch   Run populate_indicators once per epoch.\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n\nStrategy arguments:\n  -s NAME, --strategy NAME\n                        Specify strategy class name which will be used by the\n                        bot.\n  --strategy-path PATH  Specify additional strategy lookup path.\n  --recursive-strategy-search\n                        Recursively search for a strategy in the strategies\n                        folder.\n  --freqaimodel NAME    Specify a custom freqaimodels.\n  --freqaimodel-path PATH\n                        Specify additional lookup path for freqaimodels.\n</code></pre>"},{"location":"hyperopt/#hyperopt-checklist","title":"Hyperopt checklist","text":"<p>Checklist on all tasks / possibilities in hyperopt</p> <p>Depending on the space you want to optimize, only some of the below are required:</p> <ul> <li>define parameters with <code>space='buy'</code> - for entry signal optimization</li> <li>define parameters with <code>space='sell'</code> - for exit signal optimization</li> </ul> <p>Note</p> <p><code>populate_indicators</code> needs to create all indicators any of the spaces may use, otherwise hyperopt will not work.</p> <p>Rarely you may also need to create a nested class named <code>HyperOpt</code> and implement</p> <ul> <li><code>roi_space</code> - for custom ROI optimization (if you need the ranges for the ROI parameters in the optimization hyperspace that differ from default)</li> <li><code>generate_roi_table</code> - for custom ROI optimization (if you need the ranges for the values in the ROI table that differ from default or the number of entries (steps) in the ROI table which differs from the default 4 steps)</li> <li><code>stoploss_space</code> - for custom stoploss optimization (if you need the range for the stoploss parameter in the optimization hyperspace that differs from default)</li> <li><code>trailing_space</code> - for custom trailing stop optimization (if you need the ranges for the trailing stop parameters in the optimization hyperspace that differ from default)</li> <li><code>max_open_trades_space</code> - for custom max_open_trades optimization (if you need the ranges for the max_open_trades parameter in the optimization hyperspace that differ from default)</li> </ul> <p>Quickly optimize ROI, stoploss and trailing stoploss</p> <p>You can quickly optimize the spaces <code>roi</code>, <code>stoploss</code> and <code>trailing</code> without changing anything in your strategy.</p> <pre><code># Have a working strategy at hand.\nfreqtrade hyperopt --hyperopt-loss SharpeHyperOptLossDaily --spaces roi stoploss trailing --strategy MyWorkingStrategy --config config.json -e 100\n</code></pre>"},{"location":"hyperopt/#hyperopt-execution-logic","title":"Hyperopt execution logic","text":"<p>Hyperopt will first load your data into memory and will then run <code>populate_indicators()</code> once per Pair to generate all indicators, unless <code>--analyze-per-epoch</code> is specified.</p> <p>Hyperopt will then spawn into different processes (number of processors, or <code>-j &lt;n&gt;</code>), and run backtesting over and over again, changing the parameters that are part of the <code>--spaces</code> defined.</p> <p>For every new set of parameters, freqtrade will run first <code>populate_entry_trend()</code> followed by <code>populate_exit_trend()</code>, and then run the regular backtesting process to simulate trades.</p> <p>After backtesting, the results are passed into the loss function, which will evaluate if this result was better or worse than previous results. Based on the loss function result, hyperopt will determine the next set of parameters to try in the next round of backtesting.</p>"},{"location":"hyperopt/#configure-your-guards-and-triggers","title":"Configure your Guards and Triggers","text":"<p>There are two places you need to change in your strategy file to add a new buy hyperopt for testing:</p> <ul> <li>Define the parameters at the class level hyperopt shall be optimizing.</li> <li>Within <code>populate_entry_trend()</code> - use defined parameter values instead of raw constants.</li> </ul> <p>There you have two different types of indicators: 1. <code>guards</code> and 2. <code>triggers</code>.</p> <ol> <li>Guards are conditions like \"never buy if ADX &lt; 10\", or never buy if current price is over EMA10.</li> <li>Triggers are ones that actually trigger buy in specific moment, like \"buy when EMA5 crosses over EMA10\" or \"buy when close price touches lower Bollinger band\".</li> </ol> <p>Guards and Triggers</p> <p>Technically, there is no difference between Guards and Triggers. However, this guide will make this distinction to make it clear that signals should not be \"sticking\". Sticking signals are signals that are active for multiple candles. This can lead into entering a signal late (right before the signal disappears - which means that the chance of success is a lot lower than right at the beginning).</p> <p>Hyper-optimization will, for each epoch round, pick one trigger and possibly multiple guards.</p>"},{"location":"hyperopt/#exit-signal-optimization","title":"Exit signal optimization","text":"<p>Similar to the entry-signal above, exit-signals can also be optimized. Place the corresponding settings into the following methods</p> <ul> <li>Define the parameters at the class level hyperopt shall be optimizing, either naming them <code>sell_*</code>, or by explicitly defining <code>space='sell'</code>.</li> <li>Within <code>populate_exit_trend()</code> - use defined parameter values instead of raw constants.</li> </ul> <p>The configuration and rules are the same than for buy signals.</p>"},{"location":"hyperopt/#solving-a-mystery","title":"Solving a Mystery","text":"<p>Let's say you are curious: should you use MACD crossings or lower Bollinger Bands to trigger your long entries. And you also wonder should you use RSI or ADX to help with those decisions. If you decide to use RSI or ADX, which values should I use for them?</p> <p>So let's use hyperparameter optimization to solve this mystery.</p>"},{"location":"hyperopt/#defining-indicators-to-be-used","title":"Defining indicators to be used","text":"<p>We start by calculating the indicators our strategy is going to use.</p> <pre><code>class MyAwesomeStrategy(IStrategy):\n\n    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        \"\"\"\n        Generate all indicators used by the strategy\n        \"\"\"\n        dataframe['adx'] = ta.ADX(dataframe)\n        dataframe['rsi'] = ta.RSI(dataframe)\n        macd = ta.MACD(dataframe)\n        dataframe['macd'] = macd['macd']\n        dataframe['macdsignal'] = macd['macdsignal']\n        dataframe['macdhist'] = macd['macdhist']\n\n        bollinger = ta.BBANDS(dataframe, timeperiod=20, nbdevup=2.0, nbdevdn=2.0)\n        dataframe['bb_lowerband'] = bollinger['lowerband']\n        dataframe['bb_middleband'] = bollinger['middleband']\n        dataframe['bb_upperband'] = bollinger['upperband']\n        return dataframe\n</code></pre>"},{"location":"hyperopt/#hyperoptable-parameters","title":"Hyperoptable parameters","text":"<p>We continue to define hyperoptable parameters:</p> <pre><code>class MyAwesomeStrategy(IStrategy):\n    buy_adx = DecimalParameter(20, 40, decimals=1, default=30.1, space=\"buy\")\n    buy_rsi = IntParameter(20, 40, default=30, space=\"buy\")\n    buy_adx_enabled = BooleanParameter(default=True, space=\"buy\")\n    buy_rsi_enabled = CategoricalParameter([True, False], default=False, space=\"buy\")\n    buy_trigger = CategoricalParameter([\"bb_lower\", \"macd_cross_signal\"], default=\"bb_lower\", space=\"buy\")\n</code></pre> <p>The above definition says: I have five parameters I want to randomly combine to find the best combination. <code>buy_rsi</code> is an integer parameter, which will be tested between 20 and 40. This space has a size of 20. <code>buy_adx</code> is a decimal parameter, which will be evaluated between 20 and 40 with 1 decimal place (so values are 20.1, 20.2, ...). This space has a size of 200. Then we have three category variables. First two are either <code>True</code> or <code>False</code>. We use these to either enable or disable the ADX and RSI guards. The last one we call <code>trigger</code> and use it to decide which buy trigger we want to use.</p> <p>Parameter space assignment</p> <p>Parameters must either be assigned to a variable named <code>buy_*</code> or <code>sell_*</code> - or contain <code>space='buy'</code> | <code>space='sell'</code> to be assigned to a space correctly. If no parameter is available for a space, you'll receive the error that no space was found when running hyperopt. Parameters with unclear space (e.g. <code>adx_period = IntParameter(4, 24, default=14)</code> - no explicit nor implicit space) will not be detected and will therefore be ignored.</p> <p>So let's write the buy strategy using these values:</p> <pre><code>    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        conditions = []\n        # GUARDS AND TRENDS\n        if self.buy_adx_enabled.value:\n            conditions.append(dataframe['adx'] &gt; self.buy_adx.value)\n        if self.buy_rsi_enabled.value:\n            conditions.append(dataframe['rsi'] &lt; self.buy_rsi.value)\n\n        # TRIGGERS\n        if self.buy_trigger.value == 'bb_lower':\n            conditions.append(dataframe['close'] &lt; dataframe['bb_lowerband'])\n        if self.buy_trigger.value == 'macd_cross_signal':\n            conditions.append(qtpylib.crossed_above(\n                dataframe['macd'], dataframe['macdsignal']\n            ))\n\n        # Check that volume is not 0\n        conditions.append(dataframe['volume'] &gt; 0)\n\n        if conditions:\n            dataframe.loc[\n                reduce(lambda x, y: x &amp; y, conditions),\n                'enter_long'] = 1\n\n        return dataframe\n</code></pre> <p>Hyperopt will now call <code>populate_entry_trend()</code> many times (<code>epochs</code>) with different value combinations. It will use the given historical data and simulate buys based on the buy signals generated with the above function. Based on the results, hyperopt will tell you which parameter combination produced the best results (based on the configured loss function).</p> <p>Note</p> <p>The above setup expects to find ADX, RSI and Bollinger Bands in the populated indicators. When you want to test an indicator that isn't used by the bot currently, remember to add it to the <code>populate_indicators()</code> method in your strategy or hyperopt file.</p>"},{"location":"hyperopt/#parameter-types","title":"Parameter types","text":"<p>There are four parameter types each suited for different purposes.</p> <ul> <li><code>IntParameter</code> - defines an integral parameter with upper and lower boundaries of search space.</li> <li><code>DecimalParameter</code> - defines a floating point parameter with a limited number of decimals (default 3). Should be preferred instead of <code>RealParameter</code> in most cases.</li> <li><code>RealParameter</code> - defines a floating point parameter with upper and lower boundaries and no precision limit. Rarely used as it creates a space with a near infinite number of possibilities.</li> <li><code>CategoricalParameter</code> - defines a parameter with a predetermined number of choices.</li> <li><code>BooleanParameter</code> - Shorthand for <code>CategoricalParameter([True, False])</code> - great for \"enable\" parameters.</li> </ul>"},{"location":"hyperopt/#parameter-options","title":"Parameter options","text":"<p>There are two parameter options that can help you to quickly test various ideas:</p> <ul> <li><code>optimize</code> - when set to <code>False</code>, the parameter will not be included in optimization process. (Default: True)</li> <li><code>load</code> - when set to <code>False</code>, results of a previous hyperopt run (in <code>buy_params</code> and <code>sell_params</code> either in your strategy or the JSON output file) will not be used as the starting value for subsequent hyperopts. The default value specified in the parameter will be used instead. (Default: True)</li> </ul> <p>Effects of <code>load=False</code> on backtesting</p> <p>Be aware that setting the <code>load</code> option to <code>False</code> will mean backtesting will also use the default value specified in the parameter and not the value found through hyperoptimisation.</p> <p>Warning</p> <p>Hyperoptable parameters cannot be used in <code>populate_indicators</code> - as hyperopt does not recalculate indicators for each epoch, so the starting value would be used in this case.</p>"},{"location":"hyperopt/#optimizing-an-indicator-parameter","title":"Optimizing an indicator parameter","text":"<p>Assuming you have a simple strategy in mind - a EMA cross strategy (2 Moving averages crossing) - and you'd like to find the ideal parameters for this strategy. By default, we assume a stoploss of 5% - and a take-profit (<code>minimal_roi</code>) of 10% - which means freqtrade will sell the trade once 10% profit has been reached.</p> <pre><code>from pandas import DataFrame\nfrom functools import reduce\n\nimport talib.abstract as ta\n\nfrom freqtrade.strategy import (BooleanParameter, CategoricalParameter, DecimalParameter, \n                                IStrategy, IntParameter)\nimport freqtrade.vendor.qtpylib.indicators as qtpylib\n\nclass MyAwesomeStrategy(IStrategy):\n    stoploss = -0.05\n    timeframe = '15m'\n    minimal_roi = {\n        \"0\":  0.10\n    }\n    # Define the parameter spaces\n    buy_ema_short = IntParameter(3, 50, default=5)\n    buy_ema_long = IntParameter(15, 200, default=50)\n\n\n    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        \"\"\"Generate all indicators used by the strategy\"\"\"\n\n        # Calculate all ema_short values\n        for val in self.buy_ema_short.range:\n            dataframe[f'ema_short_{val}'] = ta.EMA(dataframe, timeperiod=val)\n\n        # Calculate all ema_long values\n        for val in self.buy_ema_long.range:\n            dataframe[f'ema_long_{val}'] = ta.EMA(dataframe, timeperiod=val)\n\n        return dataframe\n\n    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        conditions = []\n        conditions.append(qtpylib.crossed_above(\n                dataframe[f'ema_short_{self.buy_ema_short.value}'], dataframe[f'ema_long_{self.buy_ema_long.value}']\n            ))\n\n        # Check that volume is not 0\n        conditions.append(dataframe['volume'] &gt; 0)\n\n        if conditions:\n            dataframe.loc[\n                reduce(lambda x, y: x &amp; y, conditions),\n                'enter_long'] = 1\n        return dataframe\n\n    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        conditions = []\n        conditions.append(qtpylib.crossed_above(\n                dataframe[f'ema_long_{self.buy_ema_long.value}'], dataframe[f'ema_short_{self.buy_ema_short.value}']\n            ))\n\n        # Check that volume is not 0\n        conditions.append(dataframe['volume'] &gt; 0)\n\n        if conditions:\n            dataframe.loc[\n                reduce(lambda x, y: x &amp; y, conditions),\n                'exit_long'] = 1\n        return dataframe\n</code></pre> <p>Breaking it down:</p> <p>Using <code>self.buy_ema_short.range</code> will return a range object containing all entries between the Parameters low and high value. In this case (<code>IntParameter(3, 50, default=5)</code>), the loop would run for all numbers between 3 and 50 (<code>[3, 4, 5, ... 49, 50]</code>). By using this in a loop, hyperopt will generate 48 new columns (<code>['buy_ema_3', 'buy_ema_4', ... , 'buy_ema_50']</code>).</p> <p>Hyperopt itself will then use the selected value to create the buy and sell signals.</p> <p>While this strategy is most likely too simple to provide consistent profit, it should serve as an example how optimize indicator parameters.</p> <p>Note</p> <p><code>self.buy_ema_short.range</code> will act differently between hyperopt and other modes. For hyperopt, the above example may generate 48 new columns, however for all other modes (backtesting, dry/live), it will only generate the column for the selected value. You should therefore avoid using the resulting column with explicit values (values other than <code>self.buy_ema_short.value</code>).</p> <p>Note</p> <p><code>range</code> property may also be used with <code>DecimalParameter</code> and <code>CategoricalParameter</code>. <code>RealParameter</code> does not provide this property due to infinite search space.</p> Performance tip <p>During normal hyperopting, indicators are calculated once and supplied to each epoch, linearly increasing RAM usage as a factor of increasing cores. As this also has performance implications, there are two alternatives to reduce RAM usage</p> <ul> <li>Move <code>ema_short</code> and <code>ema_long</code> calculations from <code>populate_indicators()</code> to <code>populate_entry_trend()</code>. Since <code>populate_entry_trend()</code> will be calculated every epoch, you don't need to use <code>.range</code> functionality.</li> <li>hyperopt provides <code>--analyze-per-epoch</code> which will move the execution of <code>populate_indicators()</code> to the epoch process, calculating a single value per parameter per epoch instead of using the <code>.range</code> functionality. In this case, <code>.range</code> functionality will only return the actually used value.</li> </ul> <p>These alternatives will reduce RAM usage, but increase CPU usage. However, your hyperopting run will be less likely to fail due to Out Of Memory (OOM) issues.</p> <p>Whether you are using <code>.range</code> functionality or the alternatives above, you should try to use space ranges as small as possible since this will improve CPU/RAM usage.</p>"},{"location":"hyperopt/#optimizing-protections","title":"Optimizing protections","text":"<p>Freqtrade can also optimize protections. How you optimize protections is up to you, and the following should be considered as example only.</p> <p>The strategy will simply need to define the \"protections\" entry as property returning a list of protection configurations.</p> <pre><code>from pandas import DataFrame\nfrom functools import reduce\n\nimport talib.abstract as ta\n\nfrom freqtrade.strategy import (BooleanParameter, CategoricalParameter, DecimalParameter, \n                                IStrategy, IntParameter)\nimport freqtrade.vendor.qtpylib.indicators as qtpylib\n\nclass MyAwesomeStrategy(IStrategy):\n    stoploss = -0.05\n    timeframe = '15m'\n    # Define the parameter spaces\n    cooldown_lookback = IntParameter(2, 48, default=5, space=\"protection\", optimize=True)\n    stop_duration = IntParameter(12, 200, default=5, space=\"protection\", optimize=True)\n    use_stop_protection = BooleanParameter(default=True, space=\"protection\", optimize=True)\n\n\n    @property\n    def protections(self):\n        prot = []\n\n        prot.append({\n            \"method\": \"CooldownPeriod\",\n            \"stop_duration_candles\": self.cooldown_lookback.value\n        })\n        if self.use_stop_protection.value:\n            prot.append({\n                \"method\": \"StoplossGuard\",\n                \"lookback_period_candles\": 24 * 3,\n                \"trade_limit\": 4,\n                \"stop_duration_candles\": self.stop_duration.value,\n                \"only_per_pair\": False\n            })\n\n        return prot\n\n    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        # ...\n</code></pre> <p>You can then run hyperopt as follows: <code>freqtrade hyperopt --hyperopt-loss SharpeHyperOptLossDaily --strategy MyAwesomeStrategy --spaces protection</code></p> <p>Note</p> <p>The protection space is not part of the default space, and is only available with the Parameters Hyperopt interface, not with the legacy hyperopt interface (which required separate hyperopt files). Freqtrade will also automatically change the \"--enable-protections\" flag if the protection space is selected.</p> <p>Warning</p> <p>If protections are defined as property, entries from the configuration will be ignored. It is therefore recommended to not define protections in the configuration.</p>"},{"location":"hyperopt/#migrating-from-previous-property-setups","title":"Migrating from previous property setups","text":"<p>A migration from a previous setup is pretty simple, and can be accomplished by converting the protections entry to a property. In simple terms, the following configuration will be converted to the below.</p> <pre><code>class MyAwesomeStrategy(IStrategy):\n    protections = [\n        {\n            \"method\": \"CooldownPeriod\",\n            \"stop_duration_candles\": 4\n        }\n    ]\n</code></pre> <p>Result</p> <pre><code>class MyAwesomeStrategy(IStrategy):\n\n    @property\n    def protections(self):\n        return [\n            {\n                \"method\": \"CooldownPeriod\",\n                \"stop_duration_candles\": 4\n            }\n        ]\n</code></pre> <p>You will then obviously also change potential interesting entries to parameters to allow hyper-optimization.</p>"},{"location":"hyperopt/#optimizing-max_entry_position_adjustment","title":"Optimizing <code>max_entry_position_adjustment</code>","text":"<p>While <code>max_entry_position_adjustment</code> is not a separate space, it can still be used in hyperopt by using the property approach shown above.</p> <pre><code>from pandas import DataFrame\nfrom functools import reduce\n\nimport talib.abstract as ta\n\nfrom freqtrade.strategy import (BooleanParameter, CategoricalParameter, DecimalParameter, \n                                IStrategy, IntParameter)\nimport freqtrade.vendor.qtpylib.indicators as qtpylib\n\nclass MyAwesomeStrategy(IStrategy):\n    stoploss = -0.05\n    timeframe = '15m'\n\n    # Define the parameter spaces\n    max_epa = CategoricalParameter([-1, 0, 1, 3, 5, 10], default=1, space=\"buy\", optimize=True)\n\n    @property\n    def max_entry_position_adjustment(self):\n        return self.max_epa.value\n\n\n    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        # ...\n</code></pre> Using <code>IntParameter</code> <p>You can also use the <code>IntParameter</code> for this optimization, but you must explicitly return an integer: <pre><code>max_epa = IntParameter(-1, 10, default=1, space=\"buy\", optimize=True)\n\n@property\ndef max_entry_position_adjustment(self):\n    return int(self.max_epa.value)\n</code></pre></p>"},{"location":"hyperopt/#loss-functions","title":"Loss-functions","text":"<p>Each hyperparameter tuning requires a target. This is usually defined as a loss function (sometimes also called objective function), which should decrease for more desirable results, and increase for bad results.</p> <p>A loss function must be specified via the <code>--hyperopt-loss &lt;Class-name&gt;</code> argument (or optionally via the configuration under the <code>\"hyperopt_loss\"</code> key). This class should be in its own file within the <code>user_data/hyperopts/</code> directory.</p> <p>Currently, the following loss functions are builtin:</p> <ul> <li><code>ShortTradeDurHyperOptLoss</code> - (default legacy Freqtrade hyperoptimization loss function) - Mostly for short trade duration and avoiding losses.</li> <li><code>OnlyProfitHyperOptLoss</code> - takes only amount of profit into consideration.</li> <li><code>SharpeHyperOptLoss</code> - optimizes Sharpe Ratio calculated on trade returns relative to standard deviation.</li> <li><code>SharpeHyperOptLossDaily</code> - optimizes Sharpe Ratio calculated on daily trade returns relative to standard deviation.</li> <li><code>SortinoHyperOptLoss</code> - optimizes Sortino Ratio calculated on trade returns relative to downside standard deviation.</li> <li><code>SortinoHyperOptLossDaily</code> - optimizes Sortino Ratio calculated on daily trade returns relative to downside standard deviation.</li> <li><code>MaxDrawDownHyperOptLoss</code> - Optimizes Maximum absolute drawdown.</li> <li><code>MaxDrawDownRelativeHyperOptLoss</code> -  Optimizes both maximum absolute drawdown while also adjusting for maximum relative drawdown.</li> <li><code>CalmarHyperOptLoss</code> - Optimizes Calmar Ratio calculated on trade returns relative to max drawdown.</li> <li><code>ProfitDrawDownHyperOptLoss</code> - Optimizes by max Profit &amp; min Drawdown objective. <code>DRAWDOWN_MULT</code> variable within the hyperoptloss file can be adjusted to be stricter or more flexible on drawdown purposes.</li> </ul> <p>Creation of a custom loss function is covered in the Advanced Hyperopt part of the documentation.</p>"},{"location":"hyperopt/#execute-hyperopt","title":"Execute Hyperopt","text":"<p>Once you have updated your hyperopt configuration you can run it. Because hyperopt tries a lot of combinations to find the best parameters it will take time to get a good result.</p> <p>We strongly recommend to use <code>screen</code> or <code>tmux</code> to prevent any connection loss.</p> <pre><code>freqtrade hyperopt --config config.json --hyperopt-loss &lt;hyperoptlossname&gt; --strategy &lt;strategyname&gt; -e 500 --spaces all\n</code></pre> <p>The <code>-e</code> option will set how many evaluations hyperopt will do. Since hyperopt uses Bayesian search, running too many epochs at once may not produce greater results. Experience has shown that best results are usually not improving much after 500-1000 epochs. Doing multiple runs (executions) with a few 1000 epochs and different random state will most likely produce different results.</p> <p>The <code>--spaces all</code> option determines that all possible parameters should be optimized. Possibilities are listed below.</p> <p>Note</p> <p>Hyperopt will store hyperopt results with the timestamp of the hyperopt start time. Reading commands (<code>hyperopt-list</code>, <code>hyperopt-show</code>) can use <code>--hyperopt-filename &lt;filename&gt;</code> to read and display older hyperopt results. You can find a list of filenames with <code>ls -l user_data/hyperopt_results/</code>.</p>"},{"location":"hyperopt/#execute-hyperopt-with-different-historical-data-source","title":"Execute Hyperopt with different historical data source","text":"<p>If you would like to hyperopt parameters using an alternate historical data set that you have on-disk, use the <code>--datadir PATH</code> option. By default, hyperopt uses data from directory <code>user_data/data</code>.</p>"},{"location":"hyperopt/#running-hyperopt-with-a-smaller-test-set","title":"Running Hyperopt with a smaller test-set","text":"<p>Use the <code>--timerange</code> argument to change how much of the test-set you want to use. For example, to use one month of data, pass <code>--timerange 20210101-20210201</code> (from january 2021 - february 2021) to the hyperopt call.</p> <p>Full command:</p> <pre><code>freqtrade hyperopt --strategy &lt;strategyname&gt; --timerange 20210101-20210201\n</code></pre>"},{"location":"hyperopt/#running-hyperopt-with-smaller-search-space","title":"Running Hyperopt with Smaller Search Space","text":"<p>Use the <code>--spaces</code> option to limit the search space used by hyperopt. Letting Hyperopt optimize everything is a huuuuge search space. Often it might make more sense to start by just searching for initial buy algorithm. Or maybe you just want to optimize your stoploss or roi table for that awesome new buy strategy you have.</p> <p>Legal values are:</p> <ul> <li><code>all</code>: optimize everything</li> <li><code>buy</code>: just search for a new buy strategy</li> <li><code>sell</code>: just search for a new sell strategy</li> <li><code>roi</code>: just optimize the minimal profit table for your strategy</li> <li><code>stoploss</code>: search for the best stoploss value</li> <li><code>trailing</code>: search for the best trailing stop values</li> <li><code>trades</code>: search for the best max open trades values</li> <li><code>protection</code>: search for the best protection parameters (read the protections section on how to properly define these)</li> <li><code>default</code>: <code>all</code> except <code>trailing</code> and <code>protection</code></li> <li>space-separated list of any of the above values for example <code>--spaces roi stoploss</code></li> </ul> <p>The default Hyperopt Search Space, used when no <code>--space</code> command line option is specified, does not include the <code>trailing</code> hyperspace. We recommend you to run optimization for the <code>trailing</code> hyperspace separately, when the best parameters for other hyperspaces were found, validated and pasted into your custom strategy.</p>"},{"location":"hyperopt/#understand-the-hyperopt-result","title":"Understand the Hyperopt Result","text":"<p>Once Hyperopt is completed you can use the result to update your strategy. Given the following result from hyperopt:</p> <pre><code>Best result:\n\n    44/100:    135 trades. Avg profit  0.57%. Total profit  0.03871918 BTC (0.7722%). Avg duration 180.4 mins. Objective: 1.94367\n\n    # Buy hyperspace params:\n    buy_params = {\n        'buy_adx': 44,\n        'buy_rsi': 29,\n        'buy_adx_enabled': False,\n        'buy_rsi_enabled': True,\n        'buy_trigger': 'bb_lower'\n    }\n</code></pre> <p>You should understand this result like:</p> <ul> <li>The buy trigger that worked best was <code>bb_lower</code>.</li> <li>You should not use ADX because <code>'buy_adx_enabled': False</code>.</li> <li>You should consider using the RSI indicator (<code>'buy_rsi_enabled': True</code>) and the best value is <code>29.0</code> (<code>'buy_rsi': 29.0</code>)</li> </ul>"},{"location":"hyperopt/#automatic-parameter-application-to-the-strategy","title":"Automatic parameter application to the strategy","text":"<p>When using Hyperoptable parameters, the result of your hyperopt-run will be written to a json file next to your strategy (so for <code>MyAwesomeStrategy.py</code>, the file would be <code>MyAwesomeStrategy.json</code>). This file is also updated when using the <code>hyperopt-show</code> sub-command, unless <code>--disable-param-export</code> is provided to either of the 2 commands.</p> <p>Your strategy class can also contain these results explicitly. Simply copy hyperopt results block and paste them at class level, replacing old parameters (if any). New parameters will automatically be loaded next time strategy is executed.</p> <p>Transferring your whole hyperopt result to your strategy would then look like:</p> <pre><code>class MyAwesomeStrategy(IStrategy):\n    # Buy hyperspace params:\n    buy_params = {\n        'buy_adx': 44,\n        'buy_rsi': 29,\n        'buy_adx_enabled': False,\n        'buy_rsi_enabled': True,\n        'buy_trigger': 'bb_lower'\n    }\n</code></pre> <p>Note</p> <p>Values in the configuration file will overwrite Parameter-file level parameters - and both will overwrite parameters within the strategy. The prevalence is therefore: config &gt; parameter file &gt; strategy <code>*_params</code> &gt; parameter default</p>"},{"location":"hyperopt/#understand-hyperopt-roi-results","title":"Understand Hyperopt ROI results","text":"<p>If you are optimizing ROI (i.e. if optimization search-space contains 'all', 'default' or 'roi'), your result will look as follows and include a ROI table:</p> <pre><code>Best result:\n\n    44/100:    135 trades. Avg profit  0.57%. Total profit  0.03871918 BTC (0.7722%). Avg duration 180.4 mins. Objective: 1.94367\n\n    # ROI table:\n    minimal_roi = {\n        0: 0.10674,\n        21: 0.09158,\n        78: 0.03634,\n        118: 0\n    }\n</code></pre> <p>In order to use this best ROI table found by Hyperopt in backtesting and for live trades/dry-run, copy-paste it as the value of the <code>minimal_roi</code> attribute of your custom strategy:</p> <pre><code>    # Minimal ROI designed for the strategy.\n    # This attribute will be overridden if the config file contains \"minimal_roi\"\n    minimal_roi = {\n        0: 0.10674,\n        21: 0.09158,\n        78: 0.03634,\n        118: 0\n    }\n</code></pre> <p>As stated in the comment, you can also use it as the value of the <code>minimal_roi</code> setting in the configuration file.</p>"},{"location":"hyperopt/#default-roi-search-space","title":"Default ROI Search Space","text":"<p>If you are optimizing ROI, Freqtrade creates the 'roi' optimization hyperspace for you -- it's the hyperspace of components for the ROI tables. By default, each ROI table generated by the Freqtrade consists of 4 rows (steps). Hyperopt implements adaptive ranges for ROI tables with ranges for values in the ROI steps that depend on the timeframe used. By default the values vary in the following ranges (for some of the most used timeframes, values are rounded to 3 digits after the decimal point):</p> # step 1m 5m 1h 1d 1 0 0.011...0.119 0 0.03...0.31 0 0.068...0.711 0 0.121...1.258 2 2...8 0.007...0.042 10...40 0.02...0.11 120...480 0.045...0.252 2880...11520 0.081...0.446 3 4...20 0.003...0.015 20...100 0.01...0.04 240...1200 0.022...0.091 5760...28800 0.040...0.162 4 6...44 0.0 30...220 0.0 360...2640 0.0 8640...63360 0.0 <p>These ranges should be sufficient in most cases. The minutes in the steps (ROI dict keys) are scaled linearly depending on the timeframe used. The ROI values in the steps (ROI dict values) are scaled logarithmically depending on the timeframe used.</p> <p>If you have the <code>generate_roi_table()</code> and <code>roi_space()</code> methods in your custom hyperopt, remove them in order to utilize these adaptive ROI tables and the ROI hyperoptimization space generated by Freqtrade by default.</p> <p>Override the <code>roi_space()</code> method if you need components of the ROI tables to vary in other ranges. Override the <code>generate_roi_table()</code> and <code>roi_space()</code> methods and implement your own custom approach for generation of the ROI tables during hyperoptimization if you need a different structure of the ROI tables or other amount of rows (steps).</p> <p>A sample for these methods can be found in the overriding pre-defined spaces section.</p> <p>Reduced search space</p> <p>To limit the search space further, Decimals are limited to 3 decimal places (a precision of 0.001). This is usually sufficient, every value more precise than this will usually result in overfitted results. You can however overriding pre-defined spaces to change this to your needs.</p>"},{"location":"hyperopt/#understand-hyperopt-stoploss-results","title":"Understand Hyperopt Stoploss results","text":"<p>If you are optimizing stoploss values (i.e. if optimization search-space contains 'all', 'default' or 'stoploss'), your result will look as follows and include stoploss:</p> <pre><code>Best result:\n\n    44/100:    135 trades. Avg profit  0.57%. Total profit  0.03871918 BTC (0.7722%). Avg duration 180.4 mins. Objective: 1.94367\n\n    # Buy hyperspace params:\n    buy_params = {\n        'buy_adx': 44,\n        'buy_rsi': 29,\n        'buy_adx_enabled': False,\n        'buy_rsi_enabled': True,\n        'buy_trigger': 'bb_lower'\n    }\n\n    stoploss: -0.27996\n</code></pre> <p>In order to use this best stoploss value found by Hyperopt in backtesting and for live trades/dry-run, copy-paste it as the value of the <code>stoploss</code> attribute of your custom strategy:</p> <pre><code>    # Optimal stoploss designed for the strategy\n    # This attribute will be overridden if the config file contains \"stoploss\"\n    stoploss = -0.27996\n</code></pre> <p>As stated in the comment, you can also use it as the value of the <code>stoploss</code> setting in the configuration file.</p>"},{"location":"hyperopt/#default-stoploss-search-space","title":"Default Stoploss Search Space","text":"<p>If you are optimizing stoploss values, Freqtrade creates the 'stoploss' optimization hyperspace for you. By default, the stoploss values in that hyperspace vary in the range -0.35...-0.02, which is sufficient in most cases.</p> <p>If you have the <code>stoploss_space()</code> method in your custom hyperopt file, remove it in order to utilize Stoploss hyperoptimization space generated by Freqtrade by default.</p> <p>Override the <code>stoploss_space()</code> method and define the desired range in it if you need stoploss values to vary in other range during hyperoptimization. A sample for this method can be found in the overriding pre-defined spaces section.</p> <p>Reduced search space</p> <p>To limit the search space further, Decimals are limited to 3 decimal places (a precision of 0.001). This is usually sufficient, every value more precise than this will usually result in overfitted results. You can however overriding pre-defined spaces to change this to your needs.</p>"},{"location":"hyperopt/#understand-hyperopt-trailing-stop-results","title":"Understand Hyperopt Trailing Stop results","text":"<p>If you are optimizing trailing stop values (i.e. if optimization search-space contains 'all' or 'trailing'), your result will look as follows and include trailing stop parameters:</p> <pre><code>Best result:\n\n    45/100:    606 trades. Avg profit  1.04%. Total profit  0.31555614 BTC ( 630.48%). Avg duration 150.3 mins. Objective: -1.10161\n\n    # Trailing stop:\n    trailing_stop = True\n    trailing_stop_positive = 0.02001\n    trailing_stop_positive_offset = 0.06038\n    trailing_only_offset_is_reached = True\n</code></pre> <p>In order to use these best trailing stop parameters found by Hyperopt in backtesting and for live trades/dry-run, copy-paste them as the values of the corresponding attributes of your custom strategy:</p> <pre><code>    # Trailing stop\n    # These attributes will be overridden if the config file contains corresponding values.\n    trailing_stop = True\n    trailing_stop_positive = 0.02001\n    trailing_stop_positive_offset = 0.06038\n    trailing_only_offset_is_reached = True\n</code></pre> <p>As stated in the comment, you can also use it as the values of the corresponding settings in the configuration file.</p>"},{"location":"hyperopt/#default-trailing-stop-search-space","title":"Default Trailing Stop Search Space","text":"<p>If you are optimizing trailing stop values, Freqtrade creates the 'trailing' optimization hyperspace for you. By default, the <code>trailing_stop</code> parameter is always set to True in that hyperspace, the value of the <code>trailing_only_offset_is_reached</code> vary between True and False, the values of the <code>trailing_stop_positive</code> and <code>trailing_stop_positive_offset</code> parameters vary in the ranges 0.02...0.35 and 0.01...0.1 correspondingly, which is sufficient in most cases.</p> <p>Override the <code>trailing_space()</code> method and define the desired range in it if you need values of the trailing stop parameters to vary in other ranges during hyperoptimization. A sample for this method can be found in the overriding pre-defined spaces section.</p> <p>Reduced search space</p> <p>To limit the search space further, Decimals are limited to 3 decimal places (a precision of 0.001). This is usually sufficient, every value more precise than this will usually result in overfitted results. You can however overriding pre-defined spaces to change this to your needs.</p>"},{"location":"hyperopt/#reproducible-results","title":"Reproducible results","text":"<p>The search for optimal parameters starts with a few (currently 30) random combinations in the hyperspace of parameters, random Hyperopt epochs. These random epochs are marked with an asterisk character (<code>*</code>) in the first column in the Hyperopt output.</p> <p>The initial state for generation of these random values (random state) is controlled by the value of the <code>--random-state</code> command line option. You can set it to some arbitrary value of your choice to obtain reproducible results.</p> <p>If you have not set this value explicitly in the command line options, Hyperopt seeds the random state with some random value for you. The random state value for each Hyperopt run is shown in the log, so you can copy and paste it into the <code>--random-state</code> command line option to repeat the set of the initial random epochs used.</p> <p>If you have not changed anything in the command line options, configuration, timerange, Strategy and Hyperopt classes, historical data and the Loss Function -- you should obtain same hyper-optimization results with same random state value used.</p>"},{"location":"hyperopt/#output-formatting","title":"Output formatting","text":"<p>By default, hyperopt prints colorized results -- epochs with positive profit are printed in the green color. This highlighting helps you find epochs that can be interesting for later analysis. Epochs with zero total profit or with negative profits (losses) are printed in the normal color. If you do not need colorization of results (for instance, when you are redirecting hyperopt output to a file) you can switch colorization off by specifying the <code>--no-color</code> option in the command line.</p> <p>You can use the <code>--print-all</code> command line option if you would like to see all results in the hyperopt output, not only the best ones. When <code>--print-all</code> is used, current best results are also colorized by default -- they are printed in bold (bright) style. This can also be switched off with the <code>--no-color</code> command line option.</p> <p>Windows and color output</p> <p>Windows does not support color-output natively, therefore it is automatically disabled. To have color-output for hyperopt running under windows, please consider using WSL.</p>"},{"location":"hyperopt/#position-stacking-and-disabling-max-market-positions","title":"Position stacking and disabling max market positions","text":"<p>In some situations, you may need to run Hyperopt (and Backtesting) with the <code>--eps</code>/<code>--enable-position-staking</code> and <code>--dmmp</code>/<code>--disable-max-market-positions</code> arguments.</p> <p>By default, hyperopt emulates the behavior of the Freqtrade Live Run/Dry Run, where only one open trade is allowed for every traded pair. The total number of trades open for all pairs is also limited by the <code>max_open_trades</code> setting. During Hyperopt/Backtesting this may lead to some potential trades to be hidden (or masked) by previously open trades.</p> <p>The <code>--eps</code>/<code>--enable-position-stacking</code> argument allows emulation of buying the same pair multiple times, while <code>--dmmp</code>/<code>--disable-max-market-positions</code> disables applying <code>max_open_trades</code> during Hyperopt/Backtesting (which is equal to setting <code>max_open_trades</code> to a very high number).</p> <p>Note</p> <p>Dry/live runs will NOT use position stacking - therefore it does make sense to also validate the strategy without this as it's closer to reality.</p> <p>You can also enable position stacking in the configuration file by explicitly setting <code>\"position_stacking\"=true</code>.</p>"},{"location":"hyperopt/#out-of-memory-errors","title":"Out of Memory errors","text":"<p>As hyperopt consumes a lot of memory (the complete data needs to be in memory once per parallel backtesting process), it's likely that you run into \"out of memory\" errors. To combat these, you have multiple options:</p> <ul> <li>Reduce the amount of pairs.</li> <li>Reduce the timerange used (<code>--timerange &lt;timerange&gt;</code>).</li> <li>Avoid using <code>--timeframe-detail</code> (this loads a lot of additional data into memory).</li> <li>Reduce the number of parallel processes (<code>-j &lt;n&gt;</code>).</li> <li>Increase the memory of your machine.</li> <li>Use <code>--analyze-per-epoch</code> if you're using a lot of parameters with <code>.range</code> functionality.</li> </ul>"},{"location":"hyperopt/#the-objective-has-been-evaluated-at-this-point-before","title":"The objective has been evaluated at this point before.","text":"<p>If you see <code>The objective has been evaluated at this point before.</code> - then this is a sign that your space has been exhausted, or is close to that. Basically all points in your space have been hit (or a local minima has been hit) - and hyperopt does no longer find points in the multi-dimensional space it did not try yet. Freqtrade tries to counter the \"local minima\" problem by using new, randomized points in this case.</p> <p>Example:</p> <pre><code>buy_ema_short = IntParameter(5, 20, default=10, space=\"buy\", optimize=True)\n# This is the only parameter in the buy space\n</code></pre> <p>The <code>buy_ema_short</code> space has 15 possible values (<code>5, 6, ... 19, 20</code>). If you now run hyperopt for the buy space, hyperopt will only have 15 values to try before running out of options. Your epochs should therefore be aligned to the possible values - or you should be ready to interrupt a run if you norice a lot of <code>The objective has been evaluated at this point before.</code> warnings.</p>"},{"location":"hyperopt/#show-details-of-hyperopt-results","title":"Show details of Hyperopt results","text":"<p>After you run Hyperopt for the desired amount of epochs, you can later list all results for analysis, select only best or profitable once, and show the details for any of the epochs previously evaluated. This can be done with the <code>hyperopt-list</code> and <code>hyperopt-show</code> sub-commands. The usage of these sub-commands is described in the Utils chapter.</p>"},{"location":"hyperopt/#validate-backtesting-results","title":"Validate backtesting results","text":"<p>Once the optimized strategy has been implemented into your strategy, you should backtest this strategy to make sure everything is working as expected.</p> <p>To achieve same the results (number of trades, their durations, profit, etc.) as during Hyperopt, please use the same configuration and parameters (timerange, timeframe, ...) used for hyperopt <code>--dmmp</code>/<code>--disable-max-market-positions</code> and <code>--eps</code>/<code>--enable-position-stacking</code> for Backtesting.</p>"},{"location":"hyperopt/#why-do-my-backtest-results-not-match-my-hyperopt-results","title":"Why do my backtest results not match my hyperopt results?","text":"<p>Should results not match, check the following factors:</p> <ul> <li>You may have added parameters to hyperopt in <code>populate_indicators()</code> where they will be calculated only once for all epochs. If you are, for example, trying to optimise multiple SMA timeperiod values, the hyperoptable timeperiod parameter should be placed in <code>populate_entry_trend()</code> which is calculated every epoch. See Optimizing an indicator parameter.</li> <li>If you have disabled the auto-export of hyperopt parameters into the JSON parameters file, double-check to make sure you transferred all hyperopted values into your strategy correctly.</li> <li>Check the logs to verify what parameters are being set and what values are being used.</li> <li>Pay special care to the stoploss, max_open_trades and trailing stoploss parameters, as these are often set in configuration files, which override changes to the strategy. Check the logs of your backtest to ensure that there were no parameters inadvertently set by the configuration (like <code>stoploss</code>, <code>max_open_trades</code> or <code>trailing_stop</code>).</li> <li>Verify that you do not have an unexpected parameters JSON file overriding the parameters or the default hyperopt settings in your strategy.</li> <li>Verify that any protections that are enabled in backtesting are also enabled when hyperopting, and vice versa. When using <code>--space protection</code>, protections are auto-enabled for hyperopting.</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>This page explains how to prepare your environment for running the bot.</p> <p>The freqtrade documentation describes various ways to install freqtrade</p> <ul> <li>Docker images (separate page)</li> <li>Script Installation</li> <li>Manual Installation</li> <li>Installation with Conda</li> </ul> <p>Please consider using the prebuilt docker images to get started quickly while evaluating how freqtrade works.</p>"},{"location":"installation/#information","title":"Information","text":"<p>For Windows installation, please use the windows installation guide.</p> <p>The easiest way to install and run Freqtrade is to clone the bot Github repository and then run the <code>./setup.sh</code> script, if it's available for your platform.</p> <p>Version considerations</p> <p>When cloning the repository the default working branch has the name <code>develop</code>. This branch contains all last features (can be considered as relatively stable, thanks to automated tests). The <code>stable</code> branch contains the code of the last release (done usually once per month on an approximately one week old snapshot of the <code>develop</code> branch to prevent packaging bugs, so potentially it's more stable).</p> <p>Note</p> <p>Python3.9 or higher and the corresponding <code>pip</code> are assumed to be available. The install-script will warn you and stop if that's not the case. <code>git</code> is also needed to clone the Freqtrade repository. Also, python headers (<code>python&lt;yourversion&gt;-dev</code> / <code>python&lt;yourversion&gt;-devel</code>) must be available for the installation to complete successfully.</p> <p>Up-to-date clock</p> <p>The clock on the system running the bot must be accurate, synchronized to a NTP server frequently enough to avoid problems with communication to the exchanges.</p>"},{"location":"installation/#requirements","title":"Requirements","text":"<p>These requirements apply to both Script Installation and Manual Installation.</p> <p>ARM64 systems</p> <p>If you are running an ARM64 system (like a MacOS M1 or an Oracle VM), please use docker to run freqtrade. While native installation is possible with some manual effort, this is not supported at the moment.</p>"},{"location":"installation/#install-guide","title":"Install guide","text":"<ul> <li>Python &gt;= 3.9</li> <li>pip</li> <li>git</li> <li>virtualenv (Recommended)</li> <li>TA-Lib (install instructions below)</li> </ul>"},{"location":"installation/#install-code","title":"Install code","text":"<p>We've included/collected install instructions for Ubuntu, MacOS, and Windows. These are guidelines and your success may vary with other distros. OS Specific steps are listed first, the common section below is necessary for all systems.</p> <p>Note</p> <p>Python3.9 or higher and the corresponding pip are assumed to be available.</p> Debian/UbuntuRaspberryPi/Raspbian <p>The following assumes the latest Raspbian Buster lite image. This image comes with python3.9 preinstalled, making it easy to get freqtrade up and running.</p> <p>Tested using a Raspberry Pi 3 with the Raspbian Buster lite image, all updates applied.</p> <pre><code>sudo apt-get install python3-venv libatlas-base-dev cmake curl\n# Use pywheels.org to speed up installation\nsudo echo \"[global]\\nextra-index-url=https://www.piwheels.org/simple\" &gt; tee /etc/pip.conf\n\ngit clone https://github.com/freqtrade/freqtrade.git\ncd freqtrade\n\nbash setup.sh -i\n</code></pre> <p>Installation duration</p> <p>Depending on your internet speed and the Raspberry Pi version, installation can take multiple hours to complete. Due to this, we recommend to use the pre-build docker-image for Raspberry, by following the Docker quickstart documentation</p> <p>Note</p> <p>The above does not install hyperopt dependencies. To install these, please use <code>python3 -m pip install -e .[hyperopt]</code>. We do not advise to run hyperopt on a Raspberry Pi, since this is a very resource-heavy operation, which should be done on powerful machine.</p>"},{"location":"installation/#install-necessary-dependencies","title":"Install necessary dependencies","text":"<pre><code># update repository\nsudo apt-get update\n\n# install packages\nsudo apt install -y python3-pip python3-venv python3-dev python3-pandas git curl\n</code></pre>"},{"location":"installation/#freqtrade-repository","title":"Freqtrade repository","text":"<p>Freqtrade is an open source crypto-currency trading bot, whose code is hosted on <code>github.com</code></p> <pre><code># Download `develop` branch of freqtrade repository\ngit clone https://github.com/freqtrade/freqtrade.git\n\n# Enter downloaded directory\ncd freqtrade\n\n# your choice (1): novice user\ngit checkout stable\n\n# your choice (2): advanced user\ngit checkout develop\n</code></pre> <p>(1) This command switches the cloned repository to the use of the <code>stable</code> branch. It's not needed, if you wish to stay on the (2) <code>develop</code> branch.</p> <p>You may later switch between branches at any time with the <code>git checkout stable</code>/<code>git checkout develop</code> commands.</p> Install from pypi <p>An alternative way to install Freqtrade is from pypi. The downside is that this method requires ta-lib to be correctly installed beforehand, and is therefore currently not the recommended way to install Freqtrade.</p> <pre><code>pip install freqtrade\n</code></pre>"},{"location":"installation/#script-installation","title":"Script Installation","text":"<p>First of the ways to install Freqtrade, is to use provided the Linux/MacOS <code>./setup.sh</code> script, which install all dependencies and help you configure the bot.</p> <p>Make sure you fulfill the Requirements and have downloaded the Freqtrade repository.</p>"},{"location":"installation/#use-setupsh-install-linuxmacos","title":"Use /setup.sh -install (Linux/MacOS)","text":"<p>If you are on Debian, Ubuntu or MacOS, freqtrade provides the script to install freqtrade.</p> <pre><code># --install, Install freqtrade from scratch\n./setup.sh -i\n</code></pre>"},{"location":"installation/#activate-your-virtual-environment","title":"Activate your virtual environment","text":"<p>Each time you open a new terminal, you must run <code>source .venv/bin/activate</code> to activate your virtual environment.</p> <pre><code># activate virtual environment\nsource ./.venv/bin/activate\n</code></pre>"},{"location":"installation/#congratulations","title":"Congratulations","text":"<p>You are ready, and run the bot</p>"},{"location":"installation/#other-options-of-setupsh-script","title":"Other options of /setup.sh script","text":"<p>You can as well update, configure and reset the codebase of your bot with <code>./script.sh</code></p> <pre><code># --update, Command git pull to update.\n./setup.sh -u\n# --reset, Hard reset your develop/stable branch.\n./setup.sh -r\n</code></pre> <pre><code>** --install **\n\nWith this option, the script will install the bot and most dependencies:\nYou will need to have git and python3.9+ installed beforehand for this to work.\n\n* Mandatory software as: `ta-lib`\n* Setup your virtualenv under `.venv/`\n\nThis option is a combination of installation tasks and `--reset`\n\n** --update **\n\nThis option will pull the last version of your current branch and update your virtualenv. Run the script with this option periodically to update your bot.\n\n** --reset **\n\nThis option will hard reset your branch (only if you are on either `stable` or `develop`) and recreate your virtualenv.\n</code></pre>"},{"location":"installation/#manual-installation","title":"Manual Installation","text":"<p>Make sure you fulfill the Requirements and have downloaded the Freqtrade repository.</p>"},{"location":"installation/#install-ta-lib","title":"Install TA-Lib","text":""},{"location":"installation/#ta-lib-script-installation","title":"TA-Lib script installation","text":"<pre><code>sudo ./build_helpers/install_ta-lib.sh\n</code></pre> <p>Note</p> <p>This will use the ta-lib tar.gz included in this repository.</p>"},{"location":"installation/#ta-lib-manual-installation","title":"TA-Lib manual installation","text":"<p>Official installation guide</p> <pre><code>wget http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz\ntar xvzf ta-lib-0.4.0-src.tar.gz\ncd ta-lib\nsed -i.bak \"s|0.00000001|0.000000000000000001 |g\" src/ta_func/ta_utility.h\n./configure --prefix=/usr/local\nmake\nsudo make install\n# On debian based systems (debian, ubuntu, ...) - updating ldconfig might be necessary.\nsudo ldconfig  \ncd ..\nrm -rf ./ta-lib*\n</code></pre>"},{"location":"installation/#setup-python-virtual-environment-virtualenv","title":"Setup Python virtual environment (virtualenv)","text":"<p>You will run freqtrade in separated <code>virtual environment</code></p> <pre><code># create virtualenv in directory /freqtrade/.venv\npython3 -m venv .venv\n\n# run virtualenv\nsource .venv/bin/activate\n</code></pre>"},{"location":"installation/#install-python-dependencies","title":"Install python dependencies","text":"<pre><code>python3 -m pip install --upgrade pip\npython3 -m pip install -r requirements.txt\npython3 -m pip install -e .\n</code></pre>"},{"location":"installation/#congratulations_1","title":"Congratulations","text":"<p>You are ready, and run the bot</p>"},{"location":"installation/#optional-post-installation-tasks","title":"(Optional) Post-installation Tasks","text":"<p>Note</p> <p>If you run the bot on a server, you should consider using Docker or a terminal multiplexer like <code>screen</code> or <code>tmux</code> to avoid that the bot is stopped on logout.</p> <p>On Linux with software suite <code>systemd</code>, as an optional post-installation task, you may wish to setup the bot to run as a <code>systemd service</code> or configure it to send the log messages to the <code>syslog</code>/<code>rsyslog</code> or <code>journald</code> daemons. See Advanced Logging for details.</p>"},{"location":"installation/#installation-with-conda","title":"Installation with Conda","text":"<p>Freqtrade can also be installed with Miniconda or Anaconda. We recommend using Miniconda as it's installation footprint is smaller. Conda will automatically prepare and manage the extensive library-dependencies of the Freqtrade program.</p>"},{"location":"installation/#what-is-conda","title":"What is Conda?","text":"<p>Conda is a package, dependency and environment manager for multiple programming languages: conda docs</p>"},{"location":"installation/#installation-with-conda_1","title":"Installation with conda","text":""},{"location":"installation/#install-conda","title":"Install Conda","text":"<p>Installing on linux</p> <p>Installing on windows</p> <p>Answer all questions. After installation, it is mandatory to turn your terminal OFF and ON again.</p>"},{"location":"installation/#freqtrade-download","title":"Freqtrade download","text":"<p>Download and install freqtrade.</p> <pre><code># download freqtrade\ngit clone https://github.com/freqtrade/freqtrade.git\n\n# enter downloaded directory 'freqtrade'\ncd freqtrade      \n</code></pre>"},{"location":"installation/#freqtrade-install-conda-environment","title":"Freqtrade install: Conda Environment","text":"<pre><code>conda create --name freqtrade python=3.12\n</code></pre> <p>Creating Conda Environment</p> <p>The conda command <code>create -n</code> automatically installs all nested dependencies for the selected libraries, general structure of installation command is:</p> <pre><code># choose your own packages\nconda env create -n [name of the environment] [python version] [packages]\n</code></pre>"},{"location":"installation/#enterexit-freqtrade-environment","title":"Enter/exit freqtrade environment","text":"<p>To check available environments, type</p> <pre><code>conda env list\n</code></pre> <p>Enter installed environment</p> <pre><code># enter conda environment\nconda activate freqtrade\n\n# exit conda environment - don't do it now\nconda deactivate\n</code></pre> <p>Install last python dependencies with pip</p> <pre><code>python3 -m pip install --upgrade pip\npython3 -m pip install -r requirements.txt\npython3 -m pip install -e .\n</code></pre> <p>Patch conda libta-lib (Linux only)</p> <pre><code># Ensure that the environment is active!\nconda activate freqtrade\n\ncd build_helpers\nbash install_ta-lib.sh ${CONDA_PREFIX} nosudo\n</code></pre>"},{"location":"installation/#congratulations_2","title":"Congratulations","text":"<p>You are ready, and run the bot</p>"},{"location":"installation/#important-shortcuts","title":"Important shortcuts","text":"<pre><code># list installed conda environments\nconda env list\n\n# activate base environment\nconda activate\n\n# activate freqtrade environment\nconda activate freqtrade\n\n#deactivate any conda environments\nconda deactivate                              \n</code></pre>"},{"location":"installation/#further-info-on-anaconda","title":"Further info on anaconda","text":"<p>New heavy packages</p> <p>It may happen that creating a new Conda environment, populated with selected packages at the moment of creation takes less time than installing a large, heavy library or application, into previously set environment.</p> <p>pip install within conda</p> <p>The documentation of conda says that pip should NOT be used within conda, because internal problems can occur. However, they are rare. Anaconda Blogpost</p> <p>Nevertheless, that is why, the <code>conda-forge</code> channel is preferred:</p> <ul> <li>more libraries are available (less need for <code>pip</code>)</li> <li><code>conda-forge</code> works better with <code>pip</code></li> <li>the libraries are newer</li> </ul> <p>Happy trading!</p>"},{"location":"installation/#you-are-ready","title":"You are ready","text":"<p>You've made it this far, so you have successfully installed freqtrade.</p>"},{"location":"installation/#initialize-the-configuration","title":"Initialize the configuration","text":"<pre><code># Step 1 - Initialize user folder\nfreqtrade create-userdir --userdir user_data\n\n# Step 2 - Create a new configuration file\nfreqtrade new-config --config user_data/config.json\n</code></pre> <p>You are ready to run, read Bot Configuration, remember to start with <code>dry_run: True</code> and verify that everything is working.</p> <p>To learn how to setup your configuration, please refer to the Bot Configuration documentation page.</p>"},{"location":"installation/#start-the-bot","title":"Start the Bot","text":"<pre><code>freqtrade trade --config user_data/config.json --strategy SampleStrategy\n</code></pre> <p>Warning</p> <p>You should read through the rest of the documentation, backtest the strategy you're going to use, and use dry-run before enabling trading with real money.</p>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#common-problem-command-not-found","title":"Common problem: \"command not found\"","text":"<p>If you used (1)<code>Script</code> or (2)<code>Manual</code> installation, you need to run the bot in virtual environment. If you get error as below, make sure venv is active.</p> <pre><code># if:\nbash: freqtrade: command not found\n\n# then activate your virtual environment\nsource ./.venv/bin/activate\n</code></pre>"},{"location":"installation/#macos-installation-error","title":"MacOS installation error","text":"<p>Newer versions of MacOS may have installation failed with errors like <code>error: command 'g++' failed with exit status 1</code>.</p> <p>This error will require explicit installation of the SDK Headers, which are not installed by default in this version of MacOS. For MacOS 10.14, this can be accomplished with the below command.</p> <pre><code>open /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg\n</code></pre> <p>If this file is inexistent, then you're probably on a different version of MacOS, so you may need to consult the internet for specific resolution details.</p>"},{"location":"leverage/","title":"Trading with Leverage","text":"<p>Beta feature</p> <p>This feature is still in it's testing phase. Should you notice something you think is wrong please let us know via Discord or via Github Issue.</p> <p>Multiple bots on one account</p> <p>You can't run 2 bots on the same account with leverage. For leveraged / margin trading, freqtrade assumes it's the only user of the account, and all liquidation levels are calculated based on this assumption.</p> <p>Trading with leverage is very risky</p> <p>Do not trade with a leverage &gt; 1 using a strategy that hasn't shown positive results in a live run using the spot market. Check the stoploss of your strategy. With a leverage of 2, a stoploss of 0.5 (50%) would be too low, and these trades would be liquidated before reaching that stoploss. We do not assume any responsibility for eventual losses that occur from using this software or this mode.</p> <p>Please only use advanced trading modes when you know how freqtrade (and your strategy) works. Also, never risk more than what you can afford to lose.</p> <p>If you already have an existing strategy, please read the strategy migration guide to migrate your strategy from a freqtrade v2 strategy, to strategy of version 3 which can short and trade futures.</p>"},{"location":"leverage/#shorting","title":"Shorting","text":"<p>Shorting is not possible when trading with <code>trading_mode</code> set to <code>spot</code>. To short trade, <code>trading_mode</code> must be set to <code>margin</code>(currently unavailable) or <code>futures</code>, with <code>margin_mode</code> set to <code>cross</code>(currently unavailable) or <code>isolated</code></p> <p>For a strategy to short, the strategy class must set the class variable <code>can_short = True</code></p> <p>Please read strategy customization for instructions on how to set signals to enter and exit short trades.</p>"},{"location":"leverage/#understand-trading_mode","title":"Understand <code>trading_mode</code>","text":"<p>The possible values are: <code>spot</code> (default), <code>margin</code>(Currently unavailable) or <code>futures</code>.</p>"},{"location":"leverage/#spot","title":"Spot","text":"<p>Regular trading mode (low risk)</p> <ul> <li>Long trades only (No short trades).</li> <li>No leverage.</li> <li>No Liquidation.</li> <li>Profits gained/lost are equal to the change in value of the assets (minus trading fees).</li> </ul>"},{"location":"leverage/#leverage-trading-modes","title":"Leverage trading modes","text":"<p>With leverage, a trader borrows capital from the exchange. The capital must be re-payed fully to the exchange (potentially with interest), and the trader keeps any profits, or pays any losses, from any trades made using the borrowed capital.</p> <p>Because the capital must always be re-payed, exchanges will liquidate (forcefully sell the traders assets) a trade made using borrowed capital when the total value of assets in the leverage account drops to a certain point (a point where the total value of losses is less than the value of the collateral that the trader actually owns in the leverage account), in order to ensure that the trader has enough capital to pay the borrowed assets back to the exchange. The exchange will also charge a liquidation fee, adding to the traders losses.</p> <p>For this reason, DO NOT TRADE WITH LEVERAGE IF YOU DON'T KNOW EXACTLY WHAT YOUR DOING. LEVERAGE TRADING IS HIGH RISK, AND CAN RESULT IN THE VALUE OF YOUR ASSETS DROPPING TO 0 VERY QUICKLY, WITH NO CHANCE OF INCREASING IN VALUE AGAIN.</p>"},{"location":"leverage/#margin-currently-unavailable","title":"Margin (currently unavailable)","text":"<p>Trading occurs on the spot market, but the exchange lends currency to you in an amount equal to the chosen leverage. You pay the amount lent to you back to the exchange with interest, and your profits/losses are multiplied by the leverage specified.</p>"},{"location":"leverage/#futures","title":"Futures","text":"<p>Perpetual swaps (also known as Perpetual Futures) are contracts traded at a price that is closely tied to the underlying asset they are based off of (ex.). You are not trading the actual asset but instead are trading a derivative contract. Perpetual swap contracts can last indefinitely, in contrast to futures or option contracts.</p> <p>In addition to the gains/losses from the change in price of the futures contract, traders also exchange funding fees, which are gains/losses worth an amount that is derived from the difference in price between the futures contract and the underlying asset. The difference in price between a futures contract and the underlying asset varies between exchanges.</p> <p>To trade in futures markets, you'll have to set <code>trading_mode</code> to \"futures\". You will also have to pick a \"margin mode\" (explanation below) - with freqtrade currently only supporting isolated margin.</p> <pre><code>\"trading_mode\": \"futures\",\n\"margin_mode\": \"isolated\"\n</code></pre>"},{"location":"leverage/#pair-namings","title":"Pair namings","text":"<p>Freqtrade follows the ccxt naming conventions for futures. A futures pair will therefore have the naming of <code>base/quote:settle</code> (e.g. <code>ETH/USDT:USDT</code>).</p>"},{"location":"leverage/#margin-mode","title":"Margin mode","text":"<p>On top of <code>trading_mode</code> - you will also have to configure your <code>margin_mode</code>. While freqtrade currently only supports one margin mode, this will change, and by configuring it now you're all set for future updates.</p> <p>The possible values are: <code>isolated</code>, or <code>cross</code>(currently unavailable).</p>"},{"location":"leverage/#isolated-margin-mode","title":"Isolated margin mode","text":"<p>Each market(trading pair), keeps collateral in a separate account</p> <pre><code>\"margin_mode\": \"isolated\"\n</code></pre>"},{"location":"leverage/#cross-margin-mode-currently-unavailable","title":"Cross margin mode (currently unavailable)","text":"<p>One account is used to share collateral between markets (trading pairs). Margin is taken from total account balance to avoid liquidation when needed.</p> <pre><code>\"margin_mode\": \"cross\"\n</code></pre> <p>Please read the exchange specific notes for exchanges that support this mode and how they differ.</p>"},{"location":"leverage/#set-leverage-to-use","title":"Set leverage to use","text":"<p>Different strategies and risk profiles will require different levels of leverage. While you could configure one static leverage value - freqtrade offers you the flexibility to adjust this via strategy leverage callback - which allows you to use different leverages by pair, or based on some other factor benefitting your strategy result.</p> <p>If not implemented, leverage defaults to 1x (no leverage).</p> <p>Warning</p> <p>Higher leverage also equals higher risk - be sure you fully understand the implications of using leverage!</p>"},{"location":"leverage/#understand-liquidation_buffer","title":"Understand <code>liquidation_buffer</code>","text":"<p>Defaults to <code>0.05</code></p> <p>A ratio specifying how large of a safety net to place between the liquidation price and the stoploss to prevent a position from reaching the liquidation price. This artificial liquidation price is calculated as:</p> <p><code>freqtrade_liquidation_price = liquidation_price \u00b1 (abs(open_rate - liquidation_price) * liquidation_buffer)</code></p> <ul> <li><code>\u00b1</code> = <code>+</code> for long trades</li> <li><code>\u00b1</code> = <code>-</code> for short trades</li> </ul> <p>Possible values are any floats between 0.0 and 0.99</p> <p>ex: If a trade is entered at a price of 10 coin/USDT, and the liquidation price of this trade is 8 coin/USDT, then with <code>liquidation_buffer</code> set to <code>0.05</code> the minimum stoploss for this trade would be \\(8 + ((10 - 8) * 0.05) = 8 + 0.1 = 8.1\\)</p> <p>A <code>liquidation_buffer</code> of 0.0, or a low <code>liquidation_buffer</code> is likely to result in liquidations, and liquidation fees</p> <p>Currently Freqtrade is able to calculate liquidation prices, but does not calculate liquidation fees. Setting your <code>liquidation_buffer</code> to 0.0, or using a low <code>liquidation_buffer</code> could result in your positions being liquidated. Freqtrade does not track liquidation fees, so liquidations will result in inaccurate profit/loss results for your bot. If you use a low <code>liquidation_buffer</code>, it is recommended to use <code>stoploss_on_exchange</code> if your exchange supports this.</p>"},{"location":"leverage/#unavailable-funding-rates","title":"Unavailable funding rates","text":"<p>For futures data, exchanges commonly provide the futures candles, the marks, and the funding rates. However, it is common that whilst candles and marks might be available, the funding rates are not. This can affect backtesting timeranges, i.e. you may only be able to test recent timeranges and not earlier, experiencing the <code>No data found. Terminating.</code> error. To get around this, add the <code>futures_funding_rate</code> config option as listed in configuration.md, and it is recommended that you set this to <code>0</code>, unless you know a given specific funding rate for your pair, exchange and timerange. Setting this to anything other than <code>0</code> can have drastic effects on your profit calculations within strategy, e.g. within the <code>custom_exit</code>, <code>custom_stoploss</code>, etc functions.</p> <p>This will mean your backtests are inaccurate.</p> <p>This will not overwrite funding rates that are available from the exchange, but bear in mind that setting a false funding rate will mean backtesting results will be inaccurate for historical timeranges where funding rates are not available.</p>"},{"location":"leverage/#developer","title":"Developer","text":""},{"location":"leverage/#margin-mode_1","title":"Margin mode","text":"<p>For shorts, the currency which pays the interest fee for the <code>borrowed</code> currency is purchased at the same time of the closing trade (This means that the amount purchased in short closing trades is greater than the amount sold in short opening trades).</p> <p>For longs, the currency which pays the interest fee for the <code>borrowed</code> will already be owned by the user and does not need to be purchased. The interest is subtracted from the <code>close_value</code> of the trade.</p> <p>All Fees are included in <code>current_profit</code> calculations during the trade.</p>"},{"location":"leverage/#futures-mode","title":"Futures mode","text":"<p>Funding fees are either added or subtracted from the total amount of a trade</p>"},{"location":"lookahead-analysis/","title":"Lookahead analysis","text":"<p>This page explains how to validate your strategy in terms of look ahead bias.</p> <p>Checking look ahead bias is the bane of any strategy since it is sometimes very easy to introduce backtest bias - but very hard to detect.</p> <p>Backtesting initializes all timestamps at once and calculates all indicators in the beginning. This means that if your indicators or entry/exit signals could look into future candles and falsify your backtest.</p> <p>Lookahead-analysis requires historic data to be available. To learn how to get data for the pairs and exchange you're interested in, head over to the Data Downloading section of the documentation.</p> <p>This command is built upon backtesting since it internally chains backtests and pokes at the strategy to provoke it to show look ahead bias. This is done by not looking at the strategy itself - but at the results it returned. The results are things like changed indicator-values and moved entries/exits compared to the full backtest.</p> <p>You can use commands of Backtesting. It also supports the lookahead-analysis of freqai strategies.</p> <ul> <li><code>--cache</code> is forced to \"none\".</li> <li><code>--max-open-trades</code> is forced to be at least equal to the number of pairs.</li> <li><code>--dry-run-wallet</code> is forced to be basically infinite (1 billion).</li> <li><code>--stake-amount</code> is forced to be a static 10000 (10k).</li> <li><code>--enable-protections</code> is forced to be off.</li> </ul> <p>Those are set to avoid users accidentally generating false positives.</p>"},{"location":"lookahead-analysis/#lookahead-analysis-command-reference","title":"Lookahead-analysis command reference","text":"<pre><code>usage: freqtrade lookahead-analysis [-h] [-v] [--logfile FILE] [-V] [-c PATH]\n                                    [-d PATH] [--userdir PATH] [-s NAME]\n                                    [--strategy-path PATH]\n                                    [--recursive-strategy-search]\n                                    [--freqaimodel NAME]\n                                    [--freqaimodel-path PATH] [-i TIMEFRAME]\n                                    [--timerange TIMERANGE]\n                                    [--data-format-ohlcv {json,jsongz,hdf5,feather,parquet}]\n                                    [--max-open-trades INT]\n                                    [--stake-amount STAKE_AMOUNT]\n                                    [--fee FLOAT] [-p PAIRS [PAIRS ...]]\n                                    [--dry-run-wallet DRY_RUN_WALLET]\n                                    [--timeframe-detail TIMEFRAME_DETAIL]\n                                    [--strategy-list STRATEGY_LIST [STRATEGY_LIST ...]]\n                                    [--export {none,trades,signals}]\n                                    [--export-filename PATH]\n                                    [--breakdown {day,week,month} [{day,week,month} ...]]\n                                    [--cache {none,day,week,month}]\n                                    [--freqai-backtest-live-models]\n                                    [--minimum-trade-amount INT]\n                                    [--targeted-trade-amount INT]\n                                    [--lookahead-analysis-exportfilename LOOKAHEAD_ANALYSIS_EXPORTFILENAME]\n\noptions:\n  --minimum-trade-amount INT\n                        Minimum trade amount for lookahead-analysis\n  --targeted-trade-amount INT\n                        Targeted trade amount for lookahead analysis\n  --lookahead-analysis-exportfilename LOOKAHEAD_ANALYSIS_EXPORTFILENAME\n                        Use this csv-filename to store lookahead-analysis-\n                        results\n</code></pre> <p>The above Output was reduced to options <code>lookahead-analysis</code> adds on top of regular backtesting commands.</p>"},{"location":"lookahead-analysis/#summary","title":"Summary","text":"<p>Checks a given strategy for look ahead bias via lookahead-analysis Look ahead bias means that the backtest uses data from future candles thereby not making it viable beyond backtesting and producing false hopes for the one backtesting.</p>"},{"location":"lookahead-analysis/#introduction","title":"Introduction","text":"<p>Many strategies - without the programmer knowing - have fallen prey to look ahead bias.</p> <p>Any backtest will populate the full dataframe including all time stamps at the beginning. If the programmer is not careful or oblivious how things work internally (which sometimes can be really hard to find out) then it will just look into the future making the strategy amazing but not realistic.</p> <p>This command is made to try to verify the validity in the form of the aforementioned look ahead bias.</p>"},{"location":"lookahead-analysis/#how-does-the-command-work","title":"How does the command work?","text":"<p>It will start with a backtest of all pairs to generate a baseline for indicators and entries/exits. After the backtest ran, it will look if the <code>minimum-trade-amount</code> is met and if not cancel the lookahead-analysis for this strategy.</p> <p>After setting the baseline it will then do additional runs for every entry and exit separately. When a verification-backtest is done, it will compare the indicators as the signal (either entry or exit) and report the bias. After all signals have been verified or falsified a result-table will be generated for the user to see.</p>"},{"location":"lookahead-analysis/#caveats","title":"Caveats","text":"<ul> <li><code>lookahead-analysis</code> can only verify / falsify the trades it calculated and verified. If the strategy has many different signals / signal types, it's up to you to select appropriate parameters to ensure that all signals have triggered at least once. Not triggered signals will not have been verified. This could lead to a false-negative (the strategy will then be reported as non-biased).</li> <li><code>lookahead-analysis</code> has access to everything that backtesting has too. Please don't provoke any configs like enabling position stacking. If you decide to do so, then make doubly sure that you won't ever run out of <code>max_open_trades</code> amount and neither leftover money in your wallet.</li> </ul>"},{"location":"plotting/","title":"Plotting","text":"<p>This page explains how to plot prices, indicators and profits.</p> <p>Deprecated</p> <p>The commands described in this page (<code>plot-dataframe</code>, <code>plot-profit</code>) should be considered deprecated and are in maintenance mode. This is mostly for the performance problems even medium sized plots can cause, but also because \"store a file and open it in a browser\" isn't very intuitive from a UI perspective.</p> <p>While there are no immediate plans to remove them, they are not actively maintained - and may be removed short-term should major changes be required to keep them working.</p> <p>Please use FreqUI for plotting needs, which doesn't struggle with the same performance problems.</p>"},{"location":"plotting/#installation-setup","title":"Installation / Setup","text":"<p>Plotting modules use the Plotly library. You can install / upgrade this by running the following command:</p> <pre><code>pip install -U -r requirements-plot.txt\n</code></pre>"},{"location":"plotting/#plot-price-and-indicators","title":"Plot price and indicators","text":"<p>The <code>freqtrade plot-dataframe</code> subcommand shows an interactive graph with three subplots:</p> <ul> <li>Main plot with candlesticks and indicators following price (sma/ema)</li> <li>Volume bars</li> <li>Additional indicators as specified by <code>--indicators2</code></li> </ul> <p></p> <p>Possible arguments:</p> <pre><code>usage: freqtrade plot-dataframe [-h] [-v] [--logfile FILE] [-V] [-c PATH]\n                                [-d PATH] [--userdir PATH] [-s NAME]\n                                [--strategy-path PATH] [-p PAIRS [PAIRS ...]]\n                                [--indicators1 INDICATORS1 [INDICATORS1 ...]]\n                                [--indicators2 INDICATORS2 [INDICATORS2 ...]]\n                                [--plot-limit INT] [--db-url PATH]\n                                [--trade-source {DB,file}] [--export EXPORT]\n                                [--export-filename PATH]\n                                [--timerange TIMERANGE] [-i TIMEFRAME]\n                                [--no-trades]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...]\n                        Limit command to these pairs. Pairs are space-\n                        separated.\n  --indicators1 INDICATORS1 [INDICATORS1 ...]\n                        Set indicators from your strategy you want in the\n                        first row of the graph. Space-separated list. Example:\n                        `ema3 ema5`. Default: `['sma', 'ema3', 'ema5']`.\n  --indicators2 INDICATORS2 [INDICATORS2 ...]\n                        Set indicators from your strategy you want in the\n                        third row of the graph. Space-separated list. Example:\n                        `fastd fastk`. Default: `['macd', 'macdsignal']`.\n  --plot-limit INT      Specify tick limit for plotting. Notice: too high\n                        values cause huge files. Default: 750.\n  --db-url PATH         Override trades database URL, this is useful in custom\n                        deployments (default: `sqlite:///tradesv3.sqlite` for\n                        Live Run mode, `sqlite:///tradesv3.dryrun.sqlite` for\n                        Dry Run).\n  --trade-source {DB,file}\n                        Specify the source for trades (Can be DB or file\n                        (backtest file)) Default: file\n  --export EXPORT       Export backtest results, argument are: trades.\n                        Example: `--export=trades`\n  --export-filename PATH\n                        Save backtest results to the file with this filename.\n                        Requires `--export` to be set as well. Example:\n                        `--export-filename=user_data/backtest_results/backtest\n                        _today.json`\n  --timerange TIMERANGE\n                        Specify what timerange of data to use.\n  -i TIMEFRAME, --timeframe TIMEFRAME\n                        Specify timeframe (`1m`, `5m`, `30m`, `1h`, `1d`).\n  --no-trades           Skip using trades from backtesting file and DB.\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n\nStrategy arguments:\n  -s NAME, --strategy NAME\n                        Specify strategy class name which will be used by the\n                        bot.\n  --strategy-path PATH  Specify additional strategy lookup path.\n</code></pre> <p>Example:</p> <pre><code>freqtrade plot-dataframe -p BTC/ETH --strategy AwesomeStrategy\n</code></pre> <p>The <code>-p/--pairs</code> argument can be used to specify pairs you would like to plot.</p> <p>Note</p> <p>The <code>freqtrade plot-dataframe</code> subcommand generates one plot-file per pair.</p> <p>Specify custom indicators. Use <code>--indicators1</code> for the main plot and <code>--indicators2</code> for the subplot below (if values are in a different range than prices).</p> <pre><code>freqtrade plot-dataframe --strategy AwesomeStrategy -p BTC/ETH --indicators1 sma ema --indicators2 macd\n</code></pre>"},{"location":"plotting/#further-usage-examples","title":"Further usage examples","text":"<p>To plot multiple pairs, separate them with a space:</p> <pre><code>freqtrade plot-dataframe --strategy AwesomeStrategy -p BTC/ETH XRP/ETH\n</code></pre> <p>To plot a timerange (to zoom in)</p> <pre><code>freqtrade plot-dataframe --strategy AwesomeStrategy -p BTC/ETH --timerange=20180801-20180805\n</code></pre> <p>To plot trades stored in a database use <code>--db-url</code> in combination with <code>--trade-source DB</code>:</p> <pre><code>freqtrade plot-dataframe --strategy AwesomeStrategy --db-url sqlite:///tradesv3.dry_run.sqlite -p BTC/ETH --trade-source DB\n</code></pre> <p>To plot trades from a backtesting result, use <code>--export-filename &lt;filename&gt;</code></p> <pre><code>freqtrade plot-dataframe --strategy AwesomeStrategy --export-filename user_data/backtest_results/backtest-result.json -p BTC/ETH\n</code></pre>"},{"location":"plotting/#plot-dataframe-basics","title":"Plot dataframe basics","text":"<p>The <code>plot-dataframe</code> subcommand requires backtesting data, a strategy and either a backtesting-results file or a database, containing trades corresponding to the strategy.</p> <p>The resulting plot will have the following elements:</p> <ul> <li>Green triangles: Buy signals from the strategy. (Note: not every buy signal generates a trade, compare to cyan circles.)</li> <li>Red triangles: Sell signals from the strategy. (Also, not every sell signal terminates a trade, compare to red and green squares.)</li> <li>Cyan circles: Trade entry points.</li> <li>Red squares: Trade exit points for trades with loss or 0% profit.</li> <li>Green squares: Trade exit points for profitable trades.</li> <li>Indicators with values corresponding to the candle scale (e.g. SMA/EMA), as specified with <code>--indicators1</code>.</li> <li>Volume (bar chart at the bottom of the main chart).</li> <li>Indicators with values in different scales (e.g. MACD, RSI) below the volume bars, as specified with <code>--indicators2</code>.</li> </ul> <p>Bollinger Bands</p> <p>Bollinger bands are automatically added to the plot if the columns <code>bb_lowerband</code> and <code>bb_upperband</code> exist, and are painted as a light blue area spanning from the lower band to the upper band.</p>"},{"location":"plotting/#advanced-plot-configuration","title":"Advanced plot configuration","text":"<p>An advanced plot configuration can be specified in the strategy in the <code>plot_config</code> parameter.</p> <p>Additional features when using <code>plot_config</code> include:</p> <ul> <li>Specify colors per indicator</li> <li>Specify additional subplots</li> <li>Specify indicator pairs to fill area in between</li> </ul> <p>The sample plot configuration below specifies fixed colors for the indicators. Otherwise, consecutive plots may produce different color schemes each time, making comparisons difficult. It also allows multiple subplots to display both MACD and RSI at the same time.</p> <p>Plot type can be configured using <code>type</code> key. Possible types are:</p> <ul> <li><code>scatter</code> corresponding to <code>plotly.graph_objects.Scatter</code> class (default).</li> <li><code>bar</code> corresponding to <code>plotly.graph_objects.Bar</code> class.</li> </ul> <p>Extra parameters to <code>plotly.graph_objects.*</code> constructor can be specified in <code>plotly</code> dict.</p> <p>Sample configuration with inline comments explaining the process:</p> <pre><code>@property\ndef plot_config(self):\n    \"\"\"\n        There are a lot of solutions how to build the return dictionary.\n        The only important point is the return value.\n        Example:\n            plot_config = {'main_plot': {}, 'subplots': {}}\n\n    \"\"\"\n    plot_config = {}\n    plot_config['main_plot'] = {\n        # Configuration for main plot indicators.\n        # Assumes 2 parameters, emashort and emalong to be specified.\n        f'ema_{self.emashort.value}': {'color': 'red'},\n        f'ema_{self.emalong.value}': {'color': '#CCCCCC'},\n        # By omitting color, a random color is selected.\n        'sar': {},\n        # fill area between senkou_a and senkou_b\n        'senkou_a': {\n            'color': 'green', #optional\n            'fill_to': 'senkou_b',\n            'fill_label': 'Ichimoku Cloud', #optional\n            'fill_color': 'rgba(255,76,46,0.2)', #optional\n        },\n        # plot senkou_b, too. Not only the area to it.\n        'senkou_b': {}\n    }\n    plot_config['subplots'] = {\n         # Create subplot MACD\n        \"MACD\": {\n            'macd': {'color': 'blue', 'fill_to': 'macdhist'},\n            'macdsignal': {'color': 'orange'},\n            'macdhist': {'type': 'bar', 'plotly': {'opacity': 0.9}}\n        },\n        # Additional subplot RSI\n        \"RSI\": {\n            'rsi': {'color': 'red'}\n        }\n    }\n\n    return plot_config\n</code></pre> As attribute (former method) <p>Assigning plot_config is also possible as Attribute (this used to be the default way). This has the disadvantage that strategy parameters are not available, preventing certain configurations from working.</p> <pre><code>    plot_config = {\n        'main_plot': {\n            # Configuration for main plot indicators.\n            # Specifies `ema10` to be red, and `ema50` to be a shade of gray\n            'ema10': {'color': 'red'},\n            'ema50': {'color': '#CCCCCC'},\n            # By omitting color, a random color is selected.\n            'sar': {},\n        # fill area between senkou_a and senkou_b\n        'senkou_a': {\n            'color': 'green', #optional\n            'fill_to': 'senkou_b',\n            'fill_label': 'Ichimoku Cloud', #optional\n            'fill_color': 'rgba(255,76,46,0.2)', #optional\n        },\n        # plot senkou_b, too. Not only the area to it.\n        'senkou_b': {}\n        },\n        'subplots': {\n            # Create subplot MACD\n            \"MACD\": {\n                'macd': {'color': 'blue', 'fill_to': 'macdhist'},\n                'macdsignal': {'color': 'orange'},\n                'macdhist': {'type': 'bar', 'plotly': {'opacity': 0.9}}\n            },\n            # Additional subplot RSI\n            \"RSI\": {\n                'rsi': {'color': 'red'}\n            }\n        }\n    }\n</code></pre> <p>Note</p> <p>The above configuration assumes that <code>ema10</code>, <code>ema50</code>, <code>senkou_a</code>, <code>senkou_b</code>, <code>macd</code>, <code>macdsignal</code>, <code>macdhist</code> and <code>rsi</code> are columns in the DataFrame created by the strategy.</p> <p>Warning</p> <p><code>plotly</code> arguments are only supported with plotly library and will not work with freq-ui.</p> <p>Trade position adjustments</p> <p>If <code>position_adjustment_enable</code> / <code>adjust_trade_position()</code> is used, the trade initial buy price is averaged over multiple orders and the trade start price will most likely appear outside the candle range.</p>"},{"location":"plotting/#plot-profit","title":"Plot profit","text":"<p>The <code>plot-profit</code> subcommand shows an interactive graph with three plots:</p> <ul> <li>Average closing price for all pairs.</li> <li>The summarized profit made by backtesting. Note that this is not the real-world profit, but more of an estimate.</li> <li>Profit for each individual pair.</li> <li>Parallelism of trades.</li> <li>Underwater (Periods of drawdown).</li> </ul> <p>The first graph is good to get a grip of how the overall market progresses.</p> <p>The second graph will show if your algorithm works or doesn't. Perhaps you want an algorithm that steadily makes small profits, or one that acts less often, but makes big swings. This graph will also highlight the start (and end) of the Max drawdown period.</p> <p>The third graph can be useful to spot outliers, events in pairs that cause profit spikes.</p> <p>The forth graph can help you analyze trade parallelism, showing how often max_open_trades have been maxed out.</p> <p>Possible options for the <code>freqtrade plot-profit</code> subcommand:</p> <pre><code>usage: freqtrade plot-profit [-h] [-v] [--logfile FILE] [-V] [-c PATH]\n                             [-d PATH] [--userdir PATH] [-s NAME]\n                             [--strategy-path PATH] [-p PAIRS [PAIRS ...]]\n                             [--timerange TIMERANGE] [--export EXPORT]\n                             [--export-filename PATH] [--db-url PATH]\n                             [--trade-source {DB,file}] [-i TIMEFRAME]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -p PAIRS [PAIRS ...], --pairs PAIRS [PAIRS ...]\n                        Limit command to these pairs. Pairs are space-\n                        separated.\n  --timerange TIMERANGE\n                        Specify what timerange of data to use.\n  --export EXPORT       Export backtest results, argument are: trades.\n                        Example: `--export=trades`\n  --export-filename PATH, --backtest-filename PATH\n                        Use backtest results from this filename.\n                        Requires `--export` to be set as well. Example:\n                        `--export-filename=user_data/backtest_results/backtest\n                        _today.json`\n  --db-url PATH         Override trades database URL, this is useful in custom\n                        deployments (default: `sqlite:///tradesv3.sqlite` for\n                        Live Run mode, `sqlite:///tradesv3.dryrun.sqlite` for\n                        Dry Run).\n  --trade-source {DB,file}\n                        Specify the source for trades (Can be DB or file\n                        (backtest file)) Default: file\n  -i TIMEFRAME, --timeframe TIMEFRAME\n                        Specify timeframe (`1m`, `5m`, `30m`, `1h`, `1d`).\n  --auto-open           Automatically open generated plot.\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n\nStrategy arguments:\n  -s NAME, --strategy NAME\n                        Specify strategy class name which will be used by the\n                        bot.\n  --strategy-path PATH  Specify additional strategy lookup path.\n</code></pre> <p>The <code>-p/--pairs</code>  argument, can be used to limit the pairs that are considered for this calculation.</p> <p>Examples:</p> <p>Use custom backtest-export file</p> <pre><code>freqtrade plot-profit  -p LTC/BTC --export-filename user_data/backtest_results/backtest-result.json\n</code></pre> <p>Use custom database</p> <pre><code>freqtrade plot-profit  -p LTC/BTC --db-url sqlite:///tradesv3.sqlite --trade-source DB\n</code></pre> <pre><code>freqtrade --datadir user_data/data/binance_save/ plot-profit -p LTC/BTC\n</code></pre>"},{"location":"plugins/","title":"Plugins","text":""},{"location":"plugins/#pairlists-and-pairlist-handlers","title":"Pairlists and Pairlist Handlers","text":"<p>Pairlist Handlers define the list of pairs (pairlist) that the bot should trade. They are configured in the <code>pairlists</code> section of the configuration settings.</p> <p>In your configuration, you can use Static Pairlist (defined by the <code>StaticPairList</code> Pairlist Handler) and Dynamic Pairlist (defined by the <code>VolumePairList</code> Pairlist Handler).</p> <p>Additionally, <code>AgeFilter</code>, <code>PrecisionFilter</code>, <code>PriceFilter</code>, <code>ShuffleFilter</code>, <code>SpreadFilter</code> and <code>VolatilityFilter</code> act as Pairlist Filters, removing certain pairs and/or moving their positions in the pairlist.</p> <p>If multiple Pairlist Handlers are used, they are chained and a combination of all Pairlist Handlers forms the resulting pairlist the bot uses for trading and backtesting. Pairlist Handlers are executed in the sequence they are configured. You can define either <code>StaticPairList</code>, <code>VolumePairList</code>, <code>ProducerPairList</code>, <code>RemotePairList</code> or <code>MarketCapPairList</code> as the starting Pairlist Handler.</p> <p>Inactive markets are always removed from the resulting pairlist. Explicitly blacklisted pairs (those in the <code>pair_blacklist</code> configuration setting) are also always removed from the resulting pairlist.</p>"},{"location":"plugins/#pair-blacklist","title":"Pair blacklist","text":"<p>The pair blacklist (configured via <code>exchange.pair_blacklist</code> in the configuration) disallows certain pairs from trading. This can be as simple as excluding <code>DOGE/BTC</code> - which will remove exactly this pair.</p> <p>The pair-blacklist does also support wildcards (in regex-style) - so <code>BNB/.*</code> will exclude ALL pairs that start with BNB. You may also use something like <code>.*DOWN/BTC</code> or <code>.*UP/BTC</code> to exclude leveraged tokens (check Pair naming conventions for your exchange!)</p>"},{"location":"plugins/#available-pairlist-handlers","title":"Available Pairlist Handlers","text":"<ul> <li><code>StaticPairList</code> (default, if not configured differently)</li> <li><code>VolumePairList</code></li> <li><code>ProducerPairList</code></li> <li><code>RemotePairList</code></li> <li><code>MarketCapPairList</code></li> <li><code>AgeFilter</code></li> <li><code>FullTradesFilter</code></li> <li><code>OffsetFilter</code></li> <li><code>PerformanceFilter</code></li> <li><code>PrecisionFilter</code></li> <li><code>PriceFilter</code></li> <li><code>ShuffleFilter</code></li> <li><code>SpreadFilter</code></li> <li><code>RangeStabilityFilter</code></li> <li><code>VolatilityFilter</code></li> </ul> <p>Testing pairlists</p> <p>Pairlist configurations can be quite tricky to get right. Best use the <code>test-pairlist</code> utility sub-command to test your configuration quickly.</p>"},{"location":"plugins/#static-pair-list","title":"Static Pair List","text":"<p>By default, the <code>StaticPairList</code> method is used, which uses a statically defined pair whitelist from the configuration. The pairlist also supports wildcards (in regex-style) - so <code>.*/BTC</code> will include all pairs with BTC as a stake.</p> <p>It uses configuration from <code>exchange.pair_whitelist</code> and <code>exchange.pair_blacklist</code>.</p> <pre><code>\"pairlists\": [\n    {\"method\": \"StaticPairList\"}\n],\n</code></pre> <p>By default, only currently enabled pairs are allowed. To skip pair validation against active markets, set <code>\"allow_inactive\": true</code> within the <code>StaticPairList</code> configuration. This can be useful for backtesting expired pairs (like quarterly spot-markets). This option must be configured along with <code>exchange.skip_pair_validation</code> in the exchange configuration.</p> <p>When used in a \"follow-up\" position (e.g. after VolumePairlist), all pairs in <code>'pair_whitelist'</code> will be added to the end of the pairlist.</p>"},{"location":"plugins/#volume-pair-list","title":"Volume Pair List","text":"<p><code>VolumePairList</code> employs sorting/filtering of pairs by their trading volume. It selects <code>number_assets</code> top pairs with sorting based on the <code>sort_key</code> (which can only be <code>quoteVolume</code>).</p> <p>When used in the chain of Pairlist Handlers in a non-leading position (after StaticPairList and other Pairlist Filters), <code>VolumePairList</code> considers outputs of previous Pairlist Handlers, adding its sorting/selection of the pairs by the trading volume.</p> <p>When used in the leading position of the chain of Pairlist Handlers, the <code>pair_whitelist</code> configuration setting is ignored. Instead, <code>VolumePairList</code> selects the top assets from all available markets with matching stake-currency on the exchange.</p> <p>The <code>refresh_period</code> setting allows to define the period (in seconds), at which the pairlist will be refreshed. Defaults to 1800s (30 minutes). The pairlist cache (<code>refresh_period</code>) on <code>VolumePairList</code> is only applicable to generating pairlists. Filtering instances (not the first position in the list) will not apply any cache (beyond caching candles for the duration of the candle in advanced mode) and will always use up-to-date data.</p> <p><code>VolumePairList</code> is per default based on the ticker data from exchange, as reported by the ccxt library:</p> <ul> <li>The <code>quoteVolume</code> is the amount of quote (stake) currency traded (bought or sold) in last 24 hours.</li> </ul> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"VolumePairList\",\n        \"number_assets\": 20,\n        \"sort_key\": \"quoteVolume\",\n        \"min_value\": 0,\n        \"max_value\": 8000000,\n        \"refresh_period\": 1800\n    }\n],\n</code></pre> <p>You can define a minimum volume with <code>min_value</code> - which will filter out pairs with a volume lower than the specified value in the specified timerange. In addition to that, you can also define a maximum volume with <code>max_value</code> - which will filter out pairs with a volume higher than the specified value in the specified timerange.</p>"},{"location":"plugins/#volumepairlist-advanced-mode","title":"VolumePairList Advanced mode","text":"<p><code>VolumePairList</code> can also operate in an advanced mode to build volume over a given timerange of specified candle size. It utilizes exchange historical candle data, builds a typical price (calculated by (open+high+low)/3) and multiplies the typical price with every candle's volume. The sum is the <code>quoteVolume</code> over the given range. This allows different scenarios, for a  more smoothened volume, when using longer ranges with larger candle sizes, or the opposite when using a short range with small candles.</p> <p>For convenience <code>lookback_days</code> can be specified, which will imply that 1d candles will be used for the lookback. In the example below the pairlist would be created based on the last 7 days:</p> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"VolumePairList\",\n        \"number_assets\": 20,\n        \"sort_key\": \"quoteVolume\",\n        \"min_value\": 0,\n        \"refresh_period\": 86400,\n        \"lookback_days\": 7\n    }\n],\n</code></pre> <p>Range look back and refresh period</p> <p>When used in conjunction with <code>lookback_days</code> and <code>lookback_timeframe</code> the <code>refresh_period</code> can not be smaller than the candle size in seconds. As this will result in unnecessary requests to the exchanges API.</p> <p>Performance implications when using lookback range</p> <p>If used in first position in combination with lookback, the computation of the range based volume can be time and resource consuming, as it downloads candles for all tradable pairs. Hence it's highly advised to use the standard approach with <code>VolumeFilter</code> to narrow the pairlist down for further range volume calculation.</p> Unsupported exchanges <p>On some exchanges (like Gemini), regular VolumePairList does not work as the api does not natively provide 24h volume. This can be worked around by using candle data to build the volume. To roughly simulate 24h volume, you can use the following configuration. Please note that These pairlists will only refresh once per day.</p> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"VolumePairList\",\n        \"number_assets\": 20,\n        \"sort_key\": \"quoteVolume\",\n        \"min_value\": 0,\n        \"refresh_period\": 86400,\n        \"lookback_days\": 1\n    }\n],\n</code></pre> <p>More sophisticated approach can be used, by using <code>lookback_timeframe</code> for candle size and <code>lookback_period</code> which specifies the amount of candles. This example will build the volume pairs based on a rolling period of 3 days of 1h candles:</p> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"VolumePairList\",\n        \"number_assets\": 20,\n        \"sort_key\": \"quoteVolume\",\n        \"min_value\": 0,\n        \"refresh_period\": 3600,\n        \"lookback_timeframe\": \"1h\",\n        \"lookback_period\": 72\n    }\n],\n</code></pre> <p>Note</p> <p><code>VolumePairList</code> does not support backtesting mode.</p>"},{"location":"plugins/#producerpairlist","title":"ProducerPairList","text":"<p>With <code>ProducerPairList</code>, you can reuse the pairlist from a Producer without explicitly defining the pairlist on each consumer.</p> <p>Consumer mode is required for this pairlist to work.</p> <p>The pairlist will perform a check on active pairs against the current exchange configuration to avoid attempting to trade on invalid markets.</p> <p>You can limit the length of the pairlist with the optional parameter <code>number_assets</code>. Using <code>\"number_assets\"=0</code> or omitting this key will result in the reuse of all producer pairs valid for the current setup.</p> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"ProducerPairList\",\n        \"number_assets\": 5,\n        \"producer_name\": \"default\",\n    }\n],\n</code></pre> <p>Combining pairlists</p> <p>This pairlist can be combined with all other pairlists and filters for further pairlist reduction, and can also act as an \"additional\" pairlist, on top of already defined pairs. <code>ProducerPairList</code> can also be used multiple times in sequence, combining the pairs from multiple producers. Obviously in complex such configurations, the Producer may not provide data for all pairs, so the strategy must be fit for this.</p>"},{"location":"plugins/#remotepairlist","title":"RemotePairList","text":"<p>It allows the user to fetch a pairlist from a remote server or a locally stored json file within the freqtrade directory, enabling dynamic updates and customization of the trading pairlist.</p> <p>The RemotePairList is defined in the pairlists section of the configuration settings. It uses the following configuration options:</p> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"RemotePairList\",\n        \"mode\": \"whitelist\",\n        \"processing_mode\": \"filter\",\n        \"pairlist_url\": \"https://example.com/pairlist\",\n        \"number_assets\": 10,\n        \"refresh_period\": 1800,\n        \"keep_pairlist_on_failure\": true,\n        \"read_timeout\": 60,\n        \"bearer_token\": \"my-bearer-token\",\n        \"save_to_file\": \"user_data/filename.json\" \n    }\n]\n</code></pre> <p>The optional <code>mode</code> option specifies if the pairlist should be used as a <code>blacklist</code> or as a <code>whitelist</code>. The default value is \"whitelist\".</p> <p>The optional <code>processing_mode</code> option in the RemotePairList configuration determines how the retrieved pairlist is processed. It can have two values: \"filter\" or \"append\". The default value is \"filter\".</p> <p>In \"filter\" mode, the retrieved pairlist is used as a filter. Only the pairs present in both the original pairlist and the retrieved pairlist are included in the final pairlist. Other pairs are filtered out.</p> <p>In \"append\" mode, the retrieved pairlist is added to the original pairlist. All pairs from both lists are included in the final pairlist without any filtering.</p> <p>The <code>pairlist_url</code> option specifies the URL of the remote server where the pairlist is located, or the path to a local file (if file:/// is prepended). This allows the user to use either a remote server or a local file as the source for the pairlist.</p> <p>The <code>save_to_file</code> option, when provided with a valid filename, saves the processed pairlist to that file in JSON format. This option is optional, and by default, the pairlist is not saved to a file.</p> Multi bot with shared pairlist example <p><code>save_to_file</code> can be used to save the pairlist to a file with Bot1:</p> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"RemotePairList\",\n        \"mode\": \"whitelist\",\n        \"pairlist_url\": \"https://example.com/pairlist\",\n        \"number_assets\": 10,\n        \"refresh_period\": 1800,\n        \"keep_pairlist_on_failure\": true,\n        \"read_timeout\": 60,\n        \"save_to_file\": \"user_data/filename.json\" \n    }\n]\n</code></pre> <p>This saved pairlist file can be loaded by Bot2, or any additional bot with this configuration:</p> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"RemotePairList\",\n        \"mode\": \"whitelist\",\n        \"pairlist_url\": \"file:///user_data/filename.json\",\n        \"number_assets\": 10,\n        \"refresh_period\": 10,\n        \"keep_pairlist_on_failure\": true,\n    }\n]\n</code></pre> <p>The user is responsible for providing a server or local file that returns a JSON object with the following structure:</p> <pre><code>{\n    \"pairs\": [\"XRP/USDT\", \"ETH/USDT\", \"LTC/USDT\"],\n    \"refresh_period\": 1800\n}\n</code></pre> <p>The <code>pairs</code> property should contain a list of strings with the trading pairs to be used by the bot. The <code>refresh_period</code> property is optional and specifies the number of seconds that the pairlist should be cached before being refreshed.</p> <p>The optional <code>keep_pairlist_on_failure</code> specifies whether the previous received pairlist should be used if the remote server is not reachable or returns an error. The default value is true.</p> <p>The optional <code>read_timeout</code> specifies the maximum amount of time (in seconds) to wait for a response from the remote source, The default value is 60.</p> <p>The optional <code>bearer_token</code> will be included in the requests Authorization Header.</p> <p>Note</p> <p>In case of a server error the last received pairlist will be kept if <code>keep_pairlist_on_failure</code> is set to true, when set to false a empty pairlist is returned.</p>"},{"location":"plugins/#marketcappairlist","title":"MarketCapPairList","text":"<p><code>MarketCapPairList</code> employs sorting/filtering of pairs by their marketcap rank based of CoinGecko. It will only recognize coins up to the coin placed at rank 250. The returned pairlist will be sorted based of their marketcap ranks.</p> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"MarketCapPairList\",\n        \"number_assets\": 20,\n        \"max_rank\": 50,\n        \"refresh_period\": 86400\n    }\n]\n</code></pre> <p><code>number_assets</code> defines the maximum number of pairs returned by the pairlist. <code>max_rank</code> will determine the maximum rank used in creating/filtering the pairlist. It's expected that some coins within the top <code>max_rank</code> marketcap will not be included in the resulting pairlist since not all pairs will have active trading pairs in your preferred market/stake/exchange combination.</p> <p><code>refresh_period</code> setting defines the period (in seconds) at which the marketcap rank data will be refreshed. Defaults to 86,400s (1 day). The pairlist cache (<code>refresh_period</code>) is applicable on both generating pairlists (first position in the list) and filtering instances (not the first position in the list).</p>"},{"location":"plugins/#agefilter","title":"AgeFilter","text":"<p>Removes pairs that have been listed on the exchange for less than <code>min_days_listed</code> days (defaults to <code>10</code>) or more than <code>max_days_listed</code> days (defaults <code>None</code> mean infinity).</p> <p>When pairs are first listed on an exchange they can suffer huge price drops and volatility in the first few days while the pair goes through its price-discovery period. Bots can often be caught out buying before the pair has finished dropping in price.</p> <p>This filter allows freqtrade to ignore pairs until they have been listed for at least <code>min_days_listed</code> days and listed before <code>max_days_listed</code>.</p>"},{"location":"plugins/#fulltradesfilter","title":"FullTradesFilter","text":"<p>Shrink whitelist to consist only in-trade pairs when the trade slots are full (when <code>max_open_trades</code> isn't being set to <code>-1</code> in the config).</p> <p>When the trade slots are full, there is no need to calculate indicators of the rest of the pairs (except informative pairs) since no new trade can be opened. By shrinking the whitelist to just the in-trade pairs, you can improve calculation speeds and reduce CPU usage. When a trade slot is free (either a trade is closed or <code>max_open_trades</code> value in config is increased), then the whitelist will return to normal state.</p> <p>When multiple pairlist filters are being used, it's recommended to put this filter at second position directly below the primary pairlist, so when the trade slots are full, the bot doesn't have to download data for the rest of the filters.</p> <p>Backtesting</p> <p><code>FullTradesFilter</code> does not support backtesting mode.</p>"},{"location":"plugins/#offsetfilter","title":"OffsetFilter","text":"<p>Offsets an incoming pairlist by a given <code>offset</code> value.</p> <p>As an example it can be used in conjunction with <code>VolumeFilter</code> to remove the top X volume pairs. Or to split a larger pairlist on two bot instances.</p> <p>Example to remove the first 10 pairs from the pairlist, and takes the next 20 (taking items 10-30 of the initial list):</p> <pre><code>\"pairlists\": [\n    // ...\n    {\n        \"method\": \"OffsetFilter\",\n        \"offset\": 10,\n        \"number_assets\": 20\n    }\n],\n</code></pre> <p>Warning</p> <p>When <code>OffsetFilter</code> is used to split a larger pairlist among multiple bots in combination with <code>VolumeFilter</code>  it can not be guaranteed that pairs won't overlap due to slightly different refresh intervals for the <code>VolumeFilter</code>.</p> <p>Note</p> <p>An offset larger than the total length of the incoming pairlist will result in an empty pairlist.</p>"},{"location":"plugins/#performancefilter","title":"PerformanceFilter","text":"<p>Sorts pairs by past trade performance, as follows:</p> <ol> <li>Positive performance.</li> <li>No closed trades yet.</li> <li>Negative performance.</li> </ol> <p>Trade count is used as a tie breaker.</p> <p>You can use the <code>minutes</code> parameter to only consider performance of the past X minutes (rolling window). Not defining this parameter (or setting it to 0) will use all-time performance.</p> <p>The optional <code>min_profit</code> (as ratio -&gt; a setting of <code>0.01</code> corresponds to 1%) parameter defines the minimum profit a pair must have to be considered. Pairs below this level will be filtered out. Using this parameter without <code>minutes</code> is highly discouraged, as it can lead to an empty pairlist without a way to recover.</p> <pre><code>\"pairlists\": [\n    // ...\n    {\n        \"method\": \"PerformanceFilter\",\n        \"minutes\": 1440,  // rolling 24h\n        \"min_profit\": 0.01  // minimal profit 1%\n    }\n],\n</code></pre> <p>As this Filter uses past performance of the bot, it'll have some startup-period - and should only be used after the bot has a few 100 trades in the database.</p> <p>Backtesting</p> <p><code>PerformanceFilter</code> does not support backtesting mode.</p>"},{"location":"plugins/#precisionfilter","title":"PrecisionFilter","text":"<p>Filters low-value coins which would not allow setting stoplosses.</p> <p>Namely, pairs are blacklisted if a variance of one percent or more in the stop price would be caused by precision rounding on the exchange, i.e. <code>rounded(stop_price) &lt;= rounded(stop_price * 0.99)</code>. The idea is to avoid coins with a value VERY close to their lower trading boundary, not allowing setting of proper stoploss.</p> <p>PrecisionFilter is pointless for futures trading</p> <p>The above does not apply to shorts. And for longs, in theory the trade will be liquidated first.</p> <p>Backtesting</p> <p><code>PrecisionFilter</code> does not support backtesting mode using multiple strategies.</p>"},{"location":"plugins/#pricefilter","title":"PriceFilter","text":"<p>The <code>PriceFilter</code> allows filtering of pairs by price. Currently the following price filters are supported:</p> <ul> <li><code>min_price</code></li> <li><code>max_price</code></li> <li><code>max_value</code></li> <li><code>low_price_ratio</code></li> </ul> <p>The <code>min_price</code> setting removes pairs where the price is below the specified price. This is useful if you wish to avoid trading very low-priced pairs. This option is disabled by default, and will only apply if set to &gt; 0.</p> <p>The <code>max_price</code> setting removes pairs where the price is above the specified price. This is useful if you wish to trade only low-priced pairs. This option is disabled by default, and will only apply if set to &gt; 0.</p> <p>The <code>max_value</code> setting removes pairs where the minimum value change is above a specified value. This is useful when an exchange has unbalanced limits. For example, if step-size = 1 (so you can only buy 1, or 2, or 3, but not 1.1 Coins) - and the price is pretty high (like 20$) as the coin has risen sharply since the last limit adaption. As a result of the above, you can only buy for 20$, or 40$ - but not for 25$. On exchanges that deduct fees from the receiving currency (e.g. binance) - this can result in high value coins / amounts that are unsellable as the amount is slightly below the limit.</p> <p>The <code>low_price_ratio</code> setting removes pairs where a raise of 1 price unit (pip) is above the <code>low_price_ratio</code> ratio. This option is disabled by default, and will only apply if set to &gt; 0.</p> <p>For <code>PriceFilter</code> at least one of its <code>min_price</code>, <code>max_price</code> or <code>low_price_ratio</code> settings must be applied.</p> <p>Calculation example:</p> <p>Min price precision for SHITCOIN/BTC is 8 decimals. If its price is 0.00000011 - one price step above would be 0.00000012, which is ~9% higher than the previous price value. You may filter out this pair by using PriceFilter with <code>low_price_ratio</code> set to 0.09 (9%) or with <code>min_price</code> set to 0.00000011, correspondingly.</p> <p>Low priced pairs</p> <p>Low priced pairs with high \"1 pip movements\" are dangerous since they are often illiquid and it may also be impossible to place the desired stoploss, which can often result in high losses since price needs to be rounded to the next tradable price - so instead of having a stoploss of -5%, you could end up with a stoploss of -9% simply due to price rounding.</p>"},{"location":"plugins/#shufflefilter","title":"ShuffleFilter","text":"<p>Shuffles (randomizes) pairs in the pairlist. It can be used for preventing the bot from trading some of the pairs more frequently then others when you want all pairs be treated with the same priority.</p> <p>By default, ShuffleFilter will shuffle pairs once per candle. To shuffle on every iteration, set <code>\"shuffle_frequency\"</code> to <code>\"iteration\"</code> instead of  the default of <code>\"candle\"</code>.</p> <pre><code>    {\n        \"method\": \"ShuffleFilter\", \n        \"shuffle_frequency\": \"candle\",\n        \"seed\": 42\n    }\n</code></pre> <p>Tip</p> <p>You may set the <code>seed</code> value for this Pairlist to obtain reproducible results, which can be useful for repeated backtesting sessions. If <code>seed</code> is not set, the pairs are shuffled in the non-repeatable random order. ShuffleFilter will automatically detect runmodes and apply the <code>seed</code> only for backtesting modes - if a <code>seed</code> value is set.</p>"},{"location":"plugins/#spreadfilter","title":"SpreadFilter","text":"<p>Removes pairs that have a difference between asks and bids above the specified ratio, <code>max_spread_ratio</code> (defaults to <code>0.005</code>).</p> <p>Example:</p> <p>If <code>DOGE/BTC</code> maximum bid is 0.00000026 and minimum ask is 0.00000027, the ratio is calculated as: <code>1 - bid/ask ~= 0.037</code> which is <code>&gt; 0.005</code> and this pair will be filtered out.</p>"},{"location":"plugins/#rangestabilityfilter","title":"RangeStabilityFilter","text":"<p>Removes pairs where the difference between lowest low and highest high over <code>lookback_days</code> days is below <code>min_rate_of_change</code> or above <code>max_rate_of_change</code>. Since this is a filter that requires additional data, the results are cached for <code>refresh_period</code>.</p> <p>In the below example: If the trading range over the last 10 days is &lt;1% or &gt;99%, remove the pair from the whitelist.</p> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"RangeStabilityFilter\",\n        \"lookback_days\": 10,\n        \"min_rate_of_change\": 0.01,\n        \"max_rate_of_change\": 0.99,\n        \"refresh_period\": 86400\n    }\n]\n</code></pre> <p>Adding <code>\"sort_direction\": \"asc\"</code> or <code>\"sort_direction\": \"desc\"</code> enables sorting for this pairlist.</p> <p>Tip</p> <p>This Filter can be used to automatically remove stable coin pairs, which have a very low trading range, and are therefore extremely difficult to trade with profit. Additionally, it can also be used to automatically remove pairs with extreme high/low variance over a given amount of time.</p>"},{"location":"plugins/#volatilityfilter","title":"VolatilityFilter","text":"<p>Volatility is the degree of historical variation of a pairs over time, it is measured by the standard deviation of logarithmic daily returns. Returns are assumed to be normally distributed, although actual distribution might be different. In a normal distribution, 68% of observations fall within one standard deviation and 95% of observations fall within two standard deviations. Assuming a volatility of 0.05 means that the expected returns for 20 out of 30 days is expected to be less than 5% (one standard deviation). Volatility is a positive ratio of the expected deviation of return and can be greater than 1.00. Please refer to the wikipedia definition of <code>volatility</code>.</p> <p>This filter removes pairs if the average volatility over a <code>lookback_days</code> days is below <code>min_volatility</code> or above <code>max_volatility</code>. Since this is a filter that requires additional data, the results are cached for <code>refresh_period</code>.</p> <p>This filter can be used to narrow down your pairs to a certain volatility or avoid very volatile pairs.</p> <p>In the below example: If the volatility over the last 10 days is not in the range of 0.05-0.50, remove the pair from the whitelist. The filter is applied every 24h.</p> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"VolatilityFilter\",\n        \"lookback_days\": 10,\n        \"min_volatility\": 0.05,\n        \"max_volatility\": 0.50,\n        \"refresh_period\": 86400\n    }\n]\n</code></pre> <p>Adding <code>\"sort_direction\": \"asc\"</code> or <code>\"sort_direction\": \"desc\"</code> enables sorting mode for this pairlist.</p>"},{"location":"plugins/#full-example-of-pairlist-handlers","title":"Full example of Pairlist Handlers","text":"<p>The below example blacklists <code>BNB/BTC</code>, uses <code>VolumePairList</code> with <code>20</code> assets, sorting pairs by <code>quoteVolume</code> and applies <code>PrecisionFilter</code> and <code>PriceFilter</code>, filtering all assets where 1 price unit is &gt; 1%. Then the <code>SpreadFilter</code> and <code>VolatilityFilter</code> is applied and pairs are finally shuffled with the random seed set to some predefined value.</p> <pre><code>\"exchange\": {\n    \"pair_whitelist\": [],\n    \"pair_blacklist\": [\"BNB/BTC\"]\n},\n\"pairlists\": [\n    {\n        \"method\": \"VolumePairList\",\n        \"number_assets\": 20,\n        \"sort_key\": \"quoteVolume\"\n    },\n    {\"method\": \"AgeFilter\", \"min_days_listed\": 10},\n    {\"method\": \"PrecisionFilter\"},\n    {\"method\": \"PriceFilter\", \"low_price_ratio\": 0.01},\n    {\"method\": \"SpreadFilter\", \"max_spread_ratio\": 0.005},\n    {\n        \"method\": \"RangeStabilityFilter\",\n        \"lookback_days\": 10,\n        \"min_rate_of_change\": 0.01,\n        \"refresh_period\": 86400\n    },\n    {\n        \"method\": \"VolatilityFilter\",\n        \"lookback_days\": 10,\n        \"min_volatility\": 0.05,\n        \"max_volatility\": 0.50,\n        \"refresh_period\": 86400\n    },\n    {\"method\": \"ShuffleFilter\", \"seed\": 42}\n],\n</code></pre>"},{"location":"plugins/#protections","title":"Protections","text":"<p>Beta feature</p> <p>This feature is still in it's testing phase. Should you notice something you think is wrong please let us know via Discord or via Github Issue.</p> <p>Protections will protect your strategy from unexpected events and market conditions by temporarily stop trading for either one pair, or for all pairs. All protection end times are rounded up to the next candle to avoid sudden, unexpected intra-candle buys.</p> <p>Note</p> <p>Not all Protections will work for all strategies, and parameters will need to be tuned for your strategy to improve performance.  </p> <p>Tip</p> <p>Each Protection can be configured multiple times with different parameters, to allow different levels of protection (short-term / long-term).</p> <p>Backtesting</p> <p>Protections are supported by backtesting and hyperopt, but must be explicitly enabled by using the <code>--enable-protections</code> flag.</p> <p>Setting protections from the configuration</p> <p>Setting protections from the configuration via <code>\"protections\": [],</code> key should be considered deprecated and will be removed in a future version. It is also no longer guaranteed that your protections apply to the strategy in cases where the strategy defines protections as property.</p>"},{"location":"plugins/#available-protections","title":"Available Protections","text":"<ul> <li><code>StoplossGuard</code> Stop trading if a certain amount of stoploss occurred within a certain time window.</li> <li><code>MaxDrawdown</code> Stop trading if max-drawdown is reached.</li> <li><code>LowProfitPairs</code> Lock pairs with low profits</li> <li><code>CooldownPeriod</code> Don't enter a trade right after selling a trade.</li> </ul>"},{"location":"plugins/#common-settings-to-all-protections","title":"Common settings to all Protections","text":"Parameter Description <code>method</code> Protection name to use.  Datatype: String, selected from available Protections <code>stop_duration_candles</code> For how many candles should the lock be set?  Datatype: Positive integer (in candles) <code>stop_duration</code> how many minutes should protections be locked. Cannot be used together with <code>stop_duration_candles</code>.  Datatype: Float (in minutes) <code>lookback_period_candles</code> Only trades that completed within the last <code>lookback_period_candles</code> candles will be considered. This setting may be ignored by some Protections.  Datatype: Positive integer (in candles). <code>lookback_period</code> Only trades that completed after <code>current_time - lookback_period</code> will be considered. Cannot be used together with <code>lookback_period_candles</code>. This setting may be ignored by some Protections.  Datatype:  Float (in minutes) <code>trade_limit</code> Number of trades required at minimum (not used by all Protections).  Datatype: Positive integer <p>Durations</p> <p>Durations (<code>stop_duration*</code> and <code>lookback_period*</code> can be defined in either minutes or candles). For more flexibility when testing different timeframes, all below examples will use the \"candle\" definition.</p>"},{"location":"plugins/#stoploss-guard","title":"Stoploss Guard","text":"<p><code>StoplossGuard</code> selects all trades within <code>lookback_period</code> in minutes (or in candles when using <code>lookback_period_candles</code>). If <code>trade_limit</code> or more trades resulted in stoploss, trading will stop for <code>stop_duration</code> in minutes (or in candles when using <code>stop_duration_candles</code>).</p> <p>This applies across all pairs, unless <code>only_per_pair</code> is set to true, which will then only look at one pair at a time.</p> <p>Similarly, this protection will by default look at all trades (long and short). For futures bots, setting <code>only_per_side</code> will make the bot only consider one side, and will then only lock this one side, allowing for example shorts to continue after a series of long stoplosses.</p> <p><code>required_profit</code> will determine the required relative profit (or loss) for stoplosses to consider. This should normally not be set and defaults to 0.0 - which means all losing stoplosses will be triggering a block.</p> <p>The below example stops trading for all pairs for 4 candles after the last trade if the bot hit stoploss 4 times within the last 24 candles.</p> <pre><code>@property\ndef protections(self):\n    return [\n        {\n            \"method\": \"StoplossGuard\",\n            \"lookback_period_candles\": 24,\n            \"trade_limit\": 4,\n            \"stop_duration_candles\": 4,\n            \"required_profit\": 0.0,\n            \"only_per_pair\": False,\n            \"only_per_side\": False\n        }\n    ]\n</code></pre> <p>Note</p> <p><code>StoplossGuard</code> considers all trades with the results <code>\"stop_loss\"</code>, <code>\"stoploss_on_exchange\"</code> and <code>\"trailing_stop_loss\"</code> if the resulting profit was negative. <code>trade_limit</code> and <code>lookback_period</code> will need to be tuned for your strategy.</p>"},{"location":"plugins/#maxdrawdown","title":"MaxDrawdown","text":"<p><code>MaxDrawdown</code> uses all trades within <code>lookback_period</code> in minutes (or in candles when using <code>lookback_period_candles</code>) to determine the maximum drawdown. If the drawdown is below <code>max_allowed_drawdown</code>, trading will stop for <code>stop_duration</code> in minutes (or in candles when using <code>stop_duration_candles</code>) after the last trade - assuming that the bot needs some time to let markets recover.</p> <p>The below sample stops trading for 12 candles if max-drawdown is &gt; 20% considering all pairs - with a minimum of <code>trade_limit</code> trades - within the last 48 candles. If desired, <code>lookback_period</code> and/or <code>stop_duration</code> can be used.</p> <pre><code>@property\ndef protections(self):\n    return  [\n        {\n            \"method\": \"MaxDrawdown\",\n            \"lookback_period_candles\": 48,\n            \"trade_limit\": 20,\n            \"stop_duration_candles\": 12,\n            \"max_allowed_drawdown\": 0.2\n        },\n    ]\n</code></pre>"},{"location":"plugins/#low-profit-pairs","title":"Low Profit Pairs","text":"<p><code>LowProfitPairs</code> uses all trades for a pair within <code>lookback_period</code> in minutes (or in candles when using <code>lookback_period_candles</code>) to determine the overall profit ratio. If that ratio is below <code>required_profit</code>, that pair will be locked for <code>stop_duration</code> in minutes (or in candles when using <code>stop_duration_candles</code>).</p> <p>For futures bots, setting <code>only_per_side</code> will make the bot only consider one side, and will then only lock this one side, allowing for example shorts to continue after a series of long losses.</p> <p>The below example will stop trading a pair for 60 minutes if the pair does not have a required profit of 2% (and a minimum of 2 trades) within the last 6 candles.</p> <pre><code>@property\ndef protections(self):\n    return [\n        {\n            \"method\": \"LowProfitPairs\",\n            \"lookback_period_candles\": 6,\n            \"trade_limit\": 2,\n            \"stop_duration\": 60,\n            \"required_profit\": 0.02,\n            \"only_per_pair\": False,\n        }\n    ]\n</code></pre>"},{"location":"plugins/#cooldown-period","title":"Cooldown Period","text":"<p><code>CooldownPeriod</code> locks a pair for <code>stop_duration</code> in minutes (or in candles when using <code>stop_duration_candles</code>) after selling, avoiding a re-entry for this pair for <code>stop_duration</code> minutes.</p> <p>The below example will stop trading a pair for 2 candles after closing a trade, allowing this pair to \"cool down\".</p> <pre><code>@property\ndef protections(self):\n    return  [\n        {\n            \"method\": \"CooldownPeriod\",\n            \"stop_duration_candles\": 2\n        }\n    ]\n</code></pre> <p>Note</p> <p>This Protection applies only at pair-level, and will never lock all pairs globally. This Protection does not consider <code>lookback_period</code> as it only looks at the latest trade.</p>"},{"location":"plugins/#full-example-of-protections","title":"Full example of Protections","text":"<p>All protections can be combined at will, also with different parameters, creating a increasing wall for under-performing pairs. All protections are evaluated in the sequence they are defined.</p> <p>The below example assumes a timeframe of 1 hour:</p> <ul> <li>Locks each pair after selling for an additional 5 candles (<code>CooldownPeriod</code>), giving other pairs a chance to get filled.</li> <li>Stops trading for 4 hours (<code>4 * 1h candles</code>) if the last 2 days (<code>48 * 1h candles</code>) had 20 trades, which caused a max-drawdown of more than 20%. (<code>MaxDrawdown</code>).</li> <li>Stops trading if more than 4 stoploss occur for all pairs within a 1 day (<code>24 * 1h candles</code>) limit (<code>StoplossGuard</code>).</li> <li>Locks all pairs that had 2 Trades within the last 6 hours (<code>6 * 1h candles</code>) with a combined profit ratio of below 0.02 (&lt;2%) (<code>LowProfitPairs</code>).</li> <li>Locks all pairs for 2 candles that had a profit of below 0.01 (&lt;1%) within the last 24h (<code>24 * 1h candles</code>), a minimum of 4 trades.</li> </ul> <pre><code>from freqtrade.strategy import IStrategy\n\nclass AwesomeStrategy(IStrategy)\n    timeframe = '1h'\n\n    @property\n    def protections(self):\n        return [\n            {\n                \"method\": \"CooldownPeriod\",\n                \"stop_duration_candles\": 5\n            },\n            {\n                \"method\": \"MaxDrawdown\",\n                \"lookback_period_candles\": 48,\n                \"trade_limit\": 20,\n                \"stop_duration_candles\": 4,\n                \"max_allowed_drawdown\": 0.2\n            },\n            {\n                \"method\": \"StoplossGuard\",\n                \"lookback_period_candles\": 24,\n                \"trade_limit\": 4,\n                \"stop_duration_candles\": 2,\n                \"only_per_pair\": False\n            },\n            {\n                \"method\": \"LowProfitPairs\",\n                \"lookback_period_candles\": 6,\n                \"trade_limit\": 2,\n                \"stop_duration_candles\": 60,\n                \"required_profit\": 0.02\n            },\n            {\n                \"method\": \"LowProfitPairs\",\n                \"lookback_period_candles\": 24,\n                \"trade_limit\": 4,\n                \"stop_duration_candles\": 2,\n                \"required_profit\": 0.01\n            }\n        ]\n    # ...\n</code></pre>"},{"location":"producer-consumer/","title":"Producer / Consumer mode","text":"<p>freqtrade provides a mechanism whereby an instance (also called <code>consumer</code>) may listen to messages from an upstream freqtrade instance (also called <code>producer</code>) using the message websocket. Mainly, <code>analyzed_df</code> and <code>whitelist</code> messages. This allows the reuse of computed indicators (and signals) for pairs in multiple bots without needing to compute them multiple times.</p> <p>See Message Websocket in the Rest API docs for setting up the <code>api_server</code> configuration for your message websocket (this will be your producer).</p> <p>Note</p> <p>We strongly recommend to set <code>ws_token</code> to something random and known only to yourself to avoid unauthorized access to your bot.</p>"},{"location":"producer-consumer/#configuration","title":"Configuration","text":"<p>Enable subscribing to an instance by adding the <code>external_message_consumer</code> section to the consumer's config file.</p> <pre><code>{\n    //...\n   \"external_message_consumer\": {\n        \"enabled\": true,\n        \"producers\": [\n            {\n                \"name\": \"default\", // This can be any name you'd like, default is \"default\"\n                \"host\": \"127.0.0.1\", // The host from your producer's api_server config\n                \"port\": 8080, // The port from your producer's api_server config\n                \"secure\": false, // Use a secure websockets connection, default false\n                \"ws_token\": \"sercet_Ws_t0ken\" // The ws_token from your producer's api_server config\n            }\n        ],\n        // The following configurations are optional, and usually not required\n        // \"wait_timeout\": 300,\n        // \"ping_timeout\": 10,\n        // \"sleep_time\": 10,\n        // \"remove_entry_exit_signals\": false,\n        // \"message_size_limit\": 8\n    }\n    //...\n}\n</code></pre> Parameter Description <code>enabled</code> Required. Enable consumer mode. If set to false, all other settings in this section are ignored.Defaults to <code>false</code>. Datatype: boolean . <code>producers</code> Required. List of producers  Datatype: Array. <code>producers.name</code> Required. Name of this producer. This name must be used in calls to <code>get_producer_pairs()</code> and <code>get_producer_df()</code> if more than one producer is used. Datatype: string <code>producers.host</code> Required. The hostname or IP address from your producer. Datatype: string <code>producers.port</code> Required. The port matching the above host.Defaults to <code>8080</code>. Datatype: Integer <code>producers.secure</code> Optional.  Use ssl in websockets connection. Default False. Datatype: string <code>producers.ws_token</code> Required. <code>ws_token</code> as configured on the producer. Datatype: string Optional settings <code>wait_timeout</code> Timeout until we ping again if no message is received. Defaults to <code>300</code>. Datatype: Integer - in seconds. <code>ping_timeout</code> Ping timeout Defaults to <code>10</code>. Datatype: Integer - in seconds. <code>sleep_time</code> Sleep time before retrying to connect.Defaults to <code>10</code>. Datatype: Integer - in seconds. <code>remove_entry_exit_signals</code> Remove signal columns from the dataframe (set them to 0) on dataframe receipt.Defaults to <code>false</code>. Datatype: Boolean. <code>message_size_limit</code> Size limit per messageDefaults to <code>8</code>. Datatype: Integer - Megabytes. <p>Instead of (or as well as) calculating indicators in <code>populate_indicators()</code> the follower instance listens on the connection to a producer instance's messages (or multiple producer instances in advanced configurations) and requests the producer's most recently analyzed dataframes for each pair in the active whitelist.</p> <p>A consumer instance will then have a full copy of the analyzed dataframes without the need to calculate them itself.</p>"},{"location":"producer-consumer/#examples","title":"Examples","text":""},{"location":"producer-consumer/#example-producer-strategy","title":"Example - Producer Strategy","text":"<p>A simple strategy with multiple indicators. No special considerations are required in the strategy itself.</p> <pre><code>class ProducerStrategy(IStrategy):\n    #...\n    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        \"\"\"\n        Calculate indicators in the standard freqtrade way which can then be broadcast to other instances\n        \"\"\"\n        dataframe['rsi'] = ta.RSI(dataframe)\n        bollinger = qtpylib.bollinger_bands(qtpylib.typical_price(dataframe), window=20, stds=2)\n        dataframe['bb_lowerband'] = bollinger['lower']\n        dataframe['bb_middleband'] = bollinger['mid']\n        dataframe['bb_upperband'] = bollinger['upper']\n        dataframe['tema'] = ta.TEMA(dataframe, timeperiod=9)\n\n        return dataframe\n\n    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        \"\"\"\n        Populates the entry signal for the given dataframe\n        \"\"\"\n        dataframe.loc[\n            (\n                (qtpylib.crossed_above(dataframe['rsi'], self.buy_rsi.value)) &amp;\n                (dataframe['tema'] &lt;= dataframe['bb_middleband']) &amp;\n                (dataframe['tema'] &gt; dataframe['tema'].shift(1)) &amp;\n                (dataframe['volume'] &gt; 0)\n            ),\n            'enter_long'] = 1\n\n        return dataframe\n</code></pre> <p>FreqAI</p> <p>You can use this to setup FreqAI on a powerful machine, while you run consumers on simple machines like raspberries, which can interpret the signals generated from the producer in different ways.</p>"},{"location":"producer-consumer/#example-consumer-strategy","title":"Example - Consumer Strategy","text":"<p>A logically equivalent strategy which calculates no indicators itself, but will have the same analyzed dataframes available to make trading decisions based on the indicators calculated in the producer. In this example the consumer has the same entry criteria, however this is not necessary. The consumer may use different logic to enter/exit trades, and only use the indicators as specified.</p> <pre><code>class ConsumerStrategy(IStrategy):\n    #...\n    process_only_new_candles = False # required for consumers\n\n    _columns_to_expect = ['rsi_default', 'tema_default', 'bb_middleband_default']\n\n    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        \"\"\"\n        Use the websocket api to get pre-populated indicators from another freqtrade instance.\n        Use `self.dp.get_producer_df(pair)` to get the dataframe\n        \"\"\"\n        pair = metadata['pair']\n        timeframe = self.timeframe\n\n        producer_pairs = self.dp.get_producer_pairs()\n        # You can specify which producer to get pairs from via:\n        # self.dp.get_producer_pairs(\"my_other_producer\")\n\n        # This func returns the analyzed dataframe, and when it was analyzed\n        producer_dataframe, _ = self.dp.get_producer_df(pair)\n        # You can get other data if the producer makes it available:\n        # self.dp.get_producer_df(\n        #   pair,\n        #   timeframe=\"1h\",\n        #   candle_type=CandleType.SPOT,\n        #   producer_name=\"my_other_producer\"\n        # )\n\n        if not producer_dataframe.empty:\n            # If you plan on passing the producer's entry/exit signal directly,\n            # specify ffill=False or it will have unintended results\n            merged_dataframe = merge_informative_pair(dataframe, producer_dataframe,\n                                                      timeframe, timeframe,\n                                                      append_timeframe=False,\n                                                      suffix=\"default\")\n            return merged_dataframe\n        else:\n            dataframe[self._columns_to_expect] = 0\n\n        return dataframe\n\n    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        \"\"\"\n        Populates the entry signal for the given dataframe\n        \"\"\"\n        # Use the dataframe columns as if we calculated them ourselves\n        dataframe.loc[\n            (\n                (qtpylib.crossed_above(dataframe['rsi_default'], self.buy_rsi.value)) &amp;\n                (dataframe['tema_default'] &lt;= dataframe['bb_middleband_default']) &amp;\n                (dataframe['tema_default'] &gt; dataframe['tema_default'].shift(1)) &amp;\n                (dataframe['volume'] &gt; 0)\n            ),\n            'enter_long'] = 1\n\n        return dataframe\n</code></pre> <p>Using upstream signals</p> <p>By setting <code>remove_entry_exit_signals=false</code>, you can also use the producer's signals directly. They should be available as <code>enter_long_default</code> (assuming <code>suffix=\"default\"</code> was used) - and can be used as either signal directly, or as additional indicator.</p>"},{"location":"recursive-analysis/","title":"Recursive analysis","text":"<p>This page explains how to validate your strategy for inaccuracies due to recursive issues with certain indicators.</p> <p>A recursive formula defines any term of a sequence relative to its preceding term(s). An example of a recursive formula is a<sub>n</sub> = a<sub>n-1</sub> + b.</p> <p>Why does this matter for Freqtrade? In backtesting, the bot will get full data of the pairs according to the timerange specified. But in a dry/live run, the bot will be limited by the amount of data each exchanges gives.</p> <p>For example, to calculate a very basic indicator called <code>steps</code>, the first row's value is always 0, while the following rows' values are equal to the value of the previous row plus 1. If I were to calculate it using the latest 1000 candles, then the <code>steps</code> value of the first row is 0, and the <code>steps</code> value at the last closed candle is 999.</p> <p>What happens if the calculation is using only the latest 500 candles? Then instead of 999, the <code>steps</code> value at last closed candle is 499. The difference of the value means your backtest result can differ from your dry/live run result.</p> <p>The <code>recursive-analysis</code> command requires historic data to be available. To learn how to get data for the pairs and exchange you're interested in, head over to the Data Downloading section of the documentation.</p> <p>This command is built upon preparing different lengths of data and calculates indicators based on them. This does not backtest the strategy itself, but rather only calculates the indicators. After calculating the indicators of different startup candle values (<code>startup_candle_count</code>) are done, the values of last rows across all specified <code>startup_candle_count</code> are compared to see how much variance they show compared to the base calculation.</p> <p>Command settings:</p> <ul> <li>Use the <code>-p</code> option to set your desired pair to analyze. Since we are only looking at indicator values, using more than one pair is redundant. Preferably use a pair with a relatively high price and at least moderate volatility, such as BTC or ETH, to avoid rounding issues that can make the results inaccurate. If no pair is set on the command, the pair used for this analysis is the first pair in the whitelist.</li> <li>It is recommended to set a long timerange (at least 5000 candles) so that the initial indicators' calculation that is going to be used as a benchmark has very small or no recursive issues itself. For example, for a 5m timeframe, a timerange of 5000 candles would be equal to 18 days.</li> <li><code>--cache</code> is forced to \"none\" to avoid loading previous indicators calculation automatically.</li> </ul> <p>In addition to the recursive formula check, this command also carries out a simple lookahead bias check on the indicator values only. For a full lookahead check, use Lookahead-analysis.</p>"},{"location":"recursive-analysis/#recursive-analysis-command-reference","title":"Recursive-analysis command reference","text":"<pre><code>usage: freqtrade recursive-analysis [-h] [-v] [--logfile FILE] [-V] [-c PATH]\n                                    [-d PATH] [--userdir PATH] [-s NAME]\n                                    [--strategy-path PATH]\n                                    [--recursive-strategy-search]\n                                    [--freqaimodel NAME]\n                                    [--freqaimodel-path PATH] [-i TIMEFRAME]\n                                    [--timerange TIMERANGE]\n                                    [--data-format-ohlcv {json,jsongz,hdf5,feather,parquet}]\n                                    [-p PAIR]\n                                    [--freqai-backtest-live-models]\n                                    [--startup-candle STARTUP_CANDLES [STARTUP_CANDLES ...]]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -i TIMEFRAME, --timeframe TIMEFRAME\n                        Specify timeframe (`1m`, `5m`, `30m`, `1h`, `1d`).\n  --data-format-ohlcv {json,jsongz,hdf5,feather,parquet}\n                        Storage format for downloaded candle (OHLCV) data.\n                        (default: `feather`).\n  -p PAIR, --pairs PAIR\n                        Limit command to this pair.\n  --startup-candle STARTUP_CANDLE [STARTUP_CANDLE ...]\n                        Provide a space-separated list of startup_candle_count to\n                        be checked. Default : `199 399 499 999 1999`.\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n\nStrategy arguments:\n  -s NAME, --strategy NAME\n                        Specify strategy class name which will be used by the\n                        bot.\n  --strategy-path PATH  Specify additional strategy lookup path.\n  --timerange TIMERANGE\n                        Specify what timerange of data to use.\n</code></pre>"},{"location":"recursive-analysis/#why-are-odd-numbered-default-startup-candles-used","title":"Why are odd-numbered default startup candles used?","text":"<p>The default value for startup candles are odd numbers. When the bot fetches candle data from the exchange's API, the last candle is the one being checked by the bot and the rest of the data are the \"startup candles\".</p> <p>For example, Binance allows 1000 candles per API call. When the bot receives 1000 candles, the last candle is the \"current candle\", and the preceding 999 candles are the \"startup candles\". By setting the startup candle count as 1000 instead of 999, the bot will try to fetch 1001 candles instead. The exchange API will then send candle data in a paginated form, i.e. in case of the Binance API, this will be two groups- one of length 1000 and another of length 1. This results in the bot thinking the strategy needs 1001 candles of data, and so it will download 2000 candles worth of data instead, which means there will be 1 \"current candle\" and 1999 \"startup candles\".</p> <p>Furthermore, exchanges limit the number of consecutive bulk API calls, e.g. Binance allows 5 calls. In this case, only 5000 candles can be downloaded from Binance API without hitting the API rate limit, which means the max <code>startup_candle_count</code> you can have is 4999.</p> <p>Please note that this candle limit may be changed in the future by the exchanges without any prior notice.</p>"},{"location":"recursive-analysis/#how-does-the-command-work","title":"How does the command work?","text":"<ul> <li>Firstly an initial indicator calculation is carried out using the supplied timerange to generate a benchmark for indicator values.</li> <li>After setting the benchmark it will then carry out additional runs for each of the different startup candle count values.</li> <li>The command will then compare the indicator values at the last candle rows and report the differences in a table.</li> </ul>"},{"location":"recursive-analysis/#understanding-the-recursive-analysis-output","title":"Understanding the recursive-analysis output","text":"<p>This is an example of an output results table where at least one indicator has a recursive formula issue:</p> <pre><code>| indicators   | 20      | 40      | 80     | 100    | 150     | 300     | 999    |\n|--------------+---------+---------+--------+--------+---------+---------+--------|\n| rsi_30       | nan%    | -6.025% | 0.612% | 0.828% | -0.140% | 0.000%  | 0.000% |\n| rsi_14       | 24.141% | -0.876% | 0.070% | 0.007% | -0.000% | -0.000% | -      |\n</code></pre> <p>The column headers indicate the different <code>startup_candle_count</code> used in the analysis. The values in the table indicate the variance of the calculated indicators compared to the benchmark value.</p> <p><code>nan%</code> means the value of that indicator cannot be calculated due to lack of data. In this example, you cannot calculate RSI with length 30 with just 21 candles (1 current candle + 20 startup candles).</p> <p>Users should assess the table per indicator to decide if the specified <code>startup_candle_count</code> results in a sufficiently small variance so that the indicator does not have any effect on entries and/or exits.</p> <p>As such, aiming for absolute zero variance (shown by <code>-</code> value) might not be the best option, because some indicators might require you to use such a long <code>startup_candle_count</code> to have zero variance.</p>"},{"location":"recursive-analysis/#caveats","title":"Caveats","text":"<ul> <li><code>recursive-analysis</code> will only calculate and compare the indicator values at the last row. The output table reports the percentage differences between the different startup candle count calculations and the original benchmark calculation. Whether it has any actual impact on your entries and exits is not included.</li> <li>The ideal scenario is that indicators will have no variance (or at least very close to 0%) despite the startup candle being varied. In reality, indicators such as EMA are using a recursive formula to calculate indicator values, so the goal is not necessarily to have zero percentage variance, but to have the variance low enough (and therefore <code>startup_candle_count</code> high enough) that the recursion inherent in the indicator will not have any real impact on trading decisions.</li> <li><code>recursive-analysis</code> will only run calculations on <code>populate_indicators</code> and <code>@informative</code> decorator(s). If you put any indicator calculation on <code>populate_entry_trend</code> or <code>populate_exit_trend</code>, it won't be calculated.</li> </ul>"},{"location":"rest-api/","title":"REST API","text":""},{"location":"rest-api/#frequi","title":"FreqUI","text":"<p>FreqUI now has it's own dedicated documentation section - please refer to that section for all information regarding the FreqUI.</p>"},{"location":"rest-api/#configuration","title":"Configuration","text":"<p>Enable the rest API by adding the api_server section to your configuration and setting <code>api_server.enabled</code> to <code>true</code>.</p> <p>Sample configuration:</p> <pre><code>    \"api_server\": {\n        \"enabled\": true,\n        \"listen_ip_address\": \"127.0.0.1\",\n        \"listen_port\": 8080,\n        \"verbosity\": \"error\",\n        \"enable_openapi\": false,\n        \"jwt_secret_key\": \"somethingrandom\",\n        \"CORS_origins\": [],\n        \"username\": \"Freqtrader\",\n        \"password\": \"SuperSecret1!\",\n        \"ws_token\": \"sercet_Ws_t0ken\"\n    },\n</code></pre> <p>Security warning</p> <p>By default, the configuration listens on localhost only (so it's not reachable from other systems). We strongly recommend to not expose this API to the internet and choose a strong, unique password, since others will potentially be able to control your bot.</p> API/UI Access on a remote servers <p>If you're running on a VPS, you should consider using either a ssh tunnel, or setup a VPN (openVPN, wireguard) to connect to your bot. This will ensure that freqUI is not directly exposed to the internet, which is not recommended for security reasons (freqUI does not support https out of the box). Setup of these tools is not part of this tutorial, however many good tutorials can be found on the internet.</p> <p>You can then access the API by going to <code>http://127.0.0.1:8080/api/v1/ping</code> in a browser to check if the API is running correctly. This should return the response:</p> <pre><code>{\"status\":\"pong\"}\n</code></pre> <p>All other endpoints return sensitive info and require authentication and are therefore not available through a web browser.</p>"},{"location":"rest-api/#security","title":"Security","text":"<p>To generate a secure password, best use a password manager, or use the below code.</p> <pre><code>import secrets\nsecrets.token_hex()\n</code></pre> <p>JWT token</p> <p>Use the same method to also generate a JWT secret key (<code>jwt_secret_key</code>).</p> <p>Password selection</p> <p>Please make sure to select a very strong, unique password to protect your bot from unauthorized access. Also change <code>jwt_secret_key</code> to something random (no need to remember this, but it'll be used to encrypt your session, so it better be something unique!).</p>"},{"location":"rest-api/#configuration-with-docker","title":"Configuration with docker","text":"<p>If you run your bot using docker, you'll need to have the bot listen to incoming connections. The security is then handled by docker.</p> <pre><code>    \"api_server\": {\n        \"enabled\": true,\n        \"listen_ip_address\": \"0.0.0.0\",\n        \"listen_port\": 8080,\n        \"username\": \"Freqtrader\",\n        \"password\": \"SuperSecret1!\",\n        //...\n    },\n</code></pre> <p>Make sure that the following 2 lines are available in your docker-compose file:</p> <pre><code>    ports:\n      - \"127.0.0.1:8080:8080\"\n</code></pre> <p>Security warning</p> <p>By using <code>\"8080:8080\"</code> (or <code>\"0.0.0.0:8080:8080\"</code>) in the docker port mapping, the API will be available to everyone connecting to the server under the correct port, so others may be able to control your bot. This may be safe if you're running the bot in a secure environment (like your home network), but it's not recommended to expose the API to the internet.</p>"},{"location":"rest-api/#rest-api_1","title":"Rest API","text":""},{"location":"rest-api/#consuming-the-api","title":"Consuming the API","text":"<p>You can consume the API by using <code>freqtrade-client</code> (also available as <code>scripts/rest_client.py</code>). This command can be installed independent of the bot by using <code>pip install freqtrade-client</code>.</p> <p>This module is designed to be lightweight, and only depends on the <code>requests</code> and <code>python-rapidjson</code> modules, skipping all heavy dependencies freqtrade otherwise needs.</p> <pre><code>freqtrade-client &lt;command&gt; [optional parameters]\n</code></pre> <p>By default, the script assumes <code>127.0.0.1</code> (localhost) and port <code>8080</code> to be used, however you can specify a configuration file to override this behaviour.</p>"},{"location":"rest-api/#minimalistic-client-config","title":"Minimalistic client config","text":"<pre><code>{\n    \"api_server\": {\n        \"enabled\": true,\n        \"listen_ip_address\": \"0.0.0.0\",\n        \"listen_port\": 8080,\n        \"username\": \"Freqtrader\",\n        \"password\": \"SuperSecret1!\",\n        //...\n    }\n}\n</code></pre> <pre><code>freqtrade-client --config rest_config.json &lt;command&gt; [optional parameters]\n</code></pre> <p>Commands with many arguments may require keyword arguments (for clarity) - which can be provided as follows:</p> <pre><code>freqtrade-client --config rest_config.json forceenter BTC/USDT long enter_tag=GutFeeling\n</code></pre> <p>This method will work for all arguments - check the \"show\" command for a list of available parameters.</p> Programmatic use <p>The <code>freqtrade-client</code> package (installable independent of freqtrade) can be used in your own scripts to interact with the freqtrade API. to do so, please use the following:</p> <pre><code>from freqtrade_client import FtRestClient\n\n\nclient = FtRestClient(server_url, username, password)\n\n# Get the status of the bot\nping = client.ping()\nprint(ping)\n# ... \n</code></pre> <p>For a full list of available commands, please refer to the list below.</p>"},{"location":"rest-api/#available-endpoints","title":"Available endpoints","text":"Command Description <code>ping</code> Simple command testing the API Readiness - requires no authentication. <code>start</code> Starts the trader. <code>stop</code> Stops the trader. <code>stopbuy</code> Stops the trader from opening new trades. Gracefully closes open trades according to their rules. <code>reload_config</code> Reloads the configuration file. <code>trades</code> List last trades. Limited to 500 trades per call. <code>trade/&lt;tradeid&gt;</code> Get specific trade. <code>trades/&lt;tradeid&gt;</code> DELETE - Remove trade from the database. Tries to close open orders. Requires manual handling of this trade on the exchange. <code>trades/&lt;tradeid&gt;/open-order</code> DELETE - Cancel open order for this trade. <code>trades/&lt;tradeid&gt;/reload</code> GET - Reload a trade from the Exchange. Only works in live, and can potentially help recover a trade that was manually sold on the exchange. <code>show_config</code> Shows part of the current configuration with relevant settings to operation. <code>logs</code> Shows last log messages. <code>status</code> Lists all open trades. <code>count</code> Displays number of trades used and available. <code>entries [pair]</code> Shows profit statistics for each enter tags for given pair (or all pairs if pair isn't given). Pair is optional. <code>exits [pair]</code> Shows profit statistics for each exit reasons for given pair (or all pairs if pair isn't given). Pair is optional. <code>mix_tags [pair]</code> Shows profit statistics for each combinations of enter tag + exit reasons for given pair (or all pairs if pair isn't given). Pair is optional. <code>locks</code> Displays currently locked pairs. <code>delete_lock &lt;lock_id&gt;</code> Deletes (disables) the lock by id. <code>locks add &lt;pair&gt;, &lt;until&gt;, [side], [reason]</code> Locks a pair until \"until\". (Until will be rounded up to the nearest timeframe). <code>profit</code> Display a summary of your profit/loss from close trades and some stats about your performance. <code>forceexit &lt;trade_id&gt; [order_type] [amount]</code> Instantly exits the given trade (ignoring <code>minimum_roi</code>), using the given order type (\"market\" or \"limit\", uses your config setting if not specified), and the chosen amount (full sell if not specified). <code>forceexit all</code> Instantly exits all open trades (Ignoring <code>minimum_roi</code>). <code>forceenter &lt;pair&gt; [rate]</code> Instantly enters the given pair. Rate is optional. (<code>force_entry_enable</code> must be set to True) <code>forceenter &lt;pair&gt; &lt;side&gt; [rate]</code> Instantly longs or shorts the given pair. Rate is optional. (<code>force_entry_enable</code> must be set to True) <code>performance</code> Show performance of each finished trade grouped by pair. <code>balance</code> Show account balance per currency. <code>daily &lt;n&gt;</code> Shows profit or loss per day, over the last n days (n defaults to 7). <code>weekly &lt;n&gt;</code> Shows profit or loss per week, over the last n days (n defaults to 4). <code>monthly &lt;n&gt;</code> Shows profit or loss per month, over the last n days (n defaults to 3). <code>stats</code> Display a summary of profit / loss reasons as well as average holding times. <code>whitelist</code> Show the current whitelist. <code>blacklist [pair]</code> Show the current blacklist, or adds a pair to the blacklist. <code>edge</code> Show validated pairs by Edge if it is enabled. <code>pair_candles</code> Returns dataframe for a pair / timeframe combination while the bot is running. Alpha <code>pair_history</code> Returns an analyzed dataframe for a given timerange, analyzed by a given strategy. Alpha <code>plot_config</code> Get plot config from the strategy (or nothing if not configured). Alpha <code>strategies</code> List strategies in strategy directory. Alpha <code>strategy &lt;strategy&gt;</code> Get specific Strategy content. Alpha <code>available_pairs</code> List available backtest data. Alpha <code>version</code> Show version. <code>sysinfo</code> Show information about the system load. <code>health</code> Show bot health (last bot loop). <p>Alpha status</p> <p>Endpoints labeled with Alpha status above may change at any time without notice.</p> <p>Possible commands can be listed from the rest-client script using the <code>help</code> command.</p> <pre><code>freqtrade-client help\n</code></pre> <pre><code>Possible commands:\n\navailable_pairs\n    Return available pair (backtest data) based on timeframe / stake_currency selection\n\n        :param timeframe: Only pairs with this timeframe available.\n        :param stake_currency: Only pairs that include this timeframe\n\nbalance\n    Get the account balance.\n\nblacklist\n    Show the current blacklist.\n\n        :param add: List of coins to add (example: \"BNB/BTC\")\n\ncancel_open_order\n    Cancel open order for trade.\n\n        :param trade_id: Cancels open orders for this trade.\n\ncount\n    Return the amount of open trades.\n\ndaily\n    Return the profits for each day, and amount of trades.\n\ndelete_lock\n    Delete (disable) lock from the database.\n\n        :param lock_id: ID for the lock to delete\n\ndelete_trade\n    Delete trade from the database.\n        Tries to close open orders. Requires manual handling of this asset on the exchange.\n\n        :param trade_id: Deletes the trade with this ID from the database.\n\nedge\n    Return information about edge.\n\nforcebuy\n    Buy an asset.\n\n        :param pair: Pair to buy (ETH/BTC)\n        :param price: Optional - price to buy\n\nforceenter\n    Force entering a trade\n\n        :param pair: Pair to buy (ETH/BTC)\n        :param side: 'long' or 'short'\n        :param price: Optional - price to buy\n\nforceexit\n    Force-exit a trade.\n\n        :param tradeid: Id of the trade (can be received via status command)\n        :param ordertype: Order type to use (must be market or limit)\n        :param amount: Amount to sell. Full sell if not given\n\nhealth\n    Provides a quick health check of the running bot.\n\nlocks\n    Return current locks\n\nlogs\n    Show latest logs.\n\n        :param limit: Limits log messages to the last &lt;limit&gt; logs. No limit to get the entire log.\n\npair_candles\n    Return live dataframe for &lt;pair&gt;&lt;timeframe&gt;.\n\n        :param pair: Pair to get data for\n        :param timeframe: Only pairs with this timeframe available.\n        :param limit: Limit result to the last n candles.\n\npair_history\n    Return historic, analyzed dataframe\n\n        :param pair: Pair to get data for\n        :param timeframe: Only pairs with this timeframe available.\n        :param strategy: Strategy to analyze and get values for\n        :param timerange: Timerange to get data for (same format than --timerange endpoints)\n\nperformance\n    Return the performance of the different coins.\n\nping\n    simple ping\n\nplot_config\n    Return plot configuration if the strategy defines one.\n\nprofit\n    Return the profit summary.\n\nreload_config\n    Reload configuration.\n\nshow_config\n        Returns part of the configuration, relevant for trading operations.\n\nstart\n    Start the bot if it's in the stopped state.\n\nstats\n    Return the stats report (durations, sell-reasons).\n\nstatus\n    Get the status of open trades.\n\nstop\n    Stop the bot. Use `start` to restart.\n\nstopbuy\n    Stop buying (but handle sells gracefully). Use `reload_config` to reset.\n\nstrategies\n    Lists available strategies\n\nstrategy\n    Get strategy details\n\n        :param strategy: Strategy class name\n\nsysinfo\n    Provides system information (CPU, RAM usage)\n\ntrade\n    Return specific trade\n\n        :param trade_id: Specify which trade to get.\n\ntrades\n    Return trades history, sorted by id\n\n        :param limit: Limits trades to the X last trades. Max 500 trades.\n        :param offset: Offset by this amount of trades.\n\nversion\n    Return the version of the bot.\n\nwhitelist\n    Show the current whitelist.\n</code></pre>"},{"location":"rest-api/#message-websocket","title":"Message WebSocket","text":"<p>The API Server includes a websocket endpoint for subscribing to RPC messages from the freqtrade Bot. This can be used to consume real-time data from your bot, such as entry/exit fill messages, whitelist changes, populated indicators for pairs, and more.</p> <p>This is also used to setup Producer/Consumer mode in Freqtrade.</p> <p>Assuming your rest API is set to <code>127.0.0.1</code> on port <code>8080</code>, the endpoint is available at <code>http://localhost:8080/api/v1/message/ws</code>.</p> <p>To access the websocket endpoint, the <code>ws_token</code> is required as a query parameter in the endpoint URL.</p> <p>To generate a safe <code>ws_token</code> you can run the following code:</p> <pre><code>&gt;&gt;&gt; import secrets\n&gt;&gt;&gt; secrets.token_urlsafe(25)\n'hZ-y58LXyX_HZ8O1cJzVyN6ePWrLpNQv4Q'\n</code></pre> <p>You would then add that token under <code>ws_token</code> in your <code>api_server</code> config. Like so:</p> <pre><code>\"api_server\": {\n    \"enabled\": true,\n    \"listen_ip_address\": \"127.0.0.1\",\n    \"listen_port\": 8080,\n    \"verbosity\": \"error\",\n    \"enable_openapi\": false,\n    \"jwt_secret_key\": \"somethingrandom\",\n    \"CORS_origins\": [],\n    \"username\": \"Freqtrader\",\n    \"password\": \"SuperSecret1!\",\n    \"ws_token\": \"hZ-y58LXyX_HZ8O1cJzVyN6ePWrLpNQv4Q\" // &lt;-----\n},\n</code></pre> <p>You can now connect to the endpoint at <code>http://localhost:8080/api/v1/message/ws?token=hZ-y58LXyX_HZ8O1cJzVyN6ePWrLpNQv4Q</code>.</p> <p>Reuse of example tokens</p> <p>Please do not use the above example token. To make sure you are secure, generate a completely new token.</p>"},{"location":"rest-api/#using-the-websocket","title":"Using the WebSocket","text":"<p>Once connected to the WebSocket, the bot will broadcast RPC messages to anyone who is subscribed to them. To subscribe to a list of messages, you must send a JSON request through the WebSocket like the one below. The <code>data</code> key must be a list of message type strings.</p> <pre><code>{\n  \"type\": \"subscribe\",\n  \"data\": [\"whitelist\", \"analyzed_df\"] // A list of string message types\n}\n</code></pre> <p>For a list of message types, please refer to the RPCMessageType enum in <code>freqtrade/enums/rpcmessagetype.py</code></p> <p>Now anytime those types of RPC messages are sent in the bot, you will receive them through the WebSocket as long as the connection is active. They typically take the same form as the request:</p> <pre><code>{\n  \"type\": \"analyzed_df\",\n  \"data\": {\n      \"key\": [\"NEO/BTC\", \"5m\", \"spot\"],\n      \"df\": {}, // The dataframe\n      \"la\": \"2022-09-08 22:14:41.457786+00:00\"\n  }\n}\n</code></pre>"},{"location":"rest-api/#reverse-proxy-setup","title":"Reverse Proxy setup","text":"<p>When using Nginx, the following configuration is required for WebSockets to work (Note this configuration is incomplete, it's missing some information and can not be used as is):</p> <p>Please make sure to replace <code>&lt;freqtrade_listen_ip&gt;</code> (and the subsequent port) with the IP and Port matching your configuration/setup.</p> <pre><code>http {\n    map $http_upgrade $connection_upgrade {\n        default upgrade;\n        '' close;\n    }\n\n    #...\n\n    server {\n        #...\n\n        location / {\n            proxy_http_version 1.1;\n            proxy_pass http://&lt;freqtrade_listen_ip&gt;:8080;\n            proxy_set_header Upgrade $http_upgrade;\n            proxy_set_header Connection $connection_upgrade;\n            proxy_set_header Host $host;\n        }\n    }\n}\n</code></pre> <p>To properly configure your reverse proxy (securely), please consult it's documentation for proxying websockets.</p> <ul> <li>Traefik: Traefik supports websockets out of the box, see the documentation</li> <li>Caddy: Caddy v2 supports websockets out of the box, see the documentation</li> </ul> <p>SSL certificates</p> <p>You can use tools like certbot to setup ssl certificates to access your bot's UI through encrypted connection by using any of the above reverse proxies. While this will protect your data in transit, we do not recommend to run the freqtrade API outside of your private network (VPN, SSH tunnel).</p>"},{"location":"rest-api/#openapi-interface","title":"OpenAPI interface","text":"<p>To enable the builtin openAPI interface (Swagger UI), specify <code>\"enable_openapi\": true</code> in the api_server configuration. This will enable the Swagger UI at the <code>/docs</code> endpoint. By default, that's running at http://localhost:8080/docs - but it'll depend on your settings.</p>"},{"location":"rest-api/#advanced-api-usage-using-jwt-tokens","title":"Advanced API usage using JWT tokens","text":"<p>Note</p> <p>The below should be done in an application (a Freqtrade REST API client, which fetches info via API), and is not intended to be used on a regular basis.</p> <p>Freqtrade's REST API also offers JWT (JSON Web Tokens). You can login using the following command, and subsequently use the resulting access_token.</p> <pre><code>&gt; curl -X POST --user Freqtrader http://localhost:8080/api/v1/token/login\n{\"access_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODkxMTk2ODEsIm5iZiI6MTU4OTExOTY4MSwianRpIjoiMmEwYmY0NWUtMjhmOS00YTUzLTlmNzItMmM5ZWVlYThkNzc2IiwiZXhwIjoxNTg5MTIwNTgxLCJpZGVudGl0eSI6eyJ1IjoiRnJlcXRyYWRlciJ9LCJmcmVzaCI6ZmFsc2UsInR5cGUiOiJhY2Nlc3MifQ.qt6MAXYIa-l556OM7arBvYJ0SDI9J8bIk3_glDujF5g\",\"refresh_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODkxMTk2ODEsIm5iZiI6MTU4OTExOTY4MSwianRpIjoiZWQ1ZWI3YjAtYjMwMy00YzAyLTg2N2MtNWViMjIxNWQ2YTMxIiwiZXhwIjoxNTkxNzExNjgxLCJpZGVudGl0eSI6eyJ1IjoiRnJlcXRyYWRlciJ9LCJ0eXBlIjoicmVmcmVzaCJ9.d1AT_jYICyTAjD0fiQAr52rkRqtxCjUGEMwlNuuzgNQ\"}\n\n&gt; access_token=\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODkxMTk2ODEsIm5iZiI6MTU4OTExOTY4MSwianRpIjoiMmEwYmY0NWUtMjhmOS00YTUzLTlmNzItMmM5ZWVlYThkNzc2IiwiZXhwIjoxNTg5MTIwNTgxLCJpZGVudGl0eSI6eyJ1IjoiRnJlcXRyYWRlciJ9LCJmcmVzaCI6ZmFsc2UsInR5cGUiOiJhY2Nlc3MifQ.qt6MAXYIa-l556OM7arBvYJ0SDI9J8bIk3_glDujF5g\"\n# Use access_token for authentication\n&gt; curl -X GET --header \"Authorization: Bearer ${access_token}\" http://localhost:8080/api/v1/count\n</code></pre> <p>Since the access token has a short timeout (15 min) - the <code>token/refresh</code> request should be used periodically to get a fresh access token:</p> <pre><code>&gt; curl -X POST --header \"Authorization: Bearer ${refresh_token}\"http://localhost:8080/api/v1/token/refresh\n{\"access_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODkxMTk5NzQsIm5iZiI6MTU4OTExOTk3NCwianRpIjoiMDBjNTlhMWUtMjBmYS00ZTk0LTliZjAtNWQwNTg2MTdiZDIyIiwiZXhwIjoxNTg5MTIwODc0LCJpZGVudGl0eSI6eyJ1IjoiRnJlcXRyYWRlciJ9LCJmcmVzaCI6ZmFsc2UsInR5cGUiOiJhY2Nlc3MifQ.1seHlII3WprjjclY6DpRhen0rqdF4j6jbvxIhUFaSbs\"}\n</code></pre>"},{"location":"rest-api/#cors","title":"CORS","text":"<p>This whole section is only necessary in cross-origin cases (where you multiple bot API's running on <code>localhost:8081</code>, <code>localhost:8082</code>, ...), and want to combine them into one FreqUI instance.</p> Technical explanation <p>All web-based front-ends are subject to CORS - Cross-Origin Resource Sharing. Since most of the requests to the Freqtrade API must be authenticated, a proper CORS policy is key to avoid security problems. Also, the standard disallows <code>*</code> CORS policies for requests with credentials, so this setting must be set appropriately.</p> <p>Users can allow access from different origin URL's to the bot API via the <code>CORS_origins</code> configuration setting. It consists of a list of allowed URL's that are allowed to consume resources from the bot's API.</p> <p>Assuming your application is deployed as <code>https://frequi.freqtrade.io/home/</code> - this would mean that the following configuration becomes necessary:</p> <pre><code>{\n    //...\n    \"jwt_secret_key\": \"somethingrandom\",\n    \"CORS_origins\": [\"https://frequi.freqtrade.io\"],\n    //...\n}\n</code></pre> <p>In the following (pretty common) case, FreqUI is accessible on <code>http://localhost:8080/trade</code> (this is what you see in your navbar when navigating to freqUI). </p> <p>The correct configuration for this case is <code>http://localhost:8080</code> - the main part of the URL including the port.</p> <pre><code>{\n    //...\n    \"jwt_secret_key\": \"somethingrandom\",\n    \"CORS_origins\": [\"http://localhost:8080\"],\n    //...\n}\n</code></pre> <p>trailing Slash</p> <p>The trailing slash is not allowed in the <code>CORS_origins</code> configuration (e.g. <code>\"http://localhots:8080/\"</code>). Such a configuration will not take effect, and the cors errors will remain.</p> <p>Note</p> <p>We strongly recommend to also set <code>jwt_secret_key</code> to something random and known only to yourself to avoid unauthorized access to your bot.</p>"},{"location":"sql_cheatsheet/","title":"SQL Helper","text":"<p>This page contains some help if you want to edit your sqlite db.</p>"},{"location":"sql_cheatsheet/#install-sqlite3","title":"Install sqlite3","text":"<p>Sqlite3 is a terminal based sqlite application. Feel free to use a visual Database editor like SqliteBrowser if you feel more comfortable with that.</p>"},{"location":"sql_cheatsheet/#ubuntudebian-installation","title":"Ubuntu/Debian installation","text":"<pre><code>sudo apt-get install sqlite3\n</code></pre>"},{"location":"sql_cheatsheet/#using-sqlite3-via-docker","title":"Using sqlite3 via docker","text":"<p>The freqtrade docker image does contain sqlite3, so you can edit the database without having to install anything on the host system.</p> <pre><code>docker compose exec freqtrade /bin/bash\nsqlite3 &lt;database-file&gt;.sqlite\n</code></pre>"},{"location":"sql_cheatsheet/#open-the-db","title":"Open the DB","text":"<pre><code>sqlite3\n.open &lt;filepath&gt;\n</code></pre>"},{"location":"sql_cheatsheet/#table-structure","title":"Table structure","text":""},{"location":"sql_cheatsheet/#list-tables","title":"List tables","text":"<pre><code>.tables\n</code></pre>"},{"location":"sql_cheatsheet/#display-table-structure","title":"Display table structure","text":"<pre><code>.schema &lt;table_name&gt;\n</code></pre>"},{"location":"sql_cheatsheet/#get-all-trades-in-the-table","title":"Get all trades in the table","text":"<pre><code>SELECT * FROM trades;\n</code></pre>"},{"location":"sql_cheatsheet/#fix-trade-still-open-after-a-manual-exit-on-the-exchange","title":"Fix trade still open after a manual exit on the exchange","text":"<p>Warning</p> <p>Manually selling a pair on the exchange will not be detected by the bot and it will try to sell anyway. Whenever possible, /forceexit  should be used to accomplish the same thing. It is strongly advised to backup your database file before making any manual changes. <p>Note</p> <p>This should not be necessary after /forceexit, as force_exit orders are closed automatically by the bot on the next iteration.</p> <pre><code>UPDATE trades\nSET is_open=0,\n  close_date=&lt;close_date&gt;,\n  close_rate=&lt;close_rate&gt;,\n  close_profit = close_rate / open_rate - 1,\n  close_profit_abs = (amount * &lt;close_rate&gt; * (1 - fee_close) - (amount * (open_rate * (1 - fee_open)))),\n  exit_reason=&lt;exit_reason&gt;\nWHERE id=&lt;trade_ID_to_update&gt;;\n</code></pre>"},{"location":"sql_cheatsheet/#example","title":"Example","text":"<pre><code>UPDATE trades\nSET is_open=0,\n  close_date='2020-06-20 03:08:45.103418',\n  close_rate=0.19638016,\n  close_profit=0.0496,\n  close_profit_abs = (amount * 0.19638016 * (1 - fee_close) - (amount * (open_rate * (1 - fee_open)))),\n  exit_reason='force_exit'  \nWHERE id=31;\n</code></pre>"},{"location":"sql_cheatsheet/#remove-trade-from-the-database","title":"Remove trade from the database","text":"<p>Use RPC Methods to delete trades</p> <p>Consider using <code>/delete &lt;tradeid&gt;</code> via telegram or rest API. That's the recommended way to deleting trades.</p> <p>If you'd still like to remove a trade from the database directly, you can use the below query.</p> <p>Danger</p> <p>Some systems (Ubuntu) disable foreign keys in their sqlite3 packaging. When using sqlite - please ensure that foreign keys are on by running <code>PRAGMA foreign_keys = ON</code> before the above query.</p> <pre><code>DELETE FROM trades WHERE id = &lt;tradeid&gt;;\n\nDELETE FROM trades WHERE id = 31;\n</code></pre> <p>Warning</p> <p>This will remove this trade from the database. Please make sure you got the correct id and NEVER run this query without the <code>where</code> clause.</p>"},{"location":"sql_cheatsheet/#use-a-different-database-system","title":"Use a different database system","text":"<p>Freqtrade is using SQLAlchemy, which supports multiple different database systems. As such, a multitude of database systems should be supported. Freqtrade does not depend or install any additional database driver. Please refer to the SQLAlchemy docs on installation instructions for the respective database systems.</p> <p>The following systems have been tested and are known to work with freqtrade:</p> <ul> <li>sqlite (default)</li> <li>PostgreSQL</li> <li>MariaDB</li> </ul> <p>Warning</p> <p>By using one of the below database systems, you acknowledge that you know how to manage such a system. The freqtrade team will not provide any support with setup or maintenance (or backups) of the below database systems.</p>"},{"location":"sql_cheatsheet/#postgresql","title":"PostgreSQL","text":"<p>Installation: <code>pip install psycopg2-binary</code></p> <p>Usage: <code>... --db-url postgresql+psycopg2://&lt;username&gt;:&lt;password&gt;@localhost:5432/&lt;database&gt;</code></p> <p>Freqtrade will automatically create the tables necessary upon startup.</p> <p>If you're running different instances of Freqtrade, you must either setup one database per Instance or use different users / schemas for your connections.</p>"},{"location":"sql_cheatsheet/#mariadb-mysql","title":"MariaDB / MySQL","text":"<p>Freqtrade supports MariaDB by using SQLAlchemy, which supports multiple different database systems.</p> <p>Installation: <code>pip install pymysql</code></p> <p>Usage: <code>... --db-url mysql+pymysql://&lt;username&gt;:&lt;password&gt;@localhost:3306/&lt;database&gt;</code></p>"},{"location":"stoploss/","title":"Stop Loss","text":"<p>The <code>stoploss</code> configuration parameter is loss as ratio that should trigger a sale. For example, value <code>-0.10</code> will cause immediate sell if the profit dips below -10% for a given trade. This parameter is optional. Stoploss calculations do include fees, so a stoploss of -10% is placed exactly 10% below the entry point.</p> <p>Most of the strategy files already include the optimal <code>stoploss</code> value.</p> <p>Info</p> <p>All stoploss properties mentioned in this file can be set in the Strategy, or in the configuration. Configuration values will override the strategy values.</p>"},{"location":"stoploss/#stop-loss-on-exchangefreqtrade","title":"Stop Loss On-Exchange/Freqtrade","text":"<p>Those stoploss modes can be on exchange or off exchange.</p> <p>These modes can be configured with these values:</p> <pre><code>    'emergency_exit': 'market',\n    'stoploss_on_exchange': False\n    'stoploss_on_exchange_interval': 60,\n    'stoploss_on_exchange_limit_ratio': 0.99\n</code></pre> <p>Stoploss on exchange is only supported for the following exchanges, and not all exchanges support both stop-limit and stop-market. The Order-type will be ignored if only one mode is available.</p> Exchange stop-loss type Binance limit Binance Futures market, limit Bingx market, limit HTX (former Huobi) limit kraken market, limit Gate limit Okx limit Kucoin stop-limit, stop-market <p>Tight stoploss</p> <p>Do not set too low/tight stoploss value when using stop loss on exchange! If set to low/tight you will have greater risk of missing fill on the order and stoploss will not work.</p>"},{"location":"stoploss/#stoploss_on_exchange-and-stoploss_on_exchange_limit_ratio","title":"stoploss_on_exchange and stoploss_on_exchange_limit_ratio","text":"<p>Enable or Disable stop loss on exchange. If the stoploss is on exchange it means a stoploss limit order is placed on the exchange immediately after buy order fills. This will protect you against sudden crashes in market, as the order execution happens purely within the exchange, and has no potential network overhead.</p> <p>If <code>stoploss_on_exchange</code> uses limit orders, the exchange needs 2 prices, the stoploss_price and the Limit price. <code>stoploss</code> defines the stop-price where the limit order is placed - and limit should be slightly below this. If an exchange supports both limit and market stoploss orders, then the value of <code>stoploss</code> will be used to determine the stoploss type.  </p> <p>Calculation example: we bought the asset at 100$. Stop-price is 95$, then limit would be <code>95 * 0.99 = 94.05$</code> - so the limit order fill can happen between 95$ and 94.05$.  </p> <p>For example, assuming the stoploss is on exchange, and trailing stoploss is enabled, and the market is going up, then the bot automatically cancels the previous stoploss order and puts a new one with a stop value higher than the previous stoploss order.</p> <p>Note</p> <p>If <code>stoploss_on_exchange</code> is enabled and the stoploss is cancelled manually on the exchange, then the bot will create a new stoploss order.</p>"},{"location":"stoploss/#stoploss_on_exchange_interval","title":"stoploss_on_exchange_interval","text":"<p>In case of stoploss on exchange there is another parameter called <code>stoploss_on_exchange_interval</code>. This configures the interval in seconds at which the bot will check the stoploss and update it if necessary. The bot cannot do these every 5 seconds (at each iteration), otherwise it would get banned by the exchange. So this parameter will tell the bot how often it should update the stoploss order. The default value is 60 (1 minute). This same logic will reapply a stoploss order on the exchange should you cancel it accidentally.</p>"},{"location":"stoploss/#stoploss_price_type","title":"stoploss_price_type","text":"<p>Only applies to futures</p> <p><code>stoploss_price_type</code> only applies to futures markets (on exchanges where it's available). Freqtrade will perform a validation of this setting on startup, failing to start if an invalid setting for your exchange has been selected. Supported price types are gonna differs between each exchanges. Please check with your exchange on which price types it supports.</p> <p>Stoploss on exchange on futures markets can trigger on different price types. The naming for these prices in exchange terminology often varies, but is usually something around \"last\" (or \"contract price\" ), \"mark\" and \"index\".</p> <p>Acceptable values for this setting are <code>\"last\"</code>, <code>\"mark\"</code> and <code>\"index\"</code> - which freqtrade will transfer automatically to the corresponding API type, and place the stoploss on exchange order correspondingly.</p>"},{"location":"stoploss/#force_exit","title":"force_exit","text":"<p><code>force_exit</code> is an optional value, which defaults to the same value as <code>exit</code> and is used when sending a <code>/forceexit</code> command from Telegram or from the Rest API.</p>"},{"location":"stoploss/#force_entry","title":"force_entry","text":"<p><code>force_entry</code> is an optional value, which defaults to the same value as <code>entry</code> and is used when sending a <code>/forceentry</code> command from Telegram or from the Rest API.</p>"},{"location":"stoploss/#emergency_exit","title":"emergency_exit","text":"<p><code>emergency_exit</code> is an optional value, which defaults to <code>market</code> and is used when creating stop loss on exchange orders fails. The below is the default which is used if not changed in strategy or configuration file.</p> <p>Example from strategy file:</p> <pre><code>order_types = {\n    \"entry\": \"limit\",\n    \"exit\": \"limit\",\n    \"emergency_exit\": \"market\",\n    \"stoploss\": \"market\",\n    \"stoploss_on_exchange\": True,\n    \"stoploss_on_exchange_interval\": 60,\n    \"stoploss_on_exchange_limit_ratio\": 0.99\n}\n</code></pre>"},{"location":"stoploss/#stop-loss-types","title":"Stop Loss Types","text":"<p>At this stage the bot contains the following stoploss support modes:</p> <ol> <li>Static stop loss.</li> <li>Trailing stop loss.</li> <li>Trailing stop loss, custom positive loss.</li> <li>Trailing stop loss only once the trade has reached a certain offset.</li> <li>Custom stoploss function</li> </ol>"},{"location":"stoploss/#static-stop-loss","title":"Static Stop Loss","text":"<p>This is very simple, you define a stop loss of x (as a ratio of price, i.e. x * 100% of price). This will try to sell the asset once the loss exceeds the defined loss.</p> <p>Example of stop loss:</p> <pre><code>    stoploss = -0.10\n</code></pre> <p>For example, simplified math:</p> <ul> <li>the bot buys an asset at a price of 100$</li> <li>the stop loss is defined at -10%</li> <li>the stop loss would get triggered once the asset drops below 90$</li> </ul>"},{"location":"stoploss/#trailing-stop-loss","title":"Trailing Stop Loss","text":"<p>The initial value for this is <code>stoploss</code>, just as you would define your static Stop loss. To enable trailing stoploss:</p> <pre><code>    stoploss = -0.10\n    trailing_stop = True\n</code></pre> <p>This will now activate an algorithm, which automatically moves the stop loss up every time the price of your asset increases.</p> <p>For example, simplified math:</p> <ul> <li>the bot buys an asset at a price of 100$</li> <li>the stop loss is defined at -10%</li> <li>the stop loss would get triggered once the asset drops below 90$</li> <li>assuming the asset now increases to 102$</li> <li>the stop loss will now be -10% of 102$ = 91.8$</li> <li>now the asset drops in value to 101$, the stop loss will still be 91.8$ and would trigger at 91.8$.</li> </ul> <p>In summary: The stoploss will be adjusted to be always be -10% of the highest observed price.</p>"},{"location":"stoploss/#trailing-stop-loss-custom-positive-loss","title":"Trailing stop loss, custom positive loss","text":"<p>You could also have a default stop loss when you are in the red with your buy (buy - fee), but once you hit a positive result (or an offset you define) the system will utilize a new stop loss, which can have a different value. For example, your default stop loss is -10%, but once you have more than 0% profit (example 0.1%) a different trailing stoploss will be used.</p> <p>Note</p> <p>If you want the stoploss to only be changed when you break even of making a profit (what most users want) please refer to next section with offset enabled.</p> <p>Both values require <code>trailing_stop</code> to be set to true and <code>trailing_stop_positive</code> with a value.</p> <pre><code>    stoploss = -0.10\n    trailing_stop = True\n    trailing_stop_positive = 0.02\n    trailing_stop_positive_offset = 0.0\n    trailing_only_offset_is_reached = False  # Default - not necessary for this example\n</code></pre> <p>For example, simplified math:</p> <ul> <li>the bot buys an asset at a price of 100$</li> <li>the stop loss is defined at -10%</li> <li>the stop loss would get triggered once the asset drops below 90$</li> <li>assuming the asset now increases to 102$</li> <li>the stop loss will now be -2% of 102$ = 99.96$ (99.96$ stop loss will be locked in and will follow asset price increments with -2%)</li> <li>now the asset drops in value to 101$, the stop loss will still be 99.96$ and would trigger at 99.96$</li> </ul> <p>The 0.02 would translate to a -2% stop loss. Before this, <code>stoploss</code> is used for the trailing stoploss.</p> <p>Use an offset to change your stoploss</p> <p>Use <code>trailing_stop_positive_offset</code> to ensure that your new trailing stoploss will be in profit by setting <code>trailing_stop_positive_offset</code> higher than <code>trailing_stop_positive</code>. Your first new stoploss value will then already have locked in profits.</p> <p>Example with simplified math:</p> <pre><code>    stoploss = -0.10\n    trailing_stop = True\n    trailing_stop_positive = 0.02\n    trailing_stop_positive_offset = 0.03\n</code></pre> <ul> <li>the bot buys an asset at a price of 100$</li> <li>the stop loss is defined at -10%, so the stop loss would get triggered once the asset drops below 90$</li> <li>assuming the asset now increases to 102$</li> <li>the stoploss will now be at 91.8$ - 10% below the highest observed rate</li> <li>assuming the asset now increases to 103.5$ (above the offset configured)</li> <li>the stop loss will now be -2% of 103.5$ = 101.43$</li> <li>now the asset drops in value to 102$, the stop loss will still be 101.43$ and would trigger once price breaks below 101.43$</li> </ul>"},{"location":"stoploss/#trailing-stop-loss-only-once-the-trade-has-reached-a-certain-offset","title":"Trailing stop loss only once the trade has reached a certain offset","text":"<p>You can also keep a static stoploss until the offset is reached, and then trail the trade to take profits once the market turns.</p> <p>If <code>trailing_only_offset_is_reached = True</code> then the trailing stoploss is only activated once the offset is reached. Until then, the stoploss remains at the configured <code>stoploss</code>. This option can be used with or without <code>trailing_stop_positive</code>, but uses <code>trailing_stop_positive_offset</code> as offset.</p> <p>Configuration (offset is buy-price + 3%):</p> <pre><code>    stoploss = -0.10\n    trailing_stop = True\n    trailing_stop_positive = 0.02\n    trailing_stop_positive_offset = 0.03\n    trailing_only_offset_is_reached = True\n</code></pre> <p>For example, simplified math:</p> <ul> <li>the bot buys an asset at a price of 100$</li> <li>the stop loss is defined at -10%</li> <li>the stop loss would get triggered once the asset drops below 90$</li> <li>stoploss will remain at 90$ unless asset increases to or above the configured offset</li> <li>assuming the asset now increases to 103$ (where we have the offset configured)</li> <li>the stop loss will now be -2% of 103$ = 100.94$</li> <li>now the asset drops in value to 101$, the stop loss will still be 100.94$ and would trigger at 100.94$</li> </ul> <p>Tip</p> <p>Make sure to have this value (<code>trailing_stop_positive_offset</code>) lower than minimal ROI, otherwise minimal ROI will apply first and sell the trade.</p>"},{"location":"stoploss/#stoploss-and-leverage","title":"Stoploss and Leverage","text":"<p>Stoploss should be thought of as \"risk on this trade\" - so a stoploss of 10% on a 100$ trade means you are willing to lose 10$ (10%) on this trade - which would trigger if the price moves 10% to the downside.</p> <p>When using leverage, the same principle is applied - with stoploss defining the risk on the trade (the amount you are willing to lose).</p> <p>Therefore, a stoploss of 10% on a 10x trade would trigger on a 1% price move. If your stake amount (own capital) was 100$ - this trade would be 1000$ at 10x (after leverage). If price moves 1% - you've lost 10$ of your own capital - therefore stoploss will trigger in this case.</p> <p>Make sure to be aware of this, and avoid using too tight stoploss (at 10x leverage, 10% risk may be too little to allow the trade to \"breath\" a little).</p>"},{"location":"stoploss/#changing-stoploss-on-open-trades","title":"Changing stoploss on open trades","text":"<p>A stoploss on an open trade can be changed by changing the value in the configuration or strategy and use the <code>/reload_config</code> command (alternatively, completely stopping and restarting the bot also works).</p> <p>The new stoploss value will be applied to open trades (and corresponding log-messages will be generated).</p>"},{"location":"stoploss/#limitations","title":"Limitations","text":"<p>Stoploss values cannot be changed if <code>trailing_stop</code> is enabled and the stoploss has already been adjusted, or if Edge is enabled (since Edge would recalculate stoploss based on the current market situation).</p>"},{"location":"strategy-advanced/","title":"Advanced Strategies","text":"<p>This page explains some advanced concepts available for strategies. If you're just getting started, please familiarize yourself with the Freqtrade basics and methods described in Strategy Customization first.</p> <p>The call sequence of the methods described here is covered under bot execution logic. Those docs are also helpful in deciding which method is most suitable for your customisation needs.</p> <p>Note</p> <p>Callback methods should only be implemented if a strategy uses them.</p> <p>Tip</p> <p>Start off with a strategy template containing all available callback methods by running <code>freqtrade new-strategy --strategy MyAwesomeStrategy --template advanced</code></p>"},{"location":"strategy-advanced/#storing-information-persistent","title":"Storing information (Persistent)","text":"<p>Freqtrade allows storing/retrieving user custom information associated with a specific trade in the database.</p> <p>Using a trade object, information can be stored using <code>trade.set_custom_data(key='my_key', value=my_value)</code> and retrieved using <code>trade.get_custom_data(key='my_key')</code>. Each data entry is associated with a trade and a user supplied key (of type <code>string</code>). This means that this can only be used in callbacks that also provide a trade object.</p> <p>For the data to be able to be stored within the database, freqtrade must serialized the data. This is done by converting the data to a JSON formatted string. Freqtrade will attempt to reverse this action on retrieval, so from a strategy perspective, this should not be relevant.</p> <pre><code>from freqtrade.persistence import Trade\nfrom datetime import timedelta\n\nclass AwesomeStrategy(IStrategy):\n\n    def bot_loop_start(self, **kwargs) -&gt; None:\n        for trade in Trade.get_open_order_trades():\n            fills = trade.select_filled_orders(trade.entry_side)\n            if trade.pair == 'ETH/USDT':\n                trade_entry_type = trade.get_custom_data(key='entry_type')\n                if trade_entry_type is None:\n                    trade_entry_type = 'breakout' if 'entry_1' in trade.enter_tag else 'dip'\n                elif fills &gt; 1:\n                    trade_entry_type = 'buy_up'\n                trade.set_custom_data(key='entry_type', value=trade_entry_type)\n        return super().bot_loop_start(**kwargs)\n\n    def adjust_entry_price(self, trade: Trade, order: Optional[Order], pair: str,\n                           current_time: datetime, proposed_rate: float, current_order_rate: float,\n                           entry_tag: Optional[str], side: str, **kwargs) -&gt; float:\n        # Limit orders to use and follow SMA200 as price target for the first 10 minutes since entry trigger for BTC/USDT pair.\n        if (\n            pair == 'BTC/USDT' \n            and entry_tag == 'long_sma200' \n            and side == 'long' \n            and (current_time - timedelta(minutes=10)) &gt; trade.open_date_utc \n            and order.filled == 0.0\n        ):\n            dataframe, _ = self.dp.get_analyzed_dataframe(pair=pair, timeframe=self.timeframe)\n            current_candle = dataframe.iloc[-1].squeeze()\n            # store information about entry adjustment\n            existing_count = trade.get_custom_data('num_entry_adjustments', default=0)\n            if not existing_count:\n                existing_count = 1\n            else:\n                existing_count += 1\n            trade.set_custom_data(key='num_entry_adjustments', value=existing_count)\n\n            # adjust order price\n            return current_candle['sma_200']\n\n        # default: maintain existing order\n        return current_order_rate\n\n    def custom_exit(self, pair: str, trade: Trade, current_time: datetime, current_rate: float, current_profit: float, **kwargs):\n\n        entry_adjustment_count = trade.get_custom_data(key='num_entry_adjustments')\n        trade_entry_type = trade.get_custom_data(key='entry_type')\n        if entry_adjustment_count is None:\n            if current_profit &gt; 0.01 and (current_time - timedelta(minutes=100) &gt; trade.open_date_utc):\n                return True, 'exit_1'\n        else\n            if entry_adjustment_count &gt; 0 and if current_profit &gt; 0.05:\n                return True, 'exit_2'\n            if trade_entry_type == 'breakout' and current_profit &gt; 0.1:\n                return True, 'exit_3\n\n        return False, None\n</code></pre> <p>The above is a simple example - there are simpler ways to retrieve trade data like entry-adjustments.</p> <p>Note</p> <p>It is recommended that simple data types are used <code>[bool, int, float, str]</code> to ensure no issues when serializing the data that needs to be stored. Storing big junks of data may lead to unintended side-effects, like a database becoming big (and as a consequence, also slow).</p> <p>Non-serializable data</p> <p>If supplied data cannot be serialized a warning is logged and the entry for the specified <code>key</code> will contain <code>None</code> as data.</p> All attributes <p>custom-data has the following accessors through the Trade object (assumed as <code>trade</code> below):</p> <ul> <li><code>trade.get_custom_data(key='something', default=0)</code> - Returns the actual value given in the type provided.</li> <li><code>trade.get_custom_data_entry(key='something')</code> - Returns the entry - including metadata. The value is accessible via <code>.value</code> property.</li> <li><code>trade.set_custom_data(key='something', value={'some': 'value'})</code> - set or update the corresponding key for this trade. Value must be serializable - and we recommend to keep the stored data relatively small.</li> </ul> <p>\"value\" can be any type (both in setting and receiving) - but must be json serializable.</p>"},{"location":"strategy-advanced/#storing-information-non-persistent","title":"Storing information (Non-Persistent)","text":"<p>Deprecated</p> <p>This method of storing information is deprecated and we do advise against using non-persistent storage. Please use Persistent Storage instead.</p> <p>It's content has therefore been collapsed.</p> Storing information <p>Storing information can be accomplished by creating a new dictionary within the strategy class.</p> <p>The name of the variable can be chosen at will, but should be prefixed with <code>custom_</code> to avoid naming collisions with predefined strategy variables.</p> <pre><code>class AwesomeStrategy(IStrategy):\n    # Create custom dictionary\n    custom_info = {}\n\n    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        # Check if the entry already exists\n        if not metadata[\"pair\"] in self.custom_info:\n            # Create empty entry for this pair\n            self.custom_info[metadata[\"pair\"]] = {}\n\n        if \"crosstime\" in self.custom_info[metadata[\"pair\"]]:\n            self.custom_info[metadata[\"pair\"]][\"crosstime\"] += 1\n        else:\n            self.custom_info[metadata[\"pair\"]][\"crosstime\"] = 1\n</code></pre> <p>Warning</p> <p>The data is not persisted after a bot-restart (or config-reload). Also, the amount of data should be kept smallish (no DataFrames and such), otherwise the bot will start to consume a lot of memory and eventually run out of memory and crash.</p> <p>Note</p> <p>If the data is pair-specific, make sure to use pair as one of the keys in the dictionary.</p>"},{"location":"strategy-advanced/#dataframe-access","title":"Dataframe access","text":"<p>You may access dataframe in various strategy functions by querying it from dataprovider.</p> <pre><code>from freqtrade.exchange import timeframe_to_prev_date\n\nclass AwesomeStrategy(IStrategy):\n    def confirm_trade_exit(self, pair: str, trade: 'Trade', order_type: str, amount: float,\n                           rate: float, time_in_force: str, exit_reason: str,\n                           current_time: 'datetime', **kwargs) -&gt; bool:\n        # Obtain pair dataframe.\n        dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe)\n\n        # Obtain last available candle. Do not use current_time to look up latest candle, because \n        # current_time points to current incomplete candle whose data is not available.\n        last_candle = dataframe.iloc[-1].squeeze()\n        # &lt;...&gt;\n\n        # In dry/live runs trade open date will not match candle open date therefore it must be \n        # rounded.\n        trade_date = timeframe_to_prev_date(self.timeframe, trade.open_date_utc)\n        # Look up trade candle.\n        trade_candle = dataframe.loc[dataframe['date'] == trade_date]\n        # trade_candle may be empty for trades that just opened as it is still incomplete.\n        if not trade_candle.empty:\n            trade_candle = trade_candle.squeeze()\n            # &lt;...&gt;\n</code></pre> <p>Using .iloc[-1]</p> <p>You can use <code>.iloc[-1]</code> here because <code>get_analyzed_dataframe()</code> only returns candles that backtesting is allowed to see. This will not work in <code>populate_*</code> methods, so make sure to not use <code>.iloc[]</code> in that area. Also, this will only work starting with version 2021.5.</p>"},{"location":"strategy-advanced/#enter-tag","title":"Enter Tag","text":"<p>When your strategy has multiple buy signals, you can name the signal that triggered. Then you can access your buy signal on <code>custom_exit</code></p> <pre><code>def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n    dataframe.loc[\n        (\n            (dataframe['rsi'] &lt; 35) &amp;\n            (dataframe['volume'] &gt; 0)\n        ),\n        ['enter_long', 'enter_tag']] = (1, 'buy_signal_rsi')\n\n    return dataframe\n\ndef custom_exit(self, pair: str, trade: Trade, current_time: datetime, current_rate: float,\n                current_profit: float, **kwargs):\n    dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe)\n    last_candle = dataframe.iloc[-1].squeeze()\n    if trade.enter_tag == 'buy_signal_rsi' and last_candle['rsi'] &gt; 80:\n        return 'sell_signal_rsi'\n    return None\n</code></pre> <p>Note</p> <p><code>enter_tag</code> is limited to 100 characters, remaining data will be truncated.</p> <p>Warning</p> <p>There is only one <code>enter_tag</code> column, which is used for both long and short trades. As a consequence, this column must be treated as \"last write wins\" (it's just a dataframe column after all). In fancy situations, where multiple signals collide (or if signals are deactivated again based on different conditions), this can lead to odd results with the wrong tag applied to an entry signal. These results are a consequence of the strategy overwriting prior tags - where the last tag will \"stick\" and will be the one freqtrade will use.</p>"},{"location":"strategy-advanced/#exit-tag","title":"Exit tag","text":"<p>Similar to Entry Tagging, you can also specify an exit tag.</p> <pre><code>def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n    dataframe.loc[\n        (\n            (dataframe['rsi'] &gt; 70) &amp;\n            (dataframe['volume'] &gt; 0)\n        ),\n        ['exit_long', 'exit_tag']] = (1, 'exit_rsi')\n\n    return dataframe\n</code></pre> <p>The provided exit-tag is then used as sell-reason - and shown as such in backtest results.</p> <p>Note</p> <p><code>exit_reason</code> is limited to 100 characters, remaining data will be truncated.</p>"},{"location":"strategy-advanced/#strategy-version","title":"Strategy version","text":"<p>You can implement custom strategy versioning by using the \"version\" method, and returning the version you would like this strategy to have.</p> <pre><code>def version(self) -&gt; str:\n    \"\"\"\n    Returns version of the strategy.\n    \"\"\"\n    return \"1.1\"\n</code></pre> <p>Note</p> <p>You should make sure to implement proper version control (like a git repository) alongside this, as freqtrade will not keep historic versions of your strategy, so it's up to the user to be able to eventually roll back to a prior version of the strategy.</p>"},{"location":"strategy-advanced/#derived-strategies","title":"Derived strategies","text":"<p>The strategies can be derived from other strategies. This avoids duplication of your custom strategy code. You can use this technique to override small parts of your main strategy, leaving the rest untouched:</p> user_data/strategies/myawesomestrategy.py<pre><code>class MyAwesomeStrategy(IStrategy):\n    ...\n    stoploss = 0.13\n    trailing_stop = False\n    # All other attributes and methods are here as they\n    # should be in any custom strategy...\n    ...\n</code></pre> user_data/strategies/MyAwesomeStrategy2.py<pre><code>from myawesomestrategy import MyAwesomeStrategy\nclass MyAwesomeStrategy2(MyAwesomeStrategy):\n    # Override something\n    stoploss = 0.08\n    trailing_stop = True\n</code></pre> <p>Both attributes and methods may be overridden, altering behavior of the original strategy in a way you need.</p> <p>While keeping the subclass in the same file is technically possible, it can lead to some problems with hyperopt parameter files, we therefore recommend to use separate strategy files, and import the parent strategy as shown above.</p>"},{"location":"strategy-advanced/#embedding-strategies","title":"Embedding Strategies","text":"<p>Freqtrade provides you with an easy way to embed the strategy into your configuration file. This is done by utilizing BASE64 encoding and providing this string at the strategy configuration field, in your chosen config file.</p>"},{"location":"strategy-advanced/#encoding-a-string-as-base64","title":"Encoding a string as BASE64","text":"<p>This is a quick example, how to generate the BASE64 string in python</p> <pre><code>from base64 import urlsafe_b64encode\n\nwith open(file, 'r') as f:\n    content = f.read()\ncontent = urlsafe_b64encode(content.encode('utf-8'))\n</code></pre> <p>The variable 'content', will contain the strategy file in a BASE64 encoded form. Which can now be set in your configurations file as following</p> <pre><code>\"strategy\": \"NameOfStrategy:BASE64String\"\n</code></pre> <p>Please ensure that 'NameOfStrategy' is identical to the strategy name!</p>"},{"location":"strategy-advanced/#performance-warning","title":"Performance warning","text":"<p>When executing a strategy, one can sometimes be greeted by the following in the logs</p> <p>PerformanceWarning: DataFrame is highly fragmented.</p> <p>This is a warning from <code>pandas</code> and as the warning continues to say: use <code>pd.concat(axis=1)</code>. This can have slight performance implications, which are usually only visible during hyperopt (when optimizing an indicator).</p> <p>For example:</p> <pre><code>for val in self.buy_ema_short.range:\n    dataframe[f'ema_short_{val}'] = ta.EMA(dataframe, timeperiod=val)\n</code></pre> <p>should be rewritten to</p> <pre><code>frames = [dataframe]\nfor val in self.buy_ema_short.range:\n    frames.append(DataFrame({\n        f'ema_short_{val}': ta.EMA(dataframe, timeperiod=val)\n    }))\n\n# Combine all dataframes, and reassign the original dataframe column\ndataframe = pd.concat(frames, axis=1)\n</code></pre> <p>Freqtrade does however also counter this by running <code>dataframe.copy()</code> on the dataframe right after the <code>populate_indicators()</code> method - so performance implications of this should be low to non-existent.</p>"},{"location":"strategy-callbacks/","title":"Strategy Callbacks","text":"<p>While the main strategy functions (<code>populate_indicators()</code>, <code>populate_entry_trend()</code>, <code>populate_exit_trend()</code>) should be used in a vectorized way, and are only called once during backtesting, callbacks are called \"whenever needed\".</p> <p>As such, you should avoid doing heavy calculations in callbacks to avoid delays during operations. Depending on the callback used, they may be called when entering / exiting a trade, or throughout the duration of a trade.</p> <p>Currently available callbacks:</p> <ul> <li><code>bot_start()</code></li> <li><code>bot_loop_start()</code></li> <li><code>custom_stake_amount()</code></li> <li><code>custom_exit()</code></li> <li><code>custom_stoploss()</code></li> <li><code>custom_entry_price()</code> and <code>custom_exit_price()</code></li> <li><code>check_entry_timeout()</code> and <code>check_exit_timeout()</code></li> <li><code>confirm_trade_entry()</code></li> <li><code>confirm_trade_exit()</code></li> <li><code>adjust_trade_position()</code></li> <li><code>adjust_entry_price()</code></li> <li><code>leverage()</code></li> <li><code>order_filled()</code></li> </ul> <p>Callback calling sequence</p> <p>You can find the callback calling sequence in bot-basics</p>"},{"location":"strategy-callbacks/#bot-start","title":"Bot start","text":"<p>A simple callback which is called once when the strategy is loaded. This can be used to perform actions that must only be performed once and runs after dataprovider and wallet are set</p> <pre><code>import requests\n\nclass AwesomeStrategy(IStrategy):\n\n    # ... populate_* methods\n\n    def bot_start(self, **kwargs) -&gt; None:\n        \"\"\"\n        Called only once after bot instantiation.\n        :param **kwargs: Ensure to keep this here so updates to this won't break your strategy.\n        \"\"\"\n        if self.config['runmode'].value in ('live', 'dry_run'):\n            # Assign this to the class by using self.*\n            # can then be used by populate_* methods\n            self.custom_remote_data = requests.get('https://some_remote_source.example.com')\n</code></pre> <p>During hyperopt, this runs only once at startup.</p>"},{"location":"strategy-callbacks/#bot-loop-start","title":"Bot loop start","text":"<p>A simple callback which is called once at the start of every bot throttling iteration in dry/live mode (roughly every 5 seconds, unless configured differently) or once per candle in backtest/hyperopt mode. This can be used to perform calculations which are pair independent (apply to all pairs), loading of external data, etc.</p> <pre><code>import requests\n\nclass AwesomeStrategy(IStrategy):\n\n    # ... populate_* methods\n\n    def bot_loop_start(self, current_time: datetime, **kwargs) -&gt; None:\n        \"\"\"\n        Called at the start of the bot iteration (one loop).\n        Might be used to perform pair-independent tasks\n        (e.g. gather some remote resource for comparison)\n        :param current_time: datetime object, containing the current datetime\n        :param **kwargs: Ensure to keep this here so updates to this won't break your strategy.\n        \"\"\"\n        if self.config['runmode'].value in ('live', 'dry_run'):\n            # Assign this to the class by using self.*\n            # can then be used by populate_* methods\n            self.remote_data = requests.get('https://some_remote_source.example.com')\n</code></pre>"},{"location":"strategy-callbacks/#stake-size-management","title":"Stake size management","text":"<p>Called before entering a trade, makes it possible to manage your position size when placing a new trade.</p> <pre><code>class AwesomeStrategy(IStrategy):\n    def custom_stake_amount(self, pair: str, current_time: datetime, current_rate: float,\n                            proposed_stake: float, min_stake: Optional[float], max_stake: float,\n                            leverage: float, entry_tag: Optional[str], side: str,\n                            **kwargs) -&gt; float:\n\n        dataframe, _ = self.dp.get_analyzed_dataframe(pair=pair, timeframe=self.timeframe)\n        current_candle = dataframe.iloc[-1].squeeze()\n\n        if current_candle['fastk_rsi_1h'] &gt; current_candle['fastd_rsi_1h']:\n            if self.config['stake_amount'] == 'unlimited':\n                # Use entire available wallet during favorable conditions when in compounding mode.\n                return max_stake\n            else:\n                # Compound profits during favorable conditions instead of using a static stake.\n                return self.wallets.get_total_stake_amount() / self.config['max_open_trades']\n\n        # Use default stake amount.\n        return proposed_stake\n</code></pre> <p>Freqtrade will fall back to the <code>proposed_stake</code> value should your code raise an exception. The exception itself will be logged.</p> <p>Tip</p> <p>You do not have to ensure that <code>min_stake &lt;= returned_value &lt;= max_stake</code>. Trades will succeed as the returned value will be clamped to supported range and this action will be logged.</p> <p>Tip</p> <p>Returning <code>0</code> or <code>None</code> will prevent trades from being placed.</p>"},{"location":"strategy-callbacks/#custom-exit-signal","title":"Custom exit signal","text":"<p>Called for open trade every throttling iteration (roughly every 5 seconds) until a trade is closed.</p> <p>Allows to define custom exit signals, indicating that specified position should be sold. This is very useful when we need to customize exit conditions for each individual trade, or if you need trade data to make an exit decision.</p> <p>For example you could implement a 1:2 risk-reward ROI with <code>custom_exit()</code>.</p> <p>Using <code>custom_exit()</code> signals in place of stoploss though is not recommended. It is a inferior method to using <code>custom_stoploss()</code> in this regard - which also allows you to keep the stoploss on exchange.</p> <p>Note</p> <p>Returning a (none-empty) <code>string</code> or <code>True</code> from this method is equal to setting exit signal on a candle at specified time. This method is not called when exit signal is set already, or if exit signals are disabled (<code>use_exit_signal=False</code>). <code>string</code> max length is 64 characters. Exceeding this limit will cause the message to be truncated to 64 characters. <code>custom_exit()</code> will ignore <code>exit_profit_only</code>, and will always be called unless <code>use_exit_signal=False</code>, even if there is a new enter signal.</p> <p>An example of how we can use different indicators depending on the current profit and also exit trades that were open longer than one day:</p> <pre><code>class AwesomeStrategy(IStrategy):\n    def custom_exit(self, pair: str, trade: 'Trade', current_time: 'datetime', current_rate: float,\n                    current_profit: float, **kwargs):\n        dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe)\n        last_candle = dataframe.iloc[-1].squeeze()\n\n        # Above 20% profit, sell when rsi &lt; 80\n        if current_profit &gt; 0.2:\n            if last_candle['rsi'] &lt; 80:\n                return 'rsi_below_80'\n\n        # Between 2% and 10%, sell if EMA-long above EMA-short\n        if 0.02 &lt; current_profit &lt; 0.1:\n            if last_candle['emalong'] &gt; last_candle['emashort']:\n                return 'ema_long_below_80'\n\n        # Sell any positions at a loss if they are held for more than one day.\n        if current_profit &lt; 0.0 and (current_time - trade.open_date_utc).days &gt;= 1:\n            return 'unclog'\n</code></pre> <p>See Dataframe access for more information about dataframe use in strategy callbacks.</p>"},{"location":"strategy-callbacks/#custom-stoploss","title":"Custom stoploss","text":"<p>Called for open trade every iteration (roughly every 5 seconds) until a trade is closed.</p> <p>The usage of the custom stoploss method must be enabled by setting <code>use_custom_stoploss=True</code> on the strategy object.</p> <p>The stoploss price can only ever move upwards - if the stoploss value returned from <code>custom_stoploss</code> would result in a lower stoploss price than was previously set, it will be ignored. The traditional <code>stoploss</code> value serves as an absolute lower level and will be instated as the initial stoploss (before this method is called for the first time for a trade), and is still mandatory.</p> <p>The method must return a stoploss value (float / number) as a percentage of the current price. E.g. If the <code>current_rate</code> is 200 USD, then returning <code>0.02</code> will set the stoploss price 2% lower, at 196 USD. During backtesting, <code>current_rate</code> (and <code>current_profit</code>) are provided against the candle's high (or low for short trades) - while the resulting stoploss is evaluated against the candle's low (or high for short trades).</p> <p>The absolute value of the return value is used (the sign is ignored), so returning <code>0.05</code> or <code>-0.05</code> have the same result, a stoploss 5% below the current price. Returning <code>None</code> will be interpreted as \"no desire to change\", and is the only safe way to return when you'd like to not modify the stoploss. <code>NaN</code> and <code>inf</code> values are considered invalid and will be ignored (identical to <code>None</code>).</p> <p>Stoploss on exchange works similar to <code>trailing_stop</code>, and the stoploss on exchange is updated as configured in <code>stoploss_on_exchange_interval</code> (More details about stoploss on exchange).</p> <p>Use of dates</p> <p>All time-based calculations should be done based on <code>current_time</code> - using <code>datetime.now()</code> or <code>datetime.utcnow()</code> is discouraged, as this will break backtesting support.</p> <p>Trailing stoploss</p> <p>It's recommended to disable <code>trailing_stop</code> when using custom stoploss values. Both can work in tandem, but you might encounter the trailing stop to move the price higher while your custom function would not want this, causing conflicting behavior.</p>"},{"location":"strategy-callbacks/#adjust-stoploss-after-position-adjustments","title":"Adjust stoploss after position adjustments","text":"<p>Depending on your strategy, you may encounter the need to adjust the stoploss in both directions after a position adjustment. For this, freqtrade will make an additional call with <code>after_fill=True</code> after an order fills, which will allow the strategy to move the stoploss in any direction (also widening the gap between stoploss and current price, which is otherwise forbidden).</p> <p>backwards compatibility</p> <p>This call will only be made if the <code>after_fill</code> parameter is part of the function definition of your <code>custom_stoploss</code> function. As such, this will not impact (and with that, surprise) existing, running strategies.</p>"},{"location":"strategy-callbacks/#custom-stoploss-examples","title":"Custom stoploss examples","text":"<p>The next section will show some examples on what's possible with the custom stoploss function. Of course, many more things are possible, and all examples can be combined at will.</p>"},{"location":"strategy-callbacks/#trailing-stop-via-custom-stoploss","title":"Trailing stop via custom stoploss","text":"<p>To simulate a regular trailing stoploss of 4% (trailing 4% behind the maximum reached price) you would use the following very simple method:</p> <pre><code># additional imports required\nfrom datetime import datetime\nfrom freqtrade.persistence import Trade\n\nclass AwesomeStrategy(IStrategy):\n\n    # ... populate_* methods\n\n    use_custom_stoploss = True\n\n    def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime,\n                        current_rate: float, current_profit: float, after_fill: bool, \n                        **kwargs) -&gt; Optional[float]:\n        \"\"\"\n        Custom stoploss logic, returning the new distance relative to current_rate (as ratio).\n        e.g. returning -0.05 would create a stoploss 5% below current_rate.\n        The custom stoploss can never be below self.stoploss, which serves as a hard maximum loss.\n\n        For full documentation please go to https://www.freqtrade.io/en/latest/strategy-advanced/\n\n        When not implemented by a strategy, returns the initial stoploss value.\n        Only called when use_custom_stoploss is set to True.\n\n        :param pair: Pair that's currently analyzed\n        :param trade: trade object.\n        :param current_time: datetime object, containing the current datetime\n        :param current_rate: Rate, calculated based on pricing settings in exit_pricing.\n        :param current_profit: Current profit (as ratio), calculated based on current_rate.\n        :param after_fill: True if the stoploss is called after the order was filled.\n        :param **kwargs: Ensure to keep this here so updates to this won't break your strategy.\n        :return float: New stoploss value, relative to the current_rate\n        \"\"\"\n        return -0.04\n</code></pre>"},{"location":"strategy-callbacks/#time-based-trailing-stop","title":"Time based trailing stop","text":"<p>Use the initial stoploss for the first 60 minutes, after this change to 10% trailing stoploss, and after 2 hours (120 minutes) we use a 5% trailing stoploss.</p> <pre><code>from datetime import datetime, timedelta\nfrom freqtrade.persistence import Trade\n\nclass AwesomeStrategy(IStrategy):\n\n    # ... populate_* methods\n\n    use_custom_stoploss = True\n\n    def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime,\n                        current_rate: float, current_profit: float, after_fill: bool, \n                        **kwargs) -&gt; Optional[float]:\n\n        # Make sure you have the longest interval first - these conditions are evaluated from top to bottom.\n        if current_time - timedelta(minutes=120) &gt; trade.open_date_utc:\n            return -0.05\n        elif current_time - timedelta(minutes=60) &gt; trade.open_date_utc:\n            return -0.10\n        return None\n</code></pre>"},{"location":"strategy-callbacks/#time-based-trailing-stop-with-after-fill-adjustments","title":"Time based trailing stop with after-fill adjustments","text":"<p>Use the initial stoploss for the first 60 minutes, after this change to 10% trailing stoploss, and after 2 hours (120 minutes) we use a 5% trailing stoploss. If an additional order fills, set stoploss to -10% below the new <code>open_rate</code> (Averaged across all entries).</p> <pre><code>from datetime import datetime, timedelta\nfrom freqtrade.persistence import Trade\n\nclass AwesomeStrategy(IStrategy):\n\n    # ... populate_* methods\n\n    use_custom_stoploss = True\n\n    def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime,\n                        current_rate: float, current_profit: float, after_fill: bool, \n                        **kwargs) -&gt; Optional[float]:\n\n        if after_fill: \n            # After an additional order, start with a stoploss of 10% below the new open rate\n            return stoploss_from_open(0.10, current_profit, is_short=trade.is_short, leverage=trade.leverage)\n        # Make sure you have the longest interval first - these conditions are evaluated from top to bottom.\n        if current_time - timedelta(minutes=120) &gt; trade.open_date_utc:\n            return -0.05\n        elif current_time - timedelta(minutes=60) &gt; trade.open_date_utc:\n            return -0.10\n        return None\n</code></pre>"},{"location":"strategy-callbacks/#different-stoploss-per-pair","title":"Different stoploss per pair","text":"<p>Use a different stoploss depending on the pair. In this example, we'll trail the highest price with 10% trailing stoploss for <code>ETH/BTC</code> and <code>XRP/BTC</code>, with 5% trailing stoploss for <code>LTC/BTC</code> and with 15% for all other pairs.</p> <pre><code>from datetime import datetime\nfrom freqtrade.persistence import Trade\n\nclass AwesomeStrategy(IStrategy):\n\n    # ... populate_* methods\n\n    use_custom_stoploss = True\n\n    def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime,\n                        current_rate: float, current_profit: float, after_fill: bool,\n                        **kwargs) -&gt; Optional[float]:\n\n        if pair in ('ETH/BTC', 'XRP/BTC'):\n            return -0.10\n        elif pair in ('LTC/BTC'):\n            return -0.05\n        return -0.15\n</code></pre>"},{"location":"strategy-callbacks/#trailing-stoploss-with-positive-offset","title":"Trailing stoploss with positive offset","text":"<p>Use the initial stoploss until the profit is above 4%, then use a trailing stoploss of 50% of the current profit with a minimum of 2.5% and a maximum of 5%.</p> <p>Please note that the stoploss can only increase, values lower than the current stoploss are ignored.</p> <pre><code>from datetime import datetime, timedelta\nfrom freqtrade.persistence import Trade\n\nclass AwesomeStrategy(IStrategy):\n\n    # ... populate_* methods\n\n    use_custom_stoploss = True\n\n    def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime,\n                        current_rate: float, current_profit: float, after_fill: bool,\n                        **kwargs) -&gt; Optional[float]:\n\n        if current_profit &lt; 0.04:\n            return None # return None to keep using the initial stoploss\n\n        # After reaching the desired offset, allow the stoploss to trail by half the profit\n        desired_stoploss = current_profit / 2\n\n        # Use a minimum of 2.5% and a maximum of 5%\n        return max(min(desired_stoploss, 0.05), 0.025)\n</code></pre>"},{"location":"strategy-callbacks/#stepped-stoploss","title":"Stepped stoploss","text":"<p>Instead of continuously trailing behind the current price, this example sets fixed stoploss price levels based on the current profit.</p> <ul> <li>Use the regular stoploss until 20% profit is reached</li> <li>Once profit is &gt; 20% - set stoploss to 7% above open price.</li> <li>Once profit is &gt; 25% - set stoploss to 15% above open price.</li> <li>Once profit is &gt; 40% - set stoploss to 25% above open price.</li> </ul> <pre><code>from datetime import datetime\nfrom freqtrade.persistence import Trade\nfrom freqtrade.strategy import stoploss_from_open\n\nclass AwesomeStrategy(IStrategy):\n\n    # ... populate_* methods\n\n    use_custom_stoploss = True\n\n    def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime,\n                        current_rate: float, current_profit: float, after_fill: bool,\n                        **kwargs) -&gt; Optional[float]:\n\n        # evaluate highest to lowest, so that highest possible stop is used\n        if current_profit &gt; 0.40:\n            return stoploss_from_open(0.25, current_profit, is_short=trade.is_short, leverage=trade.leverage)\n        elif current_profit &gt; 0.25:\n            return stoploss_from_open(0.15, current_profit, is_short=trade.is_short, leverage=trade.leverage)\n        elif current_profit &gt; 0.20:\n            return stoploss_from_open(0.07, current_profit, is_short=trade.is_short, leverage=trade.leverage)\n\n        # return maximum stoploss value, keeping current stoploss price unchanged\n        return None\n</code></pre>"},{"location":"strategy-callbacks/#custom-stoploss-using-an-indicator-from-dataframe-example","title":"Custom stoploss using an indicator from dataframe example","text":"<p>Absolute stoploss value may be derived from indicators stored in dataframe. Example uses parabolic SAR below the price as stoploss.</p> <pre><code>class AwesomeStrategy(IStrategy):\n\n    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        # &lt;...&gt;\n        dataframe['sar'] = ta.SAR(dataframe)\n\n    use_custom_stoploss = True\n\n    def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime,\n                        current_rate: float, current_profit: float, after_fill: bool,\n                        **kwargs) -&gt; Optional[float]:\n\n        dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe)\n        last_candle = dataframe.iloc[-1].squeeze()\n\n        # Use parabolic sar as absolute stoploss price\n        stoploss_price = last_candle['sar']\n\n        # Convert absolute price to percentage relative to current_rate\n        if stoploss_price &lt; current_rate:\n            return stoploss_from_absolute(stoploss_price, current_rate, is_short=trade.is_short)\n\n        # return maximum stoploss value, keeping current stoploss price unchanged\n        return None\n</code></pre> <p>See Dataframe access for more information about dataframe use in strategy callbacks.</p>"},{"location":"strategy-callbacks/#common-helpers-for-stoploss-calculations","title":"Common helpers for stoploss calculations","text":""},{"location":"strategy-callbacks/#stoploss-relative-to-open-price","title":"Stoploss relative to open price","text":"<p>Stoploss values returned from <code>custom_stoploss()</code> must specify a percentage relative to <code>current_rate</code>, but sometimes you may want to specify a stoploss relative to the entry price instead. <code>stoploss_from_open()</code> is a helper function to calculate a stoploss value that can be returned from <code>custom_stoploss</code> which will be equivalent to the desired trade profit above the entry point.</p> Returning a stoploss relative to the open price from the custom stoploss function <p>Say the open price was $100, and <code>current_price</code> is $121 (<code>current_profit</code> will be <code>0.21</code>).  </p> <p>If we want a stop price at 7% above the open price we can call <code>stoploss_from_open(0.07, current_profit, False)</code> which will return <code>0.1157024793</code>.  11.57% below $121 is $107, which is the same as 7% above $100.</p> <p>This function will consider leverage - so at 10x leverage, the actual stoploss would be 0.7% above $100 (0.7% * 10x = 7%).</p> <pre><code>from datetime import datetime\nfrom freqtrade.persistence import Trade\nfrom freqtrade.strategy import IStrategy, stoploss_from_open\n\nclass AwesomeStrategy(IStrategy):\n\n    # ... populate_* methods\n\n    use_custom_stoploss = True\n\n    def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime,\n                        current_rate: float, current_profit: float, after_fill: bool,\n                        **kwargs) -&gt; Optional[float]:\n\n        # once the profit has risen above 10%, keep the stoploss at 7% above the open price\n        if current_profit &gt; 0.10:\n            return stoploss_from_open(0.07, current_profit, is_short=trade.is_short, leverage=trade.leverage)\n\n        return 1\n</code></pre> <p>Full examples can be found in the Custom stoploss section of the Documentation.</p> <p>Note</p> <p>Providing invalid input to <code>stoploss_from_open()</code> may produce \"CustomStoploss function did not return valid stoploss\" warnings. This may happen if <code>current_profit</code> parameter is below specified <code>open_relative_stop</code>. Such situations may arise when closing trade is blocked by <code>confirm_trade_exit()</code> method. Warnings can be solved by never blocking stop loss sells by checking <code>exit_reason</code> in <code>confirm_trade_exit()</code>, or by using <code>return stoploss_from_open(...) or 1</code> idiom, which will request to not change stop loss when <code>current_profit &lt; open_relative_stop</code>.</p>"},{"location":"strategy-callbacks/#stoploss-percentage-from-absolute-price","title":"Stoploss percentage from absolute price","text":"<p>Stoploss values returned from <code>custom_stoploss()</code> always specify a percentage relative to <code>current_rate</code>. In order to set a stoploss at specified absolute price level, we need to use <code>stop_rate</code> to calculate what percentage relative to the <code>current_rate</code> will give you the same result as if the percentage was specified from the open price.</p> <p>The helper function <code>stoploss_from_absolute()</code> can be used to convert from an absolute price, to a current price relative stop which can be returned from <code>custom_stoploss()</code>.</p> Returning a stoploss using absolute price from the custom stoploss function <p>If we want to trail a stop price at 2xATR below current price we can call <code>stoploss_from_absolute(current_rate + (side * candle['atr'] * 2), current_rate=current_rate, is_short=trade.is_short, leverage=trade.leverage)</code>. For futures, we need to adjust the direction (up or down), as well as adjust for leverage, since the <code>custom_stoploss</code> callback  returns the \"risk for this trade\" - not the relative price movement.</p> <pre><code>from datetime import datetime\nfrom freqtrade.persistence import Trade\nfrom freqtrade.strategy import IStrategy, stoploss_from_absolute, timeframe_to_prev_date\n\nclass AwesomeStrategy(IStrategy):\n\n    use_custom_stoploss = True\n\n    def populate_indicators_1h(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        dataframe['atr'] = ta.ATR(dataframe, timeperiod=14)\n        return dataframe\n\n    def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime,\n                        current_rate: float, current_profit: float, after_fill: bool,\n                        **kwargs) -&gt; Optional[float]:\n        dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe)\n        trade_date = timeframe_to_prev_date(self.timeframe, trade.open_date_utc)\n        candle = dataframe.iloc[-1].squeeze()\n        side = 1 if trade.is_short else -1\n        return stoploss_from_absolute(current_rate + (side * candle['atr'] * 2), \n                                      current_rate=current_rate, \n                                      is_short=trade.is_short,\n                                      leverage=trade.leverage)\n</code></pre>"},{"location":"strategy-callbacks/#custom-order-price-rules","title":"Custom order price rules","text":"<p>By default, freqtrade use the orderbook to automatically set an order price(Relevant documentation), you also have the option to create custom order prices based on your strategy.</p> <p>You can use this feature by creating a <code>custom_entry_price()</code> function in your strategy file to customize entry prices and <code>custom_exit_price()</code> for exits.</p> <p>Each of these methods are called right before placing an order on the exchange.</p> <p>Note</p> <p>If your custom pricing function return None or an invalid value, price will fall back to <code>proposed_rate</code>, which is based on the regular pricing configuration.</p> <p>Note</p> <p>Using custom_entry_price, the Trade object will be available as soon as the first entry order associated with the trade is created, for the first entry, <code>trade</code> parameter value will be <code>None</code>.</p>"},{"location":"strategy-callbacks/#custom-order-entry-and-exit-price-example","title":"Custom order entry and exit price example","text":"<pre><code>from datetime import datetime, timedelta, timezone\nfrom freqtrade.persistence import Trade\n\nclass AwesomeStrategy(IStrategy):\n\n    # ... populate_* methods\n\n    def custom_entry_price(self, pair: str, trade: Optional['Trade'], current_time: datetime, proposed_rate: float,\n                           entry_tag: Optional[str], side: str, **kwargs) -&gt; float:\n\n        dataframe, last_updated = self.dp.get_analyzed_dataframe(pair=pair,\n                                                                timeframe=self.timeframe)\n        new_entryprice = dataframe['bollinger_10_lowerband'].iat[-1]\n\n        return new_entryprice\n\n    def custom_exit_price(self, pair: str, trade: Trade,\n                          current_time: datetime, proposed_rate: float,\n                          current_profit: float, exit_tag: Optional[str], **kwargs) -&gt; float:\n\n        dataframe, last_updated = self.dp.get_analyzed_dataframe(pair=pair,\n                                                                timeframe=self.timeframe)\n        new_exitprice = dataframe['bollinger_10_upperband'].iat[-1]\n\n        return new_exitprice\n</code></pre> <p>Warning</p> <p>Modifying entry and exit prices will only work for limit orders. Depending on the price chosen, this can result in a lot of unfilled orders. By default the maximum allowed distance between the current price and the custom price is 2%, this value can be changed in config with the <code>custom_price_max_distance_ratio</code> parameter. Example: If the new_entryprice is 97, the proposed_rate is 100 and the <code>custom_price_max_distance_ratio</code> is set to 2%, The retained valid custom entry price will be 98, which is 2% below the current (proposed) rate.</p> <p>Backtesting</p> <p>Custom prices are supported in backtesting (starting with 2021.12), and orders will fill if the price falls within the candle's low/high range. Orders that don't fill immediately are subject to regular timeout handling, which happens once per (detail) candle. <code>custom_exit_price()</code> is only called for sells of type exit_signal, Custom exit and partial exits. All other exit-types will use regular backtesting prices.</p>"},{"location":"strategy-callbacks/#custom-order-timeout-rules","title":"Custom order timeout rules","text":"<p>Simple, time-based order-timeouts can be configured either via strategy or in the configuration in the <code>unfilledtimeout</code> section.</p> <p>However, freqtrade also offers a custom callback for both order types, which allows you to decide based on custom criteria if an order did time out or not.</p> <p>Note</p> <p>Backtesting fills orders if their price falls within the candle's low/high range. The below callbacks will be called once per (detail) candle for orders that don't fill immediately (which use custom pricing).</p>"},{"location":"strategy-callbacks/#custom-order-timeout-example","title":"Custom order timeout example","text":"<p>Called for every open order until that order is either filled or cancelled. <code>check_entry_timeout()</code> is called for trade entries, while <code>check_exit_timeout()</code> is called for trade exit orders.</p> <p>A simple example, which applies different unfilled-timeouts depending on the price of the asset can be seen below. It applies a tight timeout for higher priced assets, while allowing more time to fill on cheap coins.</p> <p>The function must return either <code>True</code> (cancel order) or <code>False</code> (keep order alive).</p> <pre><code>from datetime import datetime, timedelta\nfrom freqtrade.persistence import Trade, Order\n\nclass AwesomeStrategy(IStrategy):\n\n    # ... populate_* methods\n\n    # Set unfilledtimeout to 25 hours, since the maximum timeout from below is 24 hours.\n    unfilledtimeout = {\n        'entry': 60 * 25,\n        'exit': 60 * 25\n    }\n\n    def check_entry_timeout(self, pair: str, trade: 'Trade', order: 'Order',\n                            current_time: datetime, **kwargs) -&gt; bool:\n        if trade.open_rate &gt; 100 and trade.open_date_utc &lt; current_time - timedelta(minutes=5):\n            return True\n        elif trade.open_rate &gt; 10 and trade.open_date_utc &lt; current_time - timedelta(minutes=3):\n            return True\n        elif trade.open_rate &lt; 1 and trade.open_date_utc &lt; current_time - timedelta(hours=24):\n           return True\n        return False\n\n\n    def check_exit_timeout(self, pair: str, trade: Trade, order: 'Order',\n                           current_time: datetime, **kwargs) -&gt; bool:\n        if trade.open_rate &gt; 100 and trade.open_date_utc &lt; current_time - timedelta(minutes=5):\n            return True\n        elif trade.open_rate &gt; 10 and trade.open_date_utc &lt; current_time - timedelta(minutes=3):\n            return True\n        elif trade.open_rate &lt; 1 and trade.open_date_utc &lt; current_time - timedelta(hours=24):\n           return True\n        return False\n</code></pre> <p>Note</p> <p>For the above example, <code>unfilledtimeout</code> must be set to something bigger than 24h, otherwise that type of timeout will apply first.</p>"},{"location":"strategy-callbacks/#custom-order-timeout-example-using-additional-data","title":"Custom order timeout example (using additional data)","text":"<pre><code>from datetime import datetime\nfrom freqtrade.persistence import Trade, Order\n\nclass AwesomeStrategy(IStrategy):\n\n    # ... populate_* methods\n\n    # Set unfilledtimeout to 25 hours, since the maximum timeout from below is 24 hours.\n    unfilledtimeout = {\n        'entry': 60 * 25,\n        'exit': 60 * 25\n    }\n\n    def check_entry_timeout(self, pair: str, trade: 'Trade', order: 'Order',\n                            current_time: datetime, **kwargs) -&gt; bool:\n        ob = self.dp.orderbook(pair, 1)\n        current_price = ob['bids'][0][0]\n        # Cancel buy order if price is more than 2% above the order.\n        if current_price &gt; order.price * 1.02:\n            return True\n        return False\n\n\n    def check_exit_timeout(self, pair: str, trade: 'Trade', order: 'Order',\n                           current_time: datetime, **kwargs) -&gt; bool:\n        ob = self.dp.orderbook(pair, 1)\n        current_price = ob['asks'][0][0]\n        # Cancel sell order if price is more than 2% below the order.\n        if current_price &lt; order.price * 0.98:\n            return True\n        return False\n</code></pre>"},{"location":"strategy-callbacks/#bot-order-confirmation","title":"Bot order confirmation","text":"<p>Confirm trade entry / exits. This are the last methods that will be called before an order is placed.</p>"},{"location":"strategy-callbacks/#trade-entry-buy-order-confirmation","title":"Trade entry (buy order) confirmation","text":"<p><code>confirm_trade_entry()</code> can be used to abort a trade entry at the latest second (maybe because the price is not what we expect).</p> <pre><code>class AwesomeStrategy(IStrategy):\n\n    # ... populate_* methods\n\n    def confirm_trade_entry(self, pair: str, order_type: str, amount: float, rate: float,\n                            time_in_force: str, current_time: datetime, entry_tag: Optional[str],\n                            side: str, **kwargs) -&gt; bool:\n        \"\"\"\n        Called right before placing a entry order.\n        Timing for this function is critical, so avoid doing heavy computations or\n        network requests in this method.\n\n        For full documentation please go to https://www.freqtrade.io/en/latest/strategy-advanced/\n\n        When not implemented by a strategy, returns True (always confirming).\n\n        :param pair: Pair that's about to be bought/shorted.\n        :param order_type: Order type (as configured in order_types). usually limit or market.\n        :param amount: Amount in target (base) currency that's going to be traded.\n        :param rate: Rate that's going to be used when using limit orders \n                     or current rate for market orders.\n        :param time_in_force: Time in force. Defaults to GTC (Good-til-cancelled).\n        :param current_time: datetime object, containing the current datetime\n        :param entry_tag: Optional entry_tag (buy_tag) if provided with the buy signal.\n        :param side: 'long' or 'short' - indicating the direction of the proposed trade\n        :param **kwargs: Ensure to keep this here so updates to this won't break your strategy.\n        :return bool: When True is returned, then the buy-order is placed on the exchange.\n            False aborts the process\n        \"\"\"\n        return True\n</code></pre>"},{"location":"strategy-callbacks/#trade-exit-sell-order-confirmation","title":"Trade exit (sell order) confirmation","text":"<p><code>confirm_trade_exit()</code> can be used to abort a trade exit (sell) at the latest second (maybe because the price is not what we expect).</p> <p><code>confirm_trade_exit()</code> may be called multiple times within one iteration for the same trade if different exit-reasons apply. The exit-reasons (if applicable) will be in the following sequence:</p> <ul> <li><code>exit_signal</code> / <code>custom_exit</code></li> <li><code>stop_loss</code></li> <li><code>roi</code></li> <li><code>trailing_stop_loss</code></li> </ul> <pre><code>from freqtrade.persistence import Trade\n\n\nclass AwesomeStrategy(IStrategy):\n\n    # ... populate_* methods\n\n    def confirm_trade_exit(self, pair: str, trade: Trade, order_type: str, amount: float,\n                           rate: float, time_in_force: str, exit_reason: str,\n                           current_time: datetime, **kwargs) -&gt; bool:\n        \"\"\"\n        Called right before placing a regular exit order.\n        Timing for this function is critical, so avoid doing heavy computations or\n        network requests in this method.\n\n        For full documentation please go to https://www.freqtrade.io/en/latest/strategy-advanced/\n\n        When not implemented by a strategy, returns True (always confirming).\n\n        :param pair: Pair for trade that's about to be exited.\n        :param trade: trade object.\n        :param order_type: Order type (as configured in order_types). usually limit or market.\n        :param amount: Amount in base currency.\n        :param rate: Rate that's going to be used when using limit orders\n                     or current rate for market orders.\n        :param time_in_force: Time in force. Defaults to GTC (Good-til-cancelled).\n        :param exit_reason: Exit reason.\n            Can be any of ['roi', 'stop_loss', 'stoploss_on_exchange', 'trailing_stop_loss',\n                           'exit_signal', 'force_exit', 'emergency_exit']\n        :param current_time: datetime object, containing the current datetime\n        :param **kwargs: Ensure to keep this here so updates to this won't break your strategy.\n        :return bool: When True, then the exit-order is placed on the exchange.\n            False aborts the process\n        \"\"\"\n        if exit_reason == 'force_exit' and trade.calc_profit_ratio(rate) &lt; 0:\n            # Reject force-sells with negative profit\n            # This is just a sample, please adjust to your needs\n            # (this does not necessarily make sense, assuming you know when you're force-selling)\n            return False\n        return True\n</code></pre> <p>Warning</p> <p><code>confirm_trade_exit()</code> can prevent stoploss exits, causing significant losses as this would ignore stoploss exits. <code>confirm_trade_exit()</code> will not be called for Liquidations - as liquidations are forced by the exchange, and therefore cannot be rejected.</p>"},{"location":"strategy-callbacks/#adjust-trade-position","title":"Adjust trade position","text":"<p>The <code>position_adjustment_enable</code> strategy property enables the usage of <code>adjust_trade_position()</code> callback in the strategy. For performance reasons, it's disabled by default and freqtrade will show a warning message on startup if enabled. <code>adjust_trade_position()</code> can be used to perform additional orders, for example to manage risk with DCA (Dollar Cost Averaging) or to increase or decrease positions.</p> <p>Additional orders also result in additional fees and those orders don't count towards <code>max_open_trades</code>.</p> <p>This callback is not called when there is an open order (either buy or sell) waiting for execution.</p> <p><code>adjust_trade_position()</code> is called very frequently for the duration of a trade, so you must keep your implementation as performant as possible.</p> <p>Position adjustments will always be applied in the direction of the trade, so a positive value will always increase your position (negative values will decrease your position), no matter if it's a long or short trade. Adjustment orders can be assigned with a tag by returning a 2 element Tuple, with the first element being the adjustment amount, and the 2<sup>nd</sup> element the tag (e.g. <code>return 250, 'increase_favorable_conditions'</code>).</p> <p>Modifications to leverage are not possible, and the stake-amount returned is assumed to be before applying leverage.</p>"},{"location":"strategy-callbacks/#increase-position","title":"Increase position","text":"<p>The strategy is expected to return a positive stake_amount (in stake currency) between <code>min_stake</code> and <code>max_stake</code> if and when an additional entry order should be made (position is increased -&gt; buy order for long trades, sell order for short trades).</p> <p>If there are not enough funds in the wallet (the return value is above <code>max_stake</code>) then the signal will be ignored. <code>max_entry_position_adjustment</code> property is used to limit the number of additional entries per trade (on top of the first entry order) that the bot can execute. By default, the value is -1 which means the bot have no limit on number of adjustment entries.</p> <p>Additional entries are ignored once you have reached the maximum amount of extra entries that you have set on <code>max_entry_position_adjustment</code>, but the callback is called anyway looking for partial exits.</p>"},{"location":"strategy-callbacks/#decrease-position","title":"Decrease position","text":"<p>The strategy is expected to return a negative stake_amount (in stake currency) for a partial exit. Returning the full owned stake at that point (<code>-trade.stake_amount</code>) results in a full exit. Returning a value more than the above (so remaining stake_amount would become negative) will result in the bot ignoring the signal.</p> <p>About stake size</p> <p>Using fixed stake size means it will be the amount used for the first order, just like without position adjustment. If you wish to buy additional orders with DCA, then make sure to leave enough funds in the wallet for that. Using 'unlimited' stake amount with DCA orders requires you to also implement the <code>custom_stake_amount()</code> callback to avoid allocating all funds to the initial order.</p> <p>Stoploss calculation</p> <p>Stoploss is still calculated from the initial opening price, not averaged price. Regular stoploss rules still apply (cannot move down).</p> <p>While <code>/stopentry</code> command stops the bot from entering new trades, the position adjustment feature will continue buying new orders on existing trades.</p> <p>Backtesting</p> <p>During backtesting this callback is called for each candle in <code>timeframe</code> or <code>timeframe_detail</code>, so run-time performance will be affected. This can also cause deviating results between live and backtesting, since backtesting can adjust the trade only once per candle, whereas live could adjust the trade multiple times per candle.</p> <p>Performance with many position adjustments</p> <p>Position adjustments can be a good approach to increase a strategy's output - but it can also have drawbacks if using this feature extensively. Each of the orders will be attached to the trade object for the duration of the trade - hence increasing memory usage. Trades with long duration and 10s or even 100ds of position adjustments are therefore not recommended, and should be closed at regular intervals to not affect performance.</p> <pre><code>from freqtrade.persistence import Trade\nfrom typing import Optional, Tuple, Union\n\n\nclass DigDeeperStrategy(IStrategy):\n\n    position_adjustment_enable = True\n\n    # Attempts to handle large drops with DCA. High stoploss is required.\n    stoploss = -0.30\n\n    # ... populate_* methods\n\n    # Example specific variables\n    max_entry_position_adjustment = 3\n    # This number is explained a bit further down\n    max_dca_multiplier = 5.5\n\n    # This is called when placing the initial order (opening trade)\n    def custom_stake_amount(self, pair: str, current_time: datetime, current_rate: float,\n                            proposed_stake: float, min_stake: Optional[float], max_stake: float,\n                            leverage: float, entry_tag: Optional[str], side: str,\n                            **kwargs) -&gt; float:\n\n        # We need to leave most of the funds for possible further DCA orders\n        # This also applies to fixed stakes\n        return proposed_stake / self.max_dca_multiplier\n\n    def adjust_trade_position(self, trade: Trade, current_time: datetime,\n                              current_rate: float, current_profit: float,\n                              min_stake: Optional[float], max_stake: float,\n                              current_entry_rate: float, current_exit_rate: float,\n                              current_entry_profit: float, current_exit_profit: float,\n                              **kwargs\n                              ) -&gt; Union[Optional[float], Tuple[Optional[float], Optional[str]]]:\n        \"\"\"\n        Custom trade adjustment logic, returning the stake amount that a trade should be\n        increased or decreased.\n        This means extra entry or exit orders with additional fees.\n        Only called when `position_adjustment_enable` is set to True.\n\n        For full documentation please go to https://www.freqtrade.io/en/latest/strategy-advanced/\n\n        When not implemented by a strategy, returns None\n\n        :param trade: trade object.\n        :param current_time: datetime object, containing the current datetime\n        :param current_rate: Current entry rate (same as current_entry_profit)\n        :param current_profit: Current profit (as ratio), calculated based on current_rate \n                               (same as current_entry_profit).\n        :param min_stake: Minimal stake size allowed by exchange (for both entries and exits)\n        :param max_stake: Maximum stake allowed (either through balance, or by exchange limits).\n        :param current_entry_rate: Current rate using entry pricing.\n        :param current_exit_rate: Current rate using exit pricing.\n        :param current_entry_profit: Current profit using entry pricing.\n        :param current_exit_profit: Current profit using exit pricing.\n        :param **kwargs: Ensure to keep this here so updates to this won't break your strategy.\n        :return float: Stake amount to adjust your trade,\n                       Positive values to increase position, Negative values to decrease position.\n                       Return None for no action.\n                       Optionally, return a tuple with a 2nd element with an order reason\n        \"\"\"\n\n        if current_profit &gt; 0.05 and trade.nr_of_successful_exits == 0:\n            # Take half of the profit at +5%\n            return -(trade.stake_amount / 2), 'half_profit_5%'\n\n        if current_profit &gt; -0.05:\n            return None\n\n        # Obtain pair dataframe (just to show how to access it)\n        dataframe, _ = self.dp.get_analyzed_dataframe(trade.pair, self.timeframe)\n        # Only buy when not actively falling price.\n        last_candle = dataframe.iloc[-1].squeeze()\n        previous_candle = dataframe.iloc[-2].squeeze()\n        if last_candle['close'] &lt; previous_candle['close']:\n            return None\n\n        filled_entries = trade.select_filled_orders(trade.entry_side)\n        count_of_entries = trade.nr_of_successful_entries\n        # Allow up to 3 additional increasingly larger buys (4 in total)\n        # Initial buy is 1x\n        # If that falls to -5% profit, we buy 1.25x more, average profit should increase to roughly -2.2%\n        # If that falls down to -5% again, we buy 1.5x more\n        # If that falls once again down to -5%, we buy 1.75x more\n        # Total stake for this trade would be 1 + 1.25 + 1.5 + 1.75 = 5.5x of the initial allowed stake.\n        # That is why max_dca_multiplier is 5.5\n        # Hope you have a deep wallet!\n        try:\n            # This returns first order stake size\n            stake_amount = filled_entries[0].stake_amount\n            # This then calculates current safety order size\n            stake_amount = stake_amount * (1 + (count_of_entries * 0.25))\n            return stake_amount, '1/3rd_increase'\n        except Exception as exception:\n            return None\n\n        return None\n</code></pre>"},{"location":"strategy-callbacks/#position-adjust-calculations","title":"Position adjust calculations","text":"<ul> <li>Entry rates are calculated using weighted averages.</li> <li>Exits will not influence the average entry rate.</li> <li>Partial exit relative profit is relative to the average entry price at this point.</li> <li>Final exit relative profit is calculated based on the total invested capital. (See example below)</li> </ul> Calculation example <p>This example assumes 0 fees for simplicity, and a long position on an imaginary coin. </p> <ul> <li>Buy 100@8$ </li> <li>Buy 100@9$ -&gt; Avg price: 8.5$</li> <li>Sell 100@10$ -&gt; Avg price: 8.5$, realized profit 150$, 17.65%</li> <li>Buy 150@11$ -&gt; Avg price: 10$, realized profit 150$, 17.65%</li> <li>Sell 100@12$ -&gt; Avg price: 10$, total realized profit 350$, 20%</li> <li>Sell 150@14$ -&gt; Avg price: 10$, total realized profit 950$, 40%  &lt;- This will be the last \"Exit\" message</li> </ul> <p>The total profit for this trade was 950$ on a 3350$ investment (<code>100@8$ + 100@9$ + 150@11$</code>). As such - the final relative profit is 28.35% (<code>950 / 3350</code>).</p>"},{"location":"strategy-callbacks/#adjust-entry-price","title":"Adjust Entry Price","text":"<p>The <code>adjust_entry_price()</code> callback may be used by strategy developer to refresh/replace limit orders upon arrival of new candles. Be aware that <code>custom_entry_price()</code> is still the one dictating initial entry limit order price target at the time of entry trigger.</p> <p>Orders can be cancelled out of this callback by returning <code>None</code>.</p> <p>Returning <code>current_order_rate</code> will keep the order on the exchange \"as is\". Returning any other price will cancel the existing order, and replace it with a new order.</p> <p>The trade open-date (<code>trade.open_date_utc</code>) will remain at the time of the very first order placed. Please make sure to be aware of this - and eventually adjust your logic in other callbacks to account for this, and use the date of the first filled order instead.</p> <p>If the cancellation of the original order fails, then the order will not be replaced - though the order will most likely have been canceled on exchange. Having this happen on initial entries will result in the deletion of the order, while on position adjustment orders, it'll result in the trade size remaining as is.</p> <p>Regular timeout</p> <p>Entry <code>unfilledtimeout</code> mechanism (as well as <code>check_entry_timeout()</code>) takes precedence over this. Entry Orders that are cancelled via the above methods will not have this callback called. Be sure to update timeout values to match your expectations.</p> <pre><code>from freqtrade.persistence import Trade\nfrom datetime import timedelta, datetime\n\nclass AwesomeStrategy(IStrategy):\n\n    # ... populate_* methods\n\n    def adjust_entry_price(self, trade: Trade, order: Optional[Order], pair: str,\n                           current_time: datetime, proposed_rate: float, current_order_rate: float,\n                           entry_tag: Optional[str], side: str, **kwargs) -&gt; float:\n        \"\"\"\n        Entry price re-adjustment logic, returning the user desired limit price.\n        This only executes when a order was already placed, still open (unfilled fully or partially)\n        and not timed out on subsequent candles after entry trigger.\n\n        When not implemented by a strategy, returns current_order_rate as default.\n        If current_order_rate is returned then the existing order is maintained.\n        If None is returned then order gets canceled but not replaced by a new one.\n\n        :param pair: Pair that's currently analyzed\n        :param trade: Trade object.\n        :param order: Order object\n        :param current_time: datetime object, containing the current datetime\n        :param proposed_rate: Rate, calculated based on pricing settings in entry_pricing.\n        :param current_order_rate: Rate of the existing order in place.\n        :param entry_tag: Optional entry_tag (buy_tag) if provided with the buy signal.\n        :param side: 'long' or 'short' - indicating the direction of the proposed trade\n        :param **kwargs: Ensure to keep this here so updates to this won't break your strategy.\n        :return float: New entry price value if provided\n\n        \"\"\"\n        # Limit orders to use and follow SMA200 as price target for the first 10 minutes since entry trigger for BTC/USDT pair.\n        if pair == 'BTC/USDT' and entry_tag == 'long_sma200' and side == 'long' and (current_time - timedelta(minutes=10)) &gt; trade.open_date_utc:\n            # just cancel the order if it has been filled more than half of the amount\n            if order.filled &gt; order.remaining:\n                return None\n            else:\n                dataframe, _ = self.dp.get_analyzed_dataframe(pair=pair, timeframe=self.timeframe)\n                current_candle = dataframe.iloc[-1].squeeze()\n                # desired price\n                return current_candle['sma_200']\n        # default: maintain existing order\n        return current_order_rate\n</code></pre>"},{"location":"strategy-callbacks/#leverage-callback","title":"Leverage Callback","text":"<p>When trading in markets that allow leverage, this method must return the desired Leverage (Defaults to 1 -&gt; No leverage).</p> <p>Assuming a capital of 500USDT, a trade with leverage=3 would result in a position with 500 x 3 = 1500 USDT.</p> <p>Values that are above <code>max_leverage</code> will be adjusted to <code>max_leverage</code>. For markets / exchanges that don't support leverage, this method is ignored.</p> <pre><code>class AwesomeStrategy(IStrategy):\n    def leverage(self, pair: str, current_time: datetime, current_rate: float,\n                 proposed_leverage: float, max_leverage: float, entry_tag: Optional[str], side: str,\n                 **kwargs) -&gt; float:\n        \"\"\"\n        Customize leverage for each new trade. This method is only called in futures mode.\n\n        :param pair: Pair that's currently analyzed\n        :param current_time: datetime object, containing the current datetime\n        :param current_rate: Rate, calculated based on pricing settings in exit_pricing.\n        :param proposed_leverage: A leverage proposed by the bot.\n        :param max_leverage: Max leverage allowed on this pair\n        :param entry_tag: Optional entry_tag (buy_tag) if provided with the buy signal.\n        :param side: 'long' or 'short' - indicating the direction of the proposed trade\n        :return: A leverage amount, which is between 1.0 and max_leverage.\n        \"\"\"\n        return 1.0\n</code></pre> <p>All profit calculations include leverage. Stoploss / ROI also include leverage in their calculation. Defining a stoploss of 10% at 10x leverage would trigger the stoploss with a 1% move to the downside.</p>"},{"location":"strategy-callbacks/#order-filled-callback","title":"Order filled Callback","text":"<p>The <code>order_filled()</code> callback may be used to perform specific actions based on the current trade state after an order is filled. It will be called independent of the order type (entry, exit, stoploss or position adjustment).</p> <p>Assuming that your strategy needs to store the high value of the candle at trade entry, this is possible with this callback as the following example show.</p> <pre><code>class AwesomeStrategy(IStrategy):\n    def order_filled(self, pair: str, trade: Trade, order: Order, current_time: datetime, **kwargs) -&gt; None:\n        \"\"\"\n        Called right after an order fills. \n        Will be called for all order types (entry, exit, stoploss, position adjustment).\n        :param pair: Pair for trade\n        :param trade: trade object.\n        :param order: Order object.\n        :param current_time: datetime object, containing the current datetime\n        :param **kwargs: Ensure to keep this here so updates to this won't break your strategy.\n        \"\"\"\n        # Obtain pair dataframe (just to show how to access it)\n        dataframe, _ = self.dp.get_analyzed_dataframe(trade.pair, self.timeframe)\n        last_candle = dataframe.iloc[-1].squeeze()\n\n        if (trade.nr_of_successful_entries == 1) and (order.ft_order_side == trade.entry_side):\n            trade.set_custom_data(key='entry_candle_high', value=last_candle['high'])\n\n        return None\n</code></pre>"},{"location":"strategy-customization/","title":"Strategy Customization","text":"<p>This page explains how to customize your strategies, add new indicators and set up trading rules.</p> <p>Please familiarize yourself with Freqtrade basics first, which provides overall info on how the bot operates.</p>"},{"location":"strategy-customization/#develop-your-own-strategy","title":"Develop your own strategy","text":"<p>The bot includes a default strategy file. Also, several other strategies are available in the strategy repository.</p> <p>You will however most likely have your own idea for a strategy. This document intends to help you convert your strategy idea into your own strategy.</p> <p>To get started, use <code>freqtrade new-strategy --strategy AwesomeStrategy</code> (you can obviously use your own naming for your strategy). This will create a new strategy file from a template, which will be located under <code>user_data/strategies/AwesomeStrategy.py</code>.</p> <p>Note</p> <p>This is just a template file, which will most likely not be profitable out of the box.</p> Different template levels <p><code>freqtrade new-strategy</code> has an additional parameter, <code>--template</code>, which controls the amount of pre-build information you get in the created strategy. Use <code>--template minimal</code> to get an empty strategy without any indicator examples, or <code>--template advanced</code> to get a template with most callbacks defined.</p>"},{"location":"strategy-customization/#anatomy-of-a-strategy","title":"Anatomy of a strategy","text":"<p>A strategy file contains all the information needed to build a good strategy:</p> <ul> <li>Indicators</li> <li>Entry strategy rules</li> <li>Exit strategy rules</li> <li>Minimal ROI recommended</li> <li>Stoploss strongly recommended</li> </ul> <p>The bot also include a sample strategy called <code>SampleStrategy</code> you can update: <code>user_data/strategies/sample_strategy.py</code>. You can test it with the parameter: <code>--strategy SampleStrategy</code></p> <p>Additionally, there is an attribute called <code>INTERFACE_VERSION</code>, which defines the version of the strategy interface the bot should use. The current version is 3 - which is also the default when it's not set explicitly in the strategy.</p> <p>Future versions will require this to be set.</p> <pre><code>freqtrade trade --strategy AwesomeStrategy\n</code></pre> <p>For the following section we will use the user_data/strategies/sample_strategy.py file as reference.</p> <p>Strategies and Backtesting</p> <p>To avoid problems and unexpected differences between Backtesting and dry/live modes, please be aware that during backtesting the full time range is passed to the <code>populate_*()</code> methods at once. It is therefore best to use vectorized operations (across the whole dataframe, not loops) and avoid index referencing (<code>df.iloc[-1]</code>), but instead use <code>df.shift()</code> to get to the previous candle.</p> <p>Warning: Using future data</p> <p>Since backtesting passes the full time range to the <code>populate_*()</code> methods, the strategy author needs to take care to avoid having the strategy utilize data from the future. Some common patterns for this are listed in the Common Mistakes section of this document.</p>"},{"location":"strategy-customization/#dataframe","title":"Dataframe","text":"<p>Freqtrade uses pandas to store/provide the candlestick (OHLCV) data. Pandas is a great library developed for processing large amounts of data.</p> <p>Each row in a dataframe corresponds to one candle on a chart, with the latest candle always being the last in the dataframe (sorted by date).</p> <pre><code>&gt; dataframe.head()\n                       date      open      high       low     close     volume\n0 2021-11-09 23:25:00+00:00  67279.67  67321.84  67255.01  67300.97   44.62253\n1 2021-11-09 23:30:00+00:00  67300.97  67301.34  67183.03  67187.01   61.38076\n2 2021-11-09 23:35:00+00:00  67187.02  67187.02  67031.93  67123.81  113.42728\n3 2021-11-09 23:40:00+00:00  67123.80  67222.40  67080.33  67160.48   78.96008\n4 2021-11-09 23:45:00+00:00  67160.48  67160.48  66901.26  66943.37  111.39292\n</code></pre> <p>Pandas provides fast ways to calculate metrics. To benefit from this speed, it's advised to not use loops, but use vectorized methods instead.</p> <p>Vectorized operations perform calculations across the whole range of data and are therefore, compared to looping through each row, a lot faster when calculating indicators.</p> <p>As a dataframe is a table, simple python comparisons like the following will not work</p> <pre><code>    if dataframe['rsi'] &gt; 30:\n        dataframe['enter_long'] = 1\n</code></pre> <p>The above section will fail with <code>The truth value of a Series is ambiguous. [...]</code>.</p> <p>This must instead be written in a pandas-compatible way, so the operation is performed across the whole dataframe.</p> <pre><code>    dataframe.loc[\n        (dataframe['rsi'] &gt; 30)\n    , 'enter_long'] = 1\n</code></pre> <p>With this section, you have a new column in your dataframe, which has <code>1</code> assigned whenever RSI is above 30.</p>"},{"location":"strategy-customization/#customize-indicators","title":"Customize Indicators","text":"<p>Buy and sell signals need indicators. You can add more indicators by extending the list contained in the method <code>populate_indicators()</code> from your strategy file.</p> <p>You should only add the indicators used in either <code>populate_entry_trend()</code>, <code>populate_exit_trend()</code>, or to populate another indicator, otherwise performance may suffer.</p> <p>It's important to always return the dataframe without removing/modifying the columns <code>\"open\", \"high\", \"low\", \"close\", \"volume\"</code>, otherwise these fields would contain something unexpected.</p> <p>Sample:</p> <pre><code>def populate_indicators(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n    \"\"\"\n    Adds several different TA indicators to the given DataFrame\n\n    Performance Note: For the best performance be frugal on the number of indicators\n    you are using. Let uncomment only the indicator you are using in your strategies\n    or your hyperopt configuration, otherwise you will waste your memory and CPU usage.\n    :param dataframe: Dataframe with data from the exchange\n    :param metadata: Additional information, like the currently traded pair\n    :return: a Dataframe with all mandatory indicators for the strategies\n    \"\"\"\n    dataframe['sar'] = ta.SAR(dataframe)\n    dataframe['adx'] = ta.ADX(dataframe)\n    stoch = ta.STOCHF(dataframe)\n    dataframe['fastd'] = stoch['fastd']\n    dataframe['fastk'] = stoch['fastk']\n    dataframe['blower'] = ta.BBANDS(dataframe, nbdevup=2, nbdevdn=2)['lowerband']\n    dataframe['sma'] = ta.SMA(dataframe, timeperiod=40)\n    dataframe['tema'] = ta.TEMA(dataframe, timeperiod=9)\n    dataframe['mfi'] = ta.MFI(dataframe)\n    dataframe['rsi'] = ta.RSI(dataframe)\n    dataframe['ema5'] = ta.EMA(dataframe, timeperiod=5)\n    dataframe['ema10'] = ta.EMA(dataframe, timeperiod=10)\n    dataframe['ema50'] = ta.EMA(dataframe, timeperiod=50)\n    dataframe['ema100'] = ta.EMA(dataframe, timeperiod=100)\n    dataframe['ao'] = awesome_oscillator(dataframe)\n    macd = ta.MACD(dataframe)\n    dataframe['macd'] = macd['macd']\n    dataframe['macdsignal'] = macd['macdsignal']\n    dataframe['macdhist'] = macd['macdhist']\n    hilbert = ta.HT_SINE(dataframe)\n    dataframe['htsine'] = hilbert['sine']\n    dataframe['htleadsine'] = hilbert['leadsine']\n    dataframe['plus_dm'] = ta.PLUS_DM(dataframe)\n    dataframe['plus_di'] = ta.PLUS_DI(dataframe)\n    dataframe['minus_dm'] = ta.MINUS_DM(dataframe)\n    dataframe['minus_di'] = ta.MINUS_DI(dataframe)\n    return dataframe\n</code></pre> <p>Want more indicator examples?</p> <p>Look into the user_data/strategies/sample_strategy.py. Then uncomment indicators you need.</p>"},{"location":"strategy-customization/#indicator-libraries","title":"Indicator libraries","text":"<p>Out of the box, freqtrade installs the following technical libraries:</p> <ul> <li>ta-lib</li> <li>pandas-ta</li> <li>technical</li> </ul> <p>Additional technical libraries can be installed as necessary, or custom indicators may be written / invented by the strategy author.</p>"},{"location":"strategy-customization/#strategy-startup-period","title":"Strategy startup period","text":"<p>Most indicators have an instable startup period, in which they are either not available (NaN), or the calculation is incorrect. This can lead to inconsistencies, since Freqtrade does not know how long this instable period should be. To account for this, the strategy can be assigned the <code>startup_candle_count</code> attribute. This should be set to the maximum number of candles that the strategy requires to calculate stable indicators. In the case where a user includes higher timeframes with informative pairs, the <code>startup_candle_count</code> does not necessarily change. The value is the maximum period (in candles) that any of the informatives timeframes need to compute stable indicators.</p> <p>You can use recursive-analysis to check and find the correct <code>startup_candle_count</code> to be used.</p> <p>In this example strategy, this should be set to 400 (<code>startup_candle_count = 400</code>), since the minimum needed history for ema100 calculation to make sure the value is correct is 400 candles.</p> <pre><code>    dataframe['ema100'] = ta.EMA(dataframe, timeperiod=100)\n</code></pre> <p>By letting the bot know how much history is needed, backtest trades can start at the specified timerange during backtesting and hyperopt.</p> <p>Using x calls to get OHLCV</p> <p>If you receive a warning like <code>WARNING - Using 3 calls to get OHLCV. This can result in slower operations for the bot. Please check if you really need 1500 candles for your strategy</code> - you should consider if you really need this much historic data for your signals. Having this will cause Freqtrade to make multiple calls for the same pair, which will obviously be slower than one network request. As a consequence, Freqtrade will take longer to refresh candles - and should therefore be avoided if possible. This is capped to 5 total calls to avoid overloading the exchange, or make freqtrade too slow.</p> <p>Warning</p> <p><code>startup_candle_count</code> should be below <code>ohlcv_candle_limit * 5</code> (which is 500 * 5 for most exchanges) - since only this amount of candles will be available during Dry-Run/Live Trade operations.</p>"},{"location":"strategy-customization/#example","title":"Example","text":"<p>Let's try to backtest 1 month (January 2019) of 5m candles using an example strategy with EMA100, as above.</p> <pre><code>freqtrade backtesting --timerange 20190101-20190201 --timeframe 5m\n</code></pre> <p>Assuming <code>startup_candle_count</code> is set to 400, backtesting knows it needs 400 candles to generate valid buy signals. It will load data from <code>20190101 - (400 * 5m)</code> - which is ~2018-12-30 11:40:00. If this data is available, indicators will be calculated with this extended timerange. The instable startup period (up to 2019-01-01 00:00:00) will then be removed before starting backtesting.</p> <p>Note</p> <p>If data for the startup period is not available, then the timerange will be adjusted to account for this startup period - so Backtesting would start at 2019-01-02 09:20:00.</p>"},{"location":"strategy-customization/#entry-signal-rules","title":"Entry signal rules","text":"<p>Edit the method <code>populate_entry_trend()</code> in your strategy file to update your entry strategy.</p> <p>It's important to always return the dataframe without removing/modifying the columns <code>\"open\", \"high\", \"low\", \"close\", \"volume\"</code>, otherwise these fields would contain something unexpected.</p> <p>This method will also define a new column, <code>\"enter_long\"</code> (<code>\"enter_short\"</code> for shorts), which needs to contain 1 for entries, and 0 for \"no action\". <code>enter_long</code> is a mandatory column that must be set even if the strategy is shorting only.</p> <p>Sample from <code>user_data/strategies/sample_strategy.py</code>:</p> <pre><code>def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n    \"\"\"\n    Based on TA indicators, populates the buy signal for the given dataframe\n    :param dataframe: DataFrame populated with indicators\n    :param metadata: Additional information, like the currently traded pair\n    :return: DataFrame with buy column\n    \"\"\"\n    dataframe.loc[\n        (\n            (qtpylib.crossed_above(dataframe['rsi'], 30)) &amp;  # Signal: RSI crosses above 30\n            (dataframe['tema'] &lt;= dataframe['bb_middleband']) &amp;  # Guard\n            (dataframe['tema'] &gt; dataframe['tema'].shift(1)) &amp;  # Guard\n            (dataframe['volume'] &gt; 0)  # Make sure Volume is not 0\n        ),\n        ['enter_long', 'enter_tag']] = (1, 'rsi_cross')\n\n    return dataframe\n</code></pre> Enter short trades <p>Short-entries can be created by setting <code>enter_short</code> (corresponds to <code>enter_long</code> for long trades). The <code>enter_tag</code> column remains identical. Short-trades need to be supported by your exchange and market configuration! Please make sure to set <code>can_short</code> appropriately on your strategy if you intend to short.</p> <pre><code>def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n    dataframe.loc[\n        (\n            (qtpylib.crossed_above(dataframe['rsi'], 30)) &amp;  # Signal: RSI crosses above 30\n            (dataframe['tema'] &lt;= dataframe['bb_middleband']) &amp;  # Guard\n            (dataframe['tema'] &gt; dataframe['tema'].shift(1)) &amp;  # Guard\n            (dataframe['volume'] &gt; 0)  # Make sure Volume is not 0\n        ),\n        ['enter_long', 'enter_tag']] = (1, 'rsi_cross')\n\n    dataframe.loc[\n        (\n            (qtpylib.crossed_below(dataframe['rsi'], 70)) &amp;  # Signal: RSI crosses below 70\n            (dataframe['tema'] &gt; dataframe['bb_middleband']) &amp;  # Guard\n            (dataframe['tema'] &lt; dataframe['tema'].shift(1)) &amp;  # Guard\n            (dataframe['volume'] &gt; 0)  # Make sure Volume is not 0\n        ),\n        ['enter_short', 'enter_tag']] = (1, 'rsi_cross')\n\n    return dataframe\n</code></pre> <p>Note</p> <p>Buying requires sellers to buy from - therefore volume needs to be &gt; 0 (<code>dataframe['volume'] &gt; 0</code>) to make sure that the bot does not buy/sell in no-activity periods.</p>"},{"location":"strategy-customization/#exit-signal-rules","title":"Exit signal rules","text":"<p>Edit the method <code>populate_exit_trend()</code> into your strategy file to update your exit strategy. The exit-signal can be suppressed by setting <code>use_exit_signal</code> to false in the configuration or strategy. <code>use_exit_signal</code> will not influence signal collision rules - which will still apply and can prevent entries.</p> <p>It's important to always return the dataframe without removing/modifying the columns <code>\"open\", \"high\", \"low\", \"close\", \"volume\"</code>, otherwise these fields would contain something unexpected.</p> <p>This method will also define a new column, <code>\"exit_long\"</code> (<code>\"exit_short\"</code> for shorts), which needs to contain 1 for exits, and 0 for \"no action\".</p> <p>Sample from <code>user_data/strategies/sample_strategy.py</code>:</p> <pre><code>def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n    \"\"\"\n    Based on TA indicators, populates the exit signal for the given dataframe\n    :param dataframe: DataFrame populated with indicators\n    :param metadata: Additional information, like the currently traded pair\n    :return: DataFrame with buy column\n    \"\"\"\n    dataframe.loc[\n        (\n            (qtpylib.crossed_above(dataframe['rsi'], 70)) &amp;  # Signal: RSI crosses above 70\n            (dataframe['tema'] &gt; dataframe['bb_middleband']) &amp;  # Guard\n            (dataframe['tema'] &lt; dataframe['tema'].shift(1)) &amp;  # Guard\n            (dataframe['volume'] &gt; 0)  # Make sure Volume is not 0\n        ),\n        ['exit_long', 'exit_tag']] = (1, 'rsi_too_high')\n    return dataframe\n</code></pre> Exit short trades <p>Short-exits can be created by setting <code>exit_short</code> (corresponds to <code>exit_long</code>). The <code>exit_tag</code> column remains identical. Short-trades need to be supported by your exchange and market configuration!</p> <pre><code>def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n    dataframe.loc[\n        (\n            (qtpylib.crossed_above(dataframe['rsi'], 70)) &amp;  # Signal: RSI crosses above 70\n            (dataframe['tema'] &gt; dataframe['bb_middleband']) &amp;  # Guard\n            (dataframe['tema'] &lt; dataframe['tema'].shift(1)) &amp;  # Guard\n            (dataframe['volume'] &gt; 0)  # Make sure Volume is not 0\n        ),\n        ['exit_long', 'exit_tag']] = (1, 'rsi_too_high')\n    dataframe.loc[\n        (\n            (qtpylib.crossed_below(dataframe['rsi'], 30)) &amp;  # Signal: RSI crosses below 30\n            (dataframe['tema'] &lt; dataframe['bb_middleband']) &amp;  # Guard\n            (dataframe['tema'] &gt; dataframe['tema'].shift(1)) &amp;  # Guard\n            (dataframe['volume'] &gt; 0)  # Make sure Volume is not 0\n        ),\n        ['exit_short', 'exit_tag']] = (1, 'rsi_too_low')\n    return dataframe\n</code></pre>"},{"location":"strategy-customization/#minimal-roi","title":"Minimal ROI","text":"<p>This dict defines the minimal Return On Investment (ROI) a trade should reach before exiting, independent from the exit signal.</p> <p>It is of the following format, with the dict key (left side of the colon) being the minutes passed since the trade opened, and the value (right side of the colon) being the percentage.</p> <pre><code>minimal_roi = {\n    \"40\": 0.0,\n    \"30\": 0.01,\n    \"20\": 0.02,\n    \"0\": 0.04\n}\n</code></pre> <p>The above configuration would therefore mean:</p> <ul> <li>Exit whenever 4% profit was reached</li> <li>Exit when 2% profit was reached (in effect after 20 minutes)</li> <li>Exit when 1% profit was reached (in effect after 30 minutes)</li> <li>Exit when trade is non-loosing (in effect after 40 minutes)</li> </ul> <p>The calculation does include fees.</p> <p>To disable ROI completely, set it to an empty dictionary:</p> <pre><code>minimal_roi = {}\n</code></pre> <p>To use times based on candle duration (timeframe), the following snippet can be handy. This will allow you to change the timeframe for the strategy, and ROI times will still be set as candles (e.g. after 3 candles ...)</p> <pre><code>from freqtrade.exchange import timeframe_to_minutes\n\nclass AwesomeStrategy(IStrategy):\n\n    timeframe = \"1d\"\n    timeframe_mins = timeframe_to_minutes(timeframe)\n    minimal_roi = {\n        \"0\": 0.05,                      # 5% for the first 3 candles\n        str(timeframe_mins * 3): 0.02,  # 2% after 3 candles\n        str(timeframe_mins * 6): 0.01,  # 1% After 6 candles\n    }\n</code></pre> Orders that don't fill immediately <p><code>minimal_roi</code> will take the <code>trade.open_date</code> as reference, which is the time the trade was initialized / the first order for this trade was placed. This will also hold true for limit orders that don't fill immediately  (usually in combination with \"off-spot\" prices through <code>custom_entry_price()</code>), as well as for cases where the initial order is replaced through <code>adjust_entry_price()</code>. The time used will still be from the initial <code>trade.open_date</code> (when the initial order was first placed), not from the newly placed order date.</p>"},{"location":"strategy-customization/#stoploss","title":"Stoploss","text":"<p>Setting a stoploss is highly recommended to protect your capital from strong moves against you.</p> <p>Sample of setting a 10% stoploss:</p> <pre><code>stoploss = -0.10\n</code></pre> <p>For the full documentation on stoploss features, look at the dedicated stoploss page.</p>"},{"location":"strategy-customization/#timeframe","title":"Timeframe","text":"<p>This is the set of candles the bot should download and use for the analysis. Common values are <code>\"1m\"</code>, <code>\"5m\"</code>, <code>\"15m\"</code>, <code>\"1h\"</code>, however all values supported by your exchange should work.</p> <p>Please note that the same entry/exit signals may work well with one timeframe, but not with the others.</p> <p>This setting is accessible within the strategy methods as the <code>self.timeframe</code> attribute.</p>"},{"location":"strategy-customization/#can-short","title":"Can short","text":"<p>To use short signals in futures markets, you will have to let us know to do so by setting <code>can_short=True</code>. Strategies which enable this will fail to load on spot markets. Disabling of this will have short signals ignored (also in futures markets).</p>"},{"location":"strategy-customization/#metadata-dict","title":"Metadata dict","text":"<p>The metadata-dict (available for <code>populate_entry_trend</code>, <code>populate_exit_trend</code>, <code>populate_indicators</code>) contains additional information. Currently this is <code>pair</code>, which can be accessed using <code>metadata['pair']</code> - and will return a pair in the format <code>XRP/BTC</code>.</p> <p>The Metadata-dict should not be modified and does not persist information across multiple calls. Instead, have a look at the Storing information section.</p>"},{"location":"strategy-customization/#strategy-file-loading","title":"Strategy file loading","text":"<p>By default, freqtrade will attempt to load strategies from all <code>.py</code> files within <code>user_data/strategies</code>.</p> <p>Assuming your strategy is called <code>AwesomeStrategy</code>, stored in the file <code>user_data/strategies/AwesomeStrategy.py</code>, then you can start freqtrade with <code>freqtrade trade --strategy AwesomeStrategy</code>. Note that we're using the class-name, not the file name.</p> <p>You can use <code>freqtrade list-strategies</code> to see a list of all strategies Freqtrade is able to load (all strategies in the correct folder). It will also include a \"status\" field, highlighting potential problems.</p> Customize strategy directory <p>You can use a different directory by using <code>--strategy-path user_data/otherPath</code>. This parameter is available to all commands that require a strategy.</p>"},{"location":"strategy-customization/#informative-pairs","title":"Informative Pairs","text":""},{"location":"strategy-customization/#get-data-for-non-tradeable-pairs","title":"Get data for non-tradeable pairs","text":"<p>Data for additional, informative pairs (reference pairs) can be beneficial for some strategies. OHLCV data for these pairs will be downloaded as part of the regular whitelist refresh process and is available via <code>DataProvider</code> just as other pairs (see below). These parts will not be traded unless they are also specified in the pair whitelist, or have been selected by Dynamic Whitelisting.</p> <p>The pairs need to be specified as tuples in the format <code>(\"pair\", \"timeframe\")</code>, with pair as the first and timeframe as the second argument.</p> <p>Sample:</p> <pre><code>def informative_pairs(self):\n    return [(\"ETH/USDT\", \"5m\"),\n            (\"BTC/TUSD\", \"15m\"),\n            ]\n</code></pre> <p>A full sample can be found in the DataProvider section.</p> <p>Warning</p> <p>As these pairs will be refreshed as part of the regular whitelist refresh, it's best to keep this list short. All timeframes and all pairs can be specified as long as they are available (and active) on the used exchange. It is however better to use resampling to longer timeframes whenever possible to avoid hammering the exchange with too many requests and risk being blocked.</p> Alternative candle types <p>Informative_pairs can also provide a 3<sup>rd</sup> tuple element defining the candle type explicitly. Availability of alternative candle-types will depend on the trading-mode and the exchange.  In general, spot pairs cannot be used in futures markets, and futures candles can't be used as informative pairs for spot bots. Details about this may vary, if they do, this can be found in the exchange documentation.</p> <pre><code>def informative_pairs(self):\n    return [\n        (\"ETH/USDT\", \"5m\", \"\"),   # Uses default candletype, depends on trading_mode (recommended)\n        (\"ETH/USDT\", \"5m\", \"spot\"),   # Forces usage of spot candles (only valid for bots running on spot markets).\n        (\"BTC/TUSD\", \"15m\", \"futures\"),  # Uses futures candles (only bots with `trading_mode=futures`)\n        (\"BTC/TUSD\", \"15m\", \"mark\"),  # Uses mark candles (only bots with `trading_mode=futures`)\n    ]\n</code></pre>"},{"location":"strategy-customization/#informative-pairs-decorator-informative","title":"Informative pairs decorator (<code>@informative()</code>)","text":"<p>In most common case it is possible to easily define informative pairs by using a decorator. All decorated <code>populate_indicators_*</code> methods run in isolation, not having access to data from other informative pairs, in the end all informative dataframes are merged and passed to main <code>populate_indicators()</code> method. When hyperopting, use of hyperoptable parameter <code>.value</code> attribute is not supported. Please use <code>.range</code> attribute. See optimizing an indicator parameter for more information.</p> Full documentation <pre><code>def informative(timeframe: str, asset: str = '',\n                fmt: Optional[Union[str, Callable[[KwArg(str)], str]]] = None,\n                *,\n                candle_type: Optional[CandleType] = None,\n                ffill: bool = True) -&gt; Callable[[PopulateIndicators], PopulateIndicators]:\n    \"\"\"\n    A decorator for populate_indicators_Nn(self, dataframe, metadata), allowing these functions to\n    define informative indicators.\n\n    Example usage:\n\n        @informative('1h')\n        def populate_indicators_1h(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n            dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14)\n            return dataframe\n\n    :param timeframe: Informative timeframe. Must always be equal or higher than strategy timeframe.\n    :param asset: Informative asset, for example BTC, BTC/USDT, ETH/BTC. Do not specify to use\n                current pair. Also supports limited pair format strings (see below)\n    :param fmt: Column format (str) or column formatter (callable(name, asset, timeframe)). When not\n    specified, defaults to:\n    * {base}_{quote}_{column}_{timeframe} if asset is specified.\n    * {column}_{timeframe} if asset is not specified.\n    Pair format supports these format variables:\n    * {base} - base currency in lower case, for example 'eth'.\n    * {BASE} - same as {base}, except in upper case.\n    * {quote} - quote currency in lower case, for example 'usdt'.\n    * {QUOTE} - same as {quote}, except in upper case.\n    Format string additionally supports this variables.\n    * {asset} - full name of the asset, for example 'BTC/USDT'.\n    * {column} - name of dataframe column.\n    * {timeframe} - timeframe of informative dataframe.\n    :param ffill: ffill dataframe after merging informative pair.\n    :param candle_type: '', mark, index, premiumIndex, or funding_rate\n    \"\"\"\n</code></pre> Fast and easy way to define informative pairs <p>Most of the time we do not need power and flexibility offered by <code>merge_informative_pair()</code>, therefore we can use a decorator to quickly define informative pairs.</p> <pre><code>from datetime import datetime\nfrom freqtrade.persistence import Trade\nfrom freqtrade.strategy import IStrategy, informative\n\nclass AwesomeStrategy(IStrategy):\n\n    # This method is not required. \n    # def informative_pairs(self): ...\n\n    # Define informative upper timeframe for each pair. Decorators can be stacked on same \n    # method. Available in populate_indicators as 'rsi_30m' and 'rsi_1h'.\n    @informative('30m')\n    @informative('1h')\n    def populate_indicators_1h(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14)\n        return dataframe\n\n    # Define BTC/STAKE informative pair. Available in populate_indicators and other methods as\n    # 'btc_rsi_1h'. Current stake currency should be specified as {stake} format variable \n    # instead of hard-coding actual stake currency. Available in populate_indicators and other \n    # methods as 'btc_usdt_rsi_1h' (when stake currency is USDT).\n    @informative('1h', 'BTC/{stake}')\n    def populate_indicators_btc_1h(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14)\n        return dataframe\n\n    # Define BTC/ETH informative pair. You must specify quote currency if it is different from\n    # stake currency. Available in populate_indicators and other methods as 'eth_btc_rsi_1h'.\n    @informative('1h', 'ETH/BTC')\n    def populate_indicators_eth_btc_1h(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14)\n        return dataframe\n\n    # Define BTC/STAKE informative pair. A custom formatter may be specified for formatting\n    # column names. A callable `fmt(**kwargs) -&gt; str` may be specified, to implement custom\n    # formatting. Available in populate_indicators and other methods as 'rsi_upper_1h'.\n    @informative('1h', 'BTC/{stake}', '{column}_{timeframe}')\n    def populate_indicators_btc_1h_2(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        dataframe['rsi_upper'] = ta.RSI(dataframe, timeperiod=14)\n        return dataframe\n\n    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        # Strategy timeframe indicators for current pair.\n        dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14)\n        # Informative pairs are available in this method.\n        dataframe['rsi_less'] = dataframe['rsi'] &lt; dataframe['rsi_1h']\n        return dataframe\n</code></pre> <p>Note</p> <p>Do not use <code>@informative</code> decorator if you need to use data of one informative pair when generating another informative pair. Instead, define informative pairs manually as described in the DataProvider section.</p> <p>Note</p> <p>Use string formatting when accessing informative dataframes of other pairs. This will allow easily changing stake currency in config without having to adjust strategy code.</p> <pre><code>def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n    stake = self.config['stake_currency']\n    dataframe.loc[\n        (\n            (dataframe[f'btc_{stake}_rsi_1h'] &lt; 35)\n            &amp;\n            (dataframe['volume'] &gt; 0)\n        ),\n        ['enter_long', 'enter_tag']] = (1, 'buy_signal_rsi')\n\n    return dataframe\n</code></pre> <p>Alternatively column renaming may be used to remove stake currency from column names: <code>@informative('1h', 'BTC/{stake}', fmt='{base}_{column}_{timeframe}')</code>.</p> <p>Duplicate method names</p> <p>Methods tagged with <code>@informative()</code> decorator must always have unique names! Re-using same name (for example when copy-pasting already defined informative method) will overwrite previously defined method and not produce any errors due to limitations of Python programming language. In such cases you will find that indicators created in earlier-defined methods are not available in the dataframe. Carefully review method names and make sure they are unique!</p>"},{"location":"strategy-customization/#merge_informative_pair","title":"merge_informative_pair()","text":"<p>This method helps you merge an informative pair to a regular dataframe without lookahead bias. It's there to help you merge the dataframe in a safe and consistent way.</p> <p>Options:</p> <ul> <li>Rename the columns for you to create unique columns</li> <li>Merge the dataframe without lookahead bias</li> <li>Forward-fill (optional)</li> </ul> <p>For a full sample, please refer to the complete data provider example below.</p> <p>All columns of the informative dataframe will be available on the returning dataframe in a renamed fashion:</p> <p>Column renaming</p> <p>Assuming <code>inf_tf = '1d'</code> the resulting columns will be:</p> <pre><code>'date', 'open', 'high', 'low', 'close', 'rsi'                     # from the original dataframe\n'date_1d', 'open_1d', 'high_1d', 'low_1d', 'close_1d', 'rsi_1d'   # from the informative dataframe\n</code></pre> Column renaming - 1h <p>Assuming <code>inf_tf = '1h'</code> the resulting columns will be:</p> <pre><code>'date', 'open', 'high', 'low', 'close', 'rsi'                     # from the original dataframe\n'date_1h', 'open_1h', 'high_1h', 'low_1h', 'close_1h', 'rsi_1h'   # from the informative dataframe\n</code></pre> Custom implementation <p>A custom implementation for this is possible, and can be done as follows:</p> <pre><code># Shift date by 1 candle\n# This is necessary since the data is always the \"open date\"\n# and a 15m candle starting at 12:15 should not know the close of the 1h candle from 12:00 to 13:00\nminutes = timeframe_to_minutes(inf_tf)\n# Only do this if the timeframes are different:\ninformative['date_merge'] = informative[\"date\"] + pd.to_timedelta(minutes, 'm')\n\n# Rename columns to be unique\ninformative.columns = [f\"{col}_{inf_tf}\" for col in informative.columns]\n# Assuming inf_tf = '1d' - then the columns will now be:\n# date_1d, open_1d, high_1d, low_1d, close_1d, rsi_1d\n\n# Combine the 2 dataframes\n# all indicators on the informative sample MUST be calculated before this point\ndataframe = pd.merge(dataframe, informative, left_on='date', right_on=f'date_merge_{inf_tf}', how='left')\n# FFill to have the 1d value available in every row throughout the day.\n# Without this, comparisons would only work once per day.\ndataframe = dataframe.ffill()\n</code></pre> <p>Informative timeframe &lt; timeframe</p> <p>Using informative timeframes smaller than the dataframe timeframe is not recommended with this method, as it will not use any of the additional information this would provide. To use the more detailed information properly, more advanced methods should be applied (which are out of scope for freqtrade documentation, as it'll depend on the respective need).</p>"},{"location":"strategy-customization/#additional-data-dataprovider","title":"Additional data (DataProvider)","text":"<p>The strategy provides access to the <code>DataProvider</code>. This allows you to get additional data to use in your strategy.</p> <p>All methods return <code>None</code> in case of failure (do not raise an exception).</p> <p>Please always check the mode of operation to select the correct method to get data (samples see below).</p> <p>Hyperopt</p> <p>Dataprovider is available during hyperopt, however it can only be used in <code>populate_indicators()</code> within a strategy. It is not available in <code>populate_buy()</code> and <code>populate_sell()</code> methods, nor in <code>populate_indicators()</code>, if this method located in the hyperopt file.</p>"},{"location":"strategy-customization/#possible-options-for-dataprovider","title":"Possible options for DataProvider","text":"<ul> <li><code>available_pairs</code> - Property with tuples listing cached pairs with their timeframe (pair, timeframe).</li> <li><code>current_whitelist()</code> - Returns a current list of whitelisted pairs. Useful for accessing dynamic whitelists (i.e. VolumePairlist)</li> <li><code>get_pair_dataframe(pair, timeframe)</code> - This is a universal method, which returns either historical data (for backtesting) or cached live data (for the Dry-Run and Live-Run modes).</li> <li><code>get_analyzed_dataframe(pair, timeframe)</code> - Returns the analyzed dataframe (after calling <code>populate_indicators()</code>, <code>populate_buy()</code>, <code>populate_sell()</code>) and the time of the latest analysis.</li> <li><code>historic_ohlcv(pair, timeframe)</code> - Returns historical data stored on disk.</li> <li><code>market(pair)</code> - Returns market data for the pair: fees, limits, precisions, activity flag, etc. See ccxt documentation for more details on the Market data structure.</li> <li><code>ohlcv(pair, timeframe)</code> - Currently cached candle (OHLCV) data for the pair, returns DataFrame or empty DataFrame.</li> <li><code>orderbook(pair, maximum)</code> - Returns latest orderbook data for the pair, a dict with bids/asks with a total of <code>maximum</code> entries.</li> <li><code>ticker(pair)</code> - Returns current ticker data for the pair. See ccxt documentation for more details on the Ticker data structure.</li> <li><code>runmode</code> - Property containing the current runmode.</li> </ul>"},{"location":"strategy-customization/#example-usages","title":"Example Usages","text":""},{"location":"strategy-customization/#available_pairs","title":"available_pairs","text":"<pre><code>for pair, timeframe in self.dp.available_pairs:\n    print(f\"available {pair}, {timeframe}\")\n</code></pre>"},{"location":"strategy-customization/#current_whitelist","title":"current_whitelist()","text":"<p>Imagine you've developed a strategy that trades the <code>5m</code> timeframe using signals generated from a <code>1d</code> timeframe on the top 10 volume pairs by volume.</p> <p>The strategy might look something like this:</p> <p>Scan through the top 10 pairs by volume using the <code>VolumePairList</code> every 5 minutes and use a 14 day RSI to buy and sell.</p> <p>Due to the limited available data, it's very difficult to resample <code>5m</code> candles into daily candles for use in a 14 day RSI. Most exchanges limit us to just 500-1000 candles which effectively gives us around 1.74 daily candles. We need 14 days at least!</p> <p>Since we can't resample the data we will have to use an informative pair; and since the whitelist will be dynamic we don't know which pair(s) to use.</p> <p>This is where calling <code>self.dp.current_whitelist()</code> comes in handy.</p> <pre><code>    def informative_pairs(self):\n\n        # get access to all pairs available in whitelist.\n        pairs = self.dp.current_whitelist()\n        # Assign tf to each pair so they can be downloaded and cached for strategy.\n        informative_pairs = [(pair, '1d') for pair in pairs]\n        return informative_pairs\n</code></pre> Plotting with current_whitelist <p>Current whitelist is not supported for <code>plot-dataframe</code>, as this command is usually used by providing an explicit pairlist - and would therefore make the return values of this method misleading.</p>"},{"location":"strategy-customization/#get_pair_dataframepair-timeframe","title":"get_pair_dataframe(pair, timeframe)","text":"<pre><code># fetch live / historical candle (OHLCV) data for the first informative pair\ninf_pair, inf_timeframe = self.informative_pairs()[0]\ninformative = self.dp.get_pair_dataframe(pair=inf_pair,\n                                         timeframe=inf_timeframe)\n</code></pre> <p>Warning about backtesting</p> <p>In backtesting, <code>dp.get_pair_dataframe()</code> behavior differs depending on where it's called. Within <code>populate_*()</code> methods, <code>dp.get_pair_dataframe()</code> returns the full timerange. Please make sure to not \"look into the future\" to avoid surprises when running in dry/live mode. Within callbacks, you'll get the full timerange up to the current (simulated) candle.</p>"},{"location":"strategy-customization/#get_analyzed_dataframepair-timeframe","title":"get_analyzed_dataframe(pair, timeframe)","text":"<p>This method is used by freqtrade internally to determine the last signal. It can also be used in specific callbacks to get the signal that caused the action (see Advanced Strategy Documentation for more details on available callbacks).</p> <pre><code># fetch current dataframe\ndataframe, last_updated = self.dp.get_analyzed_dataframe(pair=metadata['pair'],\n                                                         timeframe=self.timeframe)\n</code></pre> <p>No data available</p> <p>Returns an empty dataframe if the requested pair was not cached. You can check for this with <code>if dataframe.empty:</code> and handle this case accordingly. This should not happen when using whitelisted pairs.</p>"},{"location":"strategy-customization/#orderbookpair-maximum","title":"orderbook(pair, maximum)","text":"<pre><code>if self.dp.runmode.value in ('live', 'dry_run'):\n    ob = self.dp.orderbook(metadata['pair'], 1)\n    dataframe['best_bid'] = ob['bids'][0][0]\n    dataframe['best_ask'] = ob['asks'][0][0]\n</code></pre> <p>The orderbook structure is aligned with the order structure from ccxt, so the result will look as follows:</p> <pre><code>{\n    'bids': [\n        [ price, amount ], // [ float, float ]\n        [ price, amount ],\n        ...\n    ],\n    'asks': [\n        [ price, amount ],\n        [ price, amount ],\n        //...\n    ],\n    //...\n}\n</code></pre> <p>Therefore, using <code>ob['bids'][0][0]</code> as demonstrated above will result in using the best bid price. <code>ob['bids'][0][1]</code> would look at the amount at this orderbook position.</p> <p>Warning about backtesting</p> <p>The order book is not part of the historic data which means backtesting and hyperopt will not work correctly if this method is used, as the method will return up-to-date values.</p>"},{"location":"strategy-customization/#tickerpair","title":"ticker(pair)","text":"<pre><code>if self.dp.runmode.value in ('live', 'dry_run'):\n    ticker = self.dp.ticker(metadata['pair'])\n    dataframe['last_price'] = ticker['last']\n    dataframe['volume24h'] = ticker['quoteVolume']\n    dataframe['vwap'] = ticker['vwap']\n</code></pre> <p>Warning</p> <p>Although the ticker data structure is a part of the ccxt Unified Interface, the values returned by this method can vary for different exchanges. For instance, many exchanges do not return <code>vwap</code> values, some exchanges does not always fills in the <code>last</code> field (so it can be None), etc. So you need to carefully verify the ticker data returned from the exchange and add appropriate error handling / defaults.</p> <p>Warning about backtesting</p> <p>This method will always return up-to-date values - so usage during backtesting / hyperopt without runmode checks will lead to wrong results.</p>"},{"location":"strategy-customization/#send-notification","title":"Send Notification","text":"<p>The dataprovider <code>.send_msg()</code> function allows you to send custom notifications from your strategy. Identical notifications will only be sent once per candle, unless the 2<sup>nd</sup> argument (<code>always_send</code>) is set to True.</p> <pre><code>    self.dp.send_msg(f\"{metadata['pair']} just got hot!\")\n\n    # Force send this notification, avoid caching (Please read warning below!)\n    self.dp.send_msg(f\"{metadata['pair']} just got hot!\", always_send=True)\n</code></pre> <p>Notifications will only be sent in trading modes (Live/Dry-run) - so this method can be called without conditions for backtesting.</p> <p>Spamming</p> <p>You can spam yourself pretty good by setting <code>always_send=True</code> in this method. Use this with great care and only in conditions you know will not happen throughout a candle to avoid a message every 5 seconds.</p>"},{"location":"strategy-customization/#complete-data-provider-sample","title":"Complete Data-provider sample","text":"<pre><code>from freqtrade.strategy import IStrategy, merge_informative_pair\nfrom pandas import DataFrame\n\nclass SampleStrategy(IStrategy):\n    # strategy init stuff...\n\n    timeframe = '5m'\n\n    # more strategy init stuff..\n\n    def informative_pairs(self):\n\n        # get access to all pairs available in whitelist.\n        pairs = self.dp.current_whitelist()\n        # Assign tf to each pair so they can be downloaded and cached for strategy.\n        informative_pairs = [(pair, '1d') for pair in pairs]\n        # Optionally Add additional \"static\" pairs\n        informative_pairs += [(\"ETH/USDT\", \"5m\"),\n                              (\"BTC/TUSD\", \"15m\"),\n                            ]\n        return informative_pairs\n\n    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n        if not self.dp:\n            # Don't do anything if DataProvider is not available.\n            return dataframe\n\n        inf_tf = '1d'\n        # Get the informative pair\n        informative = self.dp.get_pair_dataframe(pair=metadata['pair'], timeframe=inf_tf)\n        # Get the 14 day rsi\n        informative['rsi'] = ta.RSI(informative, timeperiod=14)\n\n        # Use the helper function merge_informative_pair to safely merge the pair\n        # Automatically renames the columns and merges a shorter timeframe dataframe and a longer timeframe informative pair\n        # use ffill to have the 1d value available in every row throughout the day.\n        # Without this, comparisons between columns of the original and the informative pair would only work once per day.\n        # Full documentation of this method, see below\n        dataframe = merge_informative_pair(dataframe, informative, self.timeframe, inf_tf, ffill=True)\n\n        # Calculate rsi of the original dataframe (5m timeframe)\n        dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14)\n\n        # Do other stuff\n        # ...\n\n        return dataframe\n\n    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n\n        dataframe.loc[\n            (\n                (qtpylib.crossed_above(dataframe['rsi'], 30)) &amp;  # Signal: RSI crosses above 30\n                (dataframe['rsi_1d'] &lt; 30) &amp;                     # Ensure daily RSI is &lt; 30\n                (dataframe['volume'] &gt; 0)                        # Ensure this candle had volume (important for backtesting)\n            ),\n            ['enter_long', 'enter_tag']] = (1, 'rsi_cross')\n</code></pre>"},{"location":"strategy-customization/#additional-data-wallets","title":"Additional data (Wallets)","text":"<p>The strategy provides access to the <code>wallets</code> object. This contains the current balances on the exchange.</p> <p>Backtesting / Hyperopt</p> <p>Wallets behaves differently depending on the function it's called. Within <code>populate_*()</code> methods, it'll return the full wallet as configured. Within callbacks, you'll get the wallet state corresponding to the actual simulated wallet at that point in the simulation process.</p> <p>Please always check if <code>wallets</code> is available to avoid failures during backtesting.</p> <pre><code>if self.wallets:\n    free_eth = self.wallets.get_free('ETH')\n    used_eth = self.wallets.get_used('ETH')\n    total_eth = self.wallets.get_total('ETH')\n</code></pre>"},{"location":"strategy-customization/#possible-options-for-wallets","title":"Possible options for Wallets","text":"<ul> <li><code>get_free(asset)</code> - currently available balance to trade</li> <li><code>get_used(asset)</code> - currently tied up balance (open orders)</li> <li><code>get_total(asset)</code> - total available balance - sum of the 2 above</li> </ul>"},{"location":"strategy-customization/#additional-data-trades","title":"Additional data (Trades)","text":"<p>A history of Trades can be retrieved in the strategy by querying the database.</p> <p>At the top of the file, import Trade.</p> <pre><code>from freqtrade.persistence import Trade\n</code></pre> <p>The following example queries for the current pair and trades from today, however other filters can easily be added.</p> <pre><code>trades = Trade.get_trades_proxy(pair=metadata['pair'],\n                                open_date=datetime.now(timezone.utc) - timedelta(days=1),\n                                is_open=False,\n            ]).order_by(Trade.close_date).all()\n# Summarize profit for this pair.\ncurdayprofit = sum(trade.close_profit for trade in trades)\n</code></pre> <p>For a full list of available methods, please consult the Trade object documentation.</p> <p>Warning</p> <p>Trade history is not available in <code>populate_*</code> methods during backtesting or hyperopt, and will result in empty results.</p>"},{"location":"strategy-customization/#prevent-trades-from-happening-for-a-specific-pair","title":"Prevent trades from happening for a specific pair","text":"<p>Freqtrade locks pairs automatically for the current candle (until that candle is over) when a pair is sold, preventing an immediate re-buy of that pair.</p> <p>Locked pairs will show the message <code>Pair &lt;pair&gt; is currently locked.</code>.</p>"},{"location":"strategy-customization/#locking-pairs-from-within-the-strategy","title":"Locking pairs from within the strategy","text":"<p>Sometimes it may be desired to lock a pair after certain events happen (e.g. multiple losing trades in a row).</p> <p>Freqtrade has an easy method to do this from within the strategy, by calling <code>self.lock_pair(pair, until, [reason])</code>. <code>until</code> must be a datetime object in the future, after which trading will be re-enabled for that pair, while <code>reason</code> is an optional string detailing why the pair was locked.</p> <p>Locks can also be lifted manually, by calling <code>self.unlock_pair(pair)</code> or <code>self.unlock_reason(&lt;reason&gt;)</code> - providing reason the pair was locked with. <code>self.unlock_reason(&lt;reason&gt;)</code> will unlock all pairs currently locked with the provided reason.</p> <p>To verify if a pair is currently locked, use <code>self.is_pair_locked(pair)</code>.</p> <p>Note</p> <p>Locked pairs will always be rounded up to the next candle. So assuming a <code>5m</code> timeframe, a lock with <code>until</code> set to 10:18 will lock the pair until the candle from 10:15-10:20 will be finished.</p> <p>Warning</p> <p>Manually locking pairs is not available during backtesting, only locks via Protections are allowed.</p>"},{"location":"strategy-customization/#pair-locking-example","title":"Pair locking example","text":"<pre><code>from freqtrade.persistence import Trade\nfrom datetime import timedelta, datetime, timezone\n# Put the above lines a the top of the strategy file, next to all the other imports\n# --------\n\n# Within populate indicators (or populate_buy):\nif self.config['runmode'].value in ('live', 'dry_run'):\n    # fetch closed trades for the last 2 days\n    trades = Trade.get_trades_proxy(\n        pair=metadata['pair'], is_open=False, \n        open_date=datetime.now(timezone.utc) - timedelta(days=2))\n    # Analyze the conditions you'd like to lock the pair .... will probably be different for every strategy\n    sumprofit = sum(trade.close_profit for trade in trades)\n    if sumprofit &lt; 0:\n        # Lock pair for 12 hours\n        self.lock_pair(metadata['pair'], until=datetime.now(timezone.utc) + timedelta(hours=12))\n</code></pre>"},{"location":"strategy-customization/#print-created-dataframe","title":"Print created dataframe","text":"<p>To inspect the created dataframe, you can issue a print-statement in either <code>populate_entry_trend()</code> or <code>populate_exit_trend()</code>. You may also want to print the pair so it's clear what data is currently shown.</p> <pre><code>def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n    dataframe.loc[\n        (\n            #&gt;&gt; whatever condition&lt;&lt;&lt;\n        ),\n        ['enter_long', 'enter_tag']] = (1, 'somestring')\n\n    # Print the Analyzed pair\n    print(f\"result for {metadata['pair']}\")\n\n    # Inspect the last 5 rows\n    print(dataframe.tail())\n\n    return dataframe\n</code></pre> <p>Printing more than a few rows is also possible (simply use  <code>print(dataframe)</code> instead of <code>print(dataframe.tail())</code>), however not recommended, as that will be very verbose (~500 lines per pair every 5 seconds).</p>"},{"location":"strategy-customization/#common-mistakes-when-developing-strategies","title":"Common mistakes when developing strategies","text":""},{"location":"strategy-customization/#peeking-into-the-future-while-backtesting","title":"Peeking into the future while backtesting","text":"<p>Backtesting analyzes the whole time-range at once for performance reasons. Because of this, strategy authors need to make sure that strategies do not look-ahead into the future. This is a common pain-point, which can cause huge differences between backtesting and dry/live run methods, since they all use data which is not available during dry/live runs, so these strategies will perform well during backtesting, but will fail / perform badly in real conditions.</p> <p>The following lists some common patterns which should be avoided to prevent frustration:</p> <ul> <li>don't use <code>shift(-1)</code> or other negative values. This uses data from the future in backtesting, which is not available in dry or live modes.</li> <li>don't use <code>.iloc[-1]</code> or any other absolute position in the dataframe within <code>populate_</code> functions, as this will be different between dry-run and backtesting. Absolute <code>iloc</code> indexing is safe to use in callbacks however - see Strategy Callbacks.</li> <li>don't use <code>dataframe['volume'].mean()</code>. This uses the full DataFrame for backtesting, including data from the future. Use <code>dataframe['volume'].rolling(&lt;window&gt;).mean()</code> instead</li> <li>don't use <code>.resample('1h')</code>. This uses the left border of the interval, so moves data from an hour to the start of the hour. Use <code>.resample('1h', label='right')</code> instead.</li> </ul> <p>Identifying problems</p> <p>You may also want to check the 2 helper commands lookahead-analysis and recursive-analysis, which can each help you figure out problems with your strategy in different ways. Please treat them as what they are - helpers to identify most common problems. A negative result of each does not guarantee that there's none of the above errors included.</p>"},{"location":"strategy-customization/#colliding-signals","title":"Colliding signals","text":"<p>When conflicting signals collide (e.g. both <code>'enter_long'</code> and <code>'exit_long'</code> are 1), freqtrade will do nothing and ignore the entry signal. This will avoid trades that enter, and exit immediately. Obviously, this can potentially lead to missed entries.</p> <p>The following rules apply, and entry signals will be ignored if more than one of the 3 signals is set:</p> <ul> <li><code>enter_long</code> -&gt; <code>exit_long</code>, <code>enter_short</code></li> <li><code>enter_short</code> -&gt; <code>exit_short</code>, <code>enter_long</code></li> </ul>"},{"location":"strategy-customization/#further-strategy-ideas","title":"Further strategy ideas","text":"<p>To get additional Ideas for strategies, head over to the strategy repository. Feel free to use them as they are - but results will depend on the current market situation, pairs used etc. - therefore please backtest the strategy for your exchange/desired pairs first, evaluate carefully, use at your own risk. Feel free to use any of them as inspiration for your own strategies. We're happy to accept Pull Requests containing new Strategies to that repo.</p>"},{"location":"strategy-customization/#next-step","title":"Next step","text":"<p>Now you have a perfect strategy you probably want to backtest it. Your next step is to learn How to use the Backtesting.</p>"},{"location":"strategy_analysis_example/","title":"Strategy analysis example","text":"<p>Debugging a strategy can be time-consuming. Freqtrade offers helper functions to visualize raw data. The following assumes you work with SampleStrategy, data for 5m timeframe from Binance and have downloaded them into the data directory in the default location. Please follow the documentation for more details.</p>"},{"location":"strategy_analysis_example/#setup","title":"Setup","text":""},{"location":"strategy_analysis_example/#change-working-directory-to-repository-root","title":"Change Working directory to repository root","text":"<pre><code>import os\nfrom pathlib import Path\n\n# Change directory\n# Modify this cell to insure that the output shows the correct path.\n# Define all paths relative to the project root shown in the cell output\nproject_root = \"somedir/freqtrade\"\ni=0\ntry:\n    os.chdir(project_root)\n    assert Path('LICENSE').is_file()\nexcept:\n    while i&lt;4 and (not Path('LICENSE').is_file()):\n        os.chdir(Path(Path.cwd(), '../'))\n        i+=1\n    project_root = Path.cwd()\nprint(Path.cwd())\n</code></pre>"},{"location":"strategy_analysis_example/#configure-freqtrade-environment","title":"Configure Freqtrade environment","text":"<pre><code>from freqtrade.configuration import Configuration\n\n# Customize these according to your needs.\n\n# Initialize empty configuration object\nconfig = Configuration.from_files([])\n# Optionally (recommended), use existing configuration file\n# config = Configuration.from_files([\"user_data/config.json\"])\n\n# Define some constants\nconfig[\"timeframe\"] = \"5m\"\n# Name of the strategy class\nconfig[\"strategy\"] = \"SampleStrategy\"\n# Location of the data\ndata_location = config[\"datadir\"]\n# Pair to analyze - Only use one pair here\npair = \"BTC/USDT\"\n</code></pre> <pre><code># Load data using values set above\nfrom freqtrade.data.history import load_pair_history\nfrom freqtrade.enums import CandleType\n\ncandles = load_pair_history(datadir=data_location,\n                            timeframe=config[\"timeframe\"],\n                            pair=pair,\n                            data_format = \"json\",  # Make sure to update this to your data\n                            candle_type=CandleType.SPOT,\n                            )\n\n# Confirm success\nprint(f\"Loaded {len(candles)} rows of data for {pair} from {data_location}\")\ncandles.head()\n</code></pre>"},{"location":"strategy_analysis_example/#load-and-run-strategy","title":"Load and run strategy","text":"<ul> <li>Rerun each time the strategy file is changed</li> </ul> <pre><code># Load strategy using values set above\nfrom freqtrade.resolvers import StrategyResolver\nfrom freqtrade.data.dataprovider import DataProvider\nstrategy = StrategyResolver.load_strategy(config)\nstrategy.dp = DataProvider(config, None, None)\nstrategy.ft_bot_start()\n\n# Generate buy/sell signals using strategy\ndf = strategy.analyze_ticker(candles, {'pair': pair})\ndf.tail()\n</code></pre>"},{"location":"strategy_analysis_example/#display-the-trade-details","title":"Display the trade details","text":"<ul> <li>Note that using <code>data.head()</code> would also work, however most indicators have some \"startup\" data at the top of the dataframe.</li> <li>Some possible problems     * Columns with NaN values at the end of the dataframe     * Columns used in <code>crossed*()</code> functions with completely different units</li> <li>Comparison with full backtest     * having 200 buy signals as output for one pair from <code>analyze_ticker()</code> does not necessarily mean that 200 trades will be made during backtesting.     * Assuming you use only one condition such as, <code>df['rsi'] &lt; 30</code> as buy condition, this will generate multiple \"buy\" signals for each pair in sequence (until rsi returns &gt; 29). The bot will only buy on the first of these signals (and also only if a trade-slot (\"max_open_trades\") is still available), or on one of the middle signals, as soon as a \"slot\" becomes available.  </li> </ul> <pre><code># Report results\nprint(f\"Generated {df['enter_long'].sum()} entry signals\")\ndata = df.set_index('date', drop=False)\ndata.tail()\n</code></pre>"},{"location":"strategy_analysis_example/#load-existing-objects-into-a-jupyter-notebook","title":"Load existing objects into a Jupyter notebook","text":"<p>The following cells assume that you have already generated data using the cli. They will allow you to drill deeper into your results, and perform analysis which otherwise would make the output very difficult to digest due to information overload.</p>"},{"location":"strategy_analysis_example/#load-backtest-results-to-pandas-dataframe","title":"Load backtest results to pandas dataframe","text":"<p>Analyze a trades dataframe (also used below for plotting)</p> <pre><code>from freqtrade.data.btanalysis import load_backtest_data, load_backtest_stats\n\n# if backtest_dir points to a directory, it'll automatically load the last backtest file.\nbacktest_dir = config[\"user_data_dir\"] / \"backtest_results\"\n# backtest_dir can also point to a specific file \n# backtest_dir = config[\"user_data_dir\"] / \"backtest_results/backtest-result-2020-07-01_20-04-22.json\"\n</code></pre> <pre><code># You can get the full backtest statistics by using the following command.\n# This contains all information used to generate the backtest result.\nstats = load_backtest_stats(backtest_dir)\n\nstrategy = 'SampleStrategy'\n# All statistics are available per strategy, so if `--strategy-list` was used during backtest, this will be reflected here as well.\n# Example usages:\nprint(stats['strategy'][strategy]['results_per_pair'])\n# Get pairlist used for this backtest\nprint(stats['strategy'][strategy]['pairlist'])\n# Get market change (average change of all pairs from start to end of the backtest period)\nprint(stats['strategy'][strategy]['market_change'])\n# Maximum drawdown ()\nprint(stats['strategy'][strategy]['max_drawdown'])\n# Maximum drawdown start and end\nprint(stats['strategy'][strategy]['drawdown_start'])\nprint(stats['strategy'][strategy]['drawdown_end'])\n\n\n# Get strategy comparison (only relevant if multiple strategies were compared)\nprint(stats['strategy_comparison'])\n</code></pre> <pre><code># Load backtested trades as dataframe\ntrades = load_backtest_data(backtest_dir)\n\n# Show value-counts per pair\ntrades.groupby(\"pair\")[\"exit_reason\"].value_counts()\n</code></pre>"},{"location":"strategy_analysis_example/#plotting-daily-profit-equity-line","title":"Plotting daily profit / equity line","text":"<pre><code># Plotting equity line (starting with 0 on day 1 and adding daily profit for each backtested day)\n\nfrom freqtrade.configuration import Configuration\nfrom freqtrade.data.btanalysis import load_backtest_stats\nimport plotly.express as px\nimport pandas as pd\n\n# strategy = 'SampleStrategy'\n# config = Configuration.from_files([\"user_data/config.json\"])\n# backtest_dir = config[\"user_data_dir\"] / \"backtest_results\"\n\nstats = load_backtest_stats(backtest_dir)\nstrategy_stats = stats['strategy'][strategy]\n\ndf = pd.DataFrame(columns=['dates','equity'], data=strategy_stats['daily_profit'])\ndf['equity_daily'] = df['equity'].cumsum()\n\nfig = px.line(df, x=\"dates\", y=\"equity_daily\")\nfig.show()\n</code></pre>"},{"location":"strategy_analysis_example/#load-live-trading-results-into-a-pandas-dataframe","title":"Load live trading results into a pandas dataframe","text":"<p>In case you did already some trading and want to analyze your performance</p> <pre><code>from freqtrade.data.btanalysis import load_trades_from_db\n\n# Fetch trades from database\ntrades = load_trades_from_db(\"sqlite:///tradesv3.sqlite\")\n\n# Display results\ntrades.groupby(\"pair\")[\"exit_reason\"].value_counts()\n</code></pre>"},{"location":"strategy_analysis_example/#analyze-the-loaded-trades-for-trade-parallelism","title":"Analyze the loaded trades for trade parallelism","text":"<p>This can be useful to find the best <code>max_open_trades</code> parameter, when used with backtesting in conjunction with <code>--disable-max-market-positions</code>.</p> <p><code>analyze_trade_parallelism()</code> returns a timeseries dataframe with an \"open_trades\" column, specifying the number of open trades for each candle.</p> <pre><code>from freqtrade.data.btanalysis import analyze_trade_parallelism\n\n# Analyze the above\nparallel_trades = analyze_trade_parallelism(trades, '5m')\n\nparallel_trades.plot()\n</code></pre>"},{"location":"strategy_analysis_example/#plot-results","title":"Plot results","text":"<p>Freqtrade offers interactive plotting capabilities based on plotly.</p> <pre><code>from freqtrade.plot.plotting import  generate_candlestick_graph\n# Limit graph period to keep plotly quick and reactive\n\n# Filter trades to one pair\ntrades_red = trades.loc[trades['pair'] == pair]\n\ndata_red = data['2019-06-01':'2019-06-10']\n# Generate candlestick graph\ngraph = generate_candlestick_graph(pair=pair,\n                                   data=data_red,\n                                   trades=trades_red,\n                                   indicators1=['sma20', 'ema50', 'ema55'],\n                                   indicators2=['rsi', 'macd', 'macdsignal', 'macdhist']\n                                  )\n</code></pre> <pre><code># Show graph inline\n# graph.show()\n\n# Render graph in a separate window\ngraph.show(renderer=\"browser\")\n</code></pre>"},{"location":"strategy_analysis_example/#plot-average-profit-per-trade-as-distribution-graph","title":"Plot average profit per trade as distribution graph","text":"<pre><code>import plotly.figure_factory as ff\n\nhist_data = [trades.profit_ratio]\ngroup_labels = ['profit_ratio']  # name of the dataset\n\nfig = ff.create_distplot(hist_data, group_labels, bin_size=0.01)\nfig.show()\n</code></pre> <p>Feel free to submit an issue or Pull Request enhancing this document if you would like to share ideas on how to best analyze the data.</p>"},{"location":"strategy_migration/","title":"Strategy Migration between V2 and V3","text":"<p>To support new markets and trade-types (namely short trades / trades with leverage), some things had to change in the interface. If you intend on using markets other than spot markets, please migrate your strategy to the new format.</p> <p>We have put a great effort into keeping compatibility with existing strategies, so if you just want to continue using freqtrade in spot markets, there should be no changes necessary for now.</p> <p>You can use the quick summary as checklist. Please refer to the detailed sections below for full migration details.</p>"},{"location":"strategy_migration/#quick-summary-migration-checklist","title":"Quick summary / migration checklist","text":"<p>Note : <code>forcesell</code>, <code>forcebuy</code>, <code>emergencysell</code> are changed to <code>force_exit</code>, <code>force_enter</code>, <code>emergency_exit</code> respectively.</p> <ul> <li>Strategy methods:<ul> <li><code>populate_buy_trend()</code> -&gt; <code>populate_entry_trend()</code></li> <li><code>populate_sell_trend()</code> -&gt; <code>populate_exit_trend()</code></li> <li><code>custom_sell()</code> -&gt; <code>custom_exit()</code></li> <li><code>check_buy_timeout()</code> -&gt; <code>check_entry_timeout()</code></li> <li><code>check_sell_timeout()</code> -&gt; <code>check_exit_timeout()</code></li> <li>New <code>side</code> argument to callbacks without trade object<ul> <li><code>custom_stake_amount</code></li> <li><code>confirm_trade_entry</code></li> <li><code>custom_entry_price</code></li> </ul> </li> <li>Changed argument name in <code>confirm_trade_exit</code></li> </ul> </li> <li>Dataframe columns:<ul> <li><code>buy</code> -&gt; <code>enter_long</code></li> <li><code>sell</code> -&gt; <code>exit_long</code></li> <li><code>buy_tag</code> -&gt; <code>enter_tag</code> (used for both long and short trades)</li> <li>New column <code>enter_short</code> and corresponding new column <code>exit_short</code></li> </ul> </li> <li>trade-object now has the following new properties:<ul> <li><code>is_short</code></li> <li><code>entry_side</code></li> <li><code>exit_side</code></li> <li><code>trade_direction</code></li> <li>renamed: <code>sell_reason</code> -&gt; <code>exit_reason</code></li> </ul> </li> <li>Renamed <code>trade.nr_of_successful_buys</code> to <code>trade.nr_of_successful_entries</code> (mostly relevant for <code>adjust_trade_position()</code>)</li> <li>Introduced new <code>leverage</code> callback.</li> <li>Informative pairs can now pass a 3<sup>rd</sup> element in the Tuple, defining the candle type.</li> <li><code>@informative</code> decorator now takes an optional <code>candle_type</code> argument.</li> <li>helper methods <code>stoploss_from_open</code> and <code>stoploss_from_absolute</code> now take <code>is_short</code> as additional argument.</li> <li><code>INTERFACE_VERSION</code> should be set to 3.</li> <li>Strategy/Configuration settings.<ul> <li><code>order_time_in_force</code> buy -&gt; entry, sell -&gt; exit.</li> <li><code>order_types</code> buy -&gt; entry, sell -&gt; exit.</li> <li><code>unfilledtimeout</code> buy -&gt; entry, sell -&gt; exit.</li> <li><code>ignore_buying_expired_candle_after</code> -&gt; moved to root level instead of \"ask_strategy/exit_pricing\"</li> </ul> </li> <li>Terminology changes<ul> <li>Sell reasons changed to reflect the new naming of \"exit\" instead of sells. Be careful in your strategy if you're using <code>exit_reason</code> checks and eventually update your strategy.<ul> <li><code>sell_signal</code> -&gt; <code>exit_signal</code></li> <li><code>custom_sell</code> -&gt; <code>custom_exit</code></li> <li><code>force_sell</code> -&gt; <code>force_exit</code></li> <li><code>emergency_sell</code> -&gt; <code>emergency_exit</code></li> </ul> </li> <li>Order pricing<ul> <li><code>bid_strategy</code> -&gt; <code>entry_pricing</code></li> <li><code>ask_strategy</code> -&gt; <code>exit_pricing</code></li> <li><code>ask_last_balance</code> -&gt; <code>price_last_balance</code></li> <li><code>bid_last_balance</code> -&gt; <code>price_last_balance</code></li> </ul> </li> <li>Webhook terminology changed from \"sell\" to \"exit\", and from \"buy\" to entry<ul> <li><code>webhookbuy</code> -&gt; <code>entry</code></li> <li><code>webhookbuyfill</code> -&gt; <code>entry_fill</code></li> <li><code>webhookbuycancel</code> -&gt; <code>entry_cancel</code></li> <li><code>webhooksell</code> -&gt; <code>exit</code></li> <li><code>webhooksellfill</code> -&gt; <code>exit_fill</code></li> <li><code>webhooksellcancel</code> -&gt; <code>exit_cancel</code></li> </ul> </li> <li>Telegram notification settings<ul> <li><code>buy</code> -&gt; <code>entry</code></li> <li><code>buy_fill</code> -&gt; <code>entry_fill</code></li> <li><code>buy_cancel</code> -&gt; <code>entry_cancel</code></li> <li><code>sell</code> -&gt; <code>exit</code></li> <li><code>sell_fill</code> -&gt; <code>exit_fill</code></li> <li><code>sell_cancel</code> -&gt; <code>exit_cancel</code></li> </ul> </li> <li>Strategy/config settings:<ul> <li><code>use_sell_signal</code> -&gt; <code>use_exit_signal</code></li> <li><code>sell_profit_only</code> -&gt; <code>exit_profit_only</code></li> <li><code>sell_profit_offset</code> -&gt; <code>exit_profit_offset</code></li> <li><code>ignore_roi_if_buy_signal</code> -&gt; <code>ignore_roi_if_entry_signal</code></li> <li><code>forcebuy_enable</code> -&gt; <code>force_entry_enable</code></li> </ul> </li> </ul> </li> </ul>"},{"location":"strategy_migration/#extensive-explanation","title":"Extensive explanation","text":""},{"location":"strategy_migration/#populate_buy_trend","title":"<code>populate_buy_trend</code>","text":"<p>In <code>populate_buy_trend()</code> - you will want to change the columns you assign from <code>'buy</code>' to <code>'enter_long'</code>, as well as the method name from <code>populate_buy_trend</code> to <code>populate_entry_trend</code>.</p> <pre><code>def populate_buy_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n    dataframe.loc[\n        (\n            (qtpylib.crossed_above(dataframe['rsi'], 30)) &amp;  # Signal: RSI crosses above 30\n            (dataframe['tema'] &lt;= dataframe['bb_middleband']) &amp;  # Guard\n            (dataframe['tema'] &gt; dataframe['tema'].shift(1)) &amp;  # Guard\n            (dataframe['volume'] &gt; 0)  # Make sure Volume is not 0\n        ),\n        ['buy', 'buy_tag']] = (1, 'rsi_cross')\n\n    return dataframe\n</code></pre> <p>After:</p> <pre><code>def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n    dataframe.loc[\n        (\n            (qtpylib.crossed_above(dataframe['rsi'], 30)) &amp;  # Signal: RSI crosses above 30\n            (dataframe['tema'] &lt;= dataframe['bb_middleband']) &amp;  # Guard\n            (dataframe['tema'] &gt; dataframe['tema'].shift(1)) &amp;  # Guard\n            (dataframe['volume'] &gt; 0)  # Make sure Volume is not 0\n        ),\n        ['enter_long', 'enter_tag']] = (1, 'rsi_cross')\n\n    return dataframe\n</code></pre> <p>Please refer to the Strategy documentation on how to enter and exit short trades.</p>"},{"location":"strategy_migration/#populate_sell_trend","title":"<code>populate_sell_trend</code>","text":"<p>Similar to <code>populate_buy_trend</code>, <code>populate_sell_trend()</code> will be renamed to <code>populate_exit_trend()</code>. We'll also change the column from <code>'sell'</code> to <code>'exit_long'</code>.</p> <pre><code>def populate_sell_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n    dataframe.loc[\n        (\n            (qtpylib.crossed_above(dataframe['rsi'], 70)) &amp;  # Signal: RSI crosses above 70\n            (dataframe['tema'] &gt; dataframe['bb_middleband']) &amp;  # Guard\n            (dataframe['tema'] &lt; dataframe['tema'].shift(1)) &amp;  # Guard\n            (dataframe['volume'] &gt; 0)  # Make sure Volume is not 0\n        ),\n        ['sell', 'exit_tag']] = (1, 'some_exit_tag')\n    return dataframe\n</code></pre> <p>After</p> <pre><code>def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -&gt; DataFrame:\n    dataframe.loc[\n        (\n            (qtpylib.crossed_above(dataframe['rsi'], 70)) &amp;  # Signal: RSI crosses above 70\n            (dataframe['tema'] &gt; dataframe['bb_middleband']) &amp;  # Guard\n            (dataframe['tema'] &lt; dataframe['tema'].shift(1)) &amp;  # Guard\n            (dataframe['volume'] &gt; 0)  # Make sure Volume is not 0\n        ),\n        ['exit_long', 'exit_tag']] = (1, 'some_exit_tag')\n    return dataframe\n</code></pre> <p>Please refer to the Strategy documentation on how to enter and exit short trades.</p>"},{"location":"strategy_migration/#custom_sell","title":"<code>custom_sell</code>","text":"<p><code>custom_sell</code> has been renamed to <code>custom_exit</code>. It's now also being called for every iteration, independent of current profit and <code>exit_profit_only</code> settings.</p> <pre><code>class AwesomeStrategy(IStrategy):\n    def custom_sell(self, pair: str, trade: 'Trade', current_time: 'datetime', current_rate: float,\n                    current_profit: float, **kwargs):\n        dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe)\n        last_candle = dataframe.iloc[-1].squeeze()\n        # ...\n</code></pre> <pre><code>class AwesomeStrategy(IStrategy):\n    def custom_exit(self, pair: str, trade: 'Trade', current_time: 'datetime', current_rate: float,\n                    current_profit: float, **kwargs):\n        dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe)\n        last_candle = dataframe.iloc[-1].squeeze()\n        # ...\n</code></pre>"},{"location":"strategy_migration/#custom_entry_timeout","title":"<code>custom_entry_timeout</code>","text":"<p><code>check_buy_timeout()</code> has been renamed to <code>check_entry_timeout()</code>, and <code>check_sell_timeout()</code> has been renamed to <code>check_exit_timeout()</code>.</p> <pre><code>class AwesomeStrategy(IStrategy):\n    def check_buy_timeout(self, pair: str, trade: 'Trade', order: dict, \n                            current_time: datetime, **kwargs) -&gt; bool:\n        return False\n\n    def check_sell_timeout(self, pair: str, trade: 'Trade', order: dict, \n                            current_time: datetime, **kwargs) -&gt; bool:\n        return False \n</code></pre> <pre><code>class AwesomeStrategy(IStrategy):\n    def check_entry_timeout(self, pair: str, trade: 'Trade', order: 'Order', \n                            current_time: datetime, **kwargs) -&gt; bool:\n        return False\n\n    def check_exit_timeout(self, pair: str, trade: 'Trade', order: 'Order', \n                            current_time: datetime, **kwargs) -&gt; bool:\n        return False \n</code></pre>"},{"location":"strategy_migration/#custom_stake_amount","title":"<code>custom_stake_amount</code>","text":"<p>New string argument <code>side</code> - which can be either <code>\"long\"</code> or <code>\"short\"</code>.</p> <pre><code>class AwesomeStrategy(IStrategy):\n    def custom_stake_amount(self, pair: str, current_time: datetime, current_rate: float,\n                            proposed_stake: float, min_stake: Optional[float], max_stake: float,\n                            entry_tag: Optional[str], **kwargs) -&gt; float:\n        # ... \n        return proposed_stake\n</code></pre> <pre><code>class AwesomeStrategy(IStrategy):\n    def custom_stake_amount(self, pair: str, current_time: datetime, current_rate: float,\n                            proposed_stake: float, min_stake: Optional[float], max_stake: float,\n                            entry_tag: Optional[str], side: str, **kwargs) -&gt; float:\n        # ... \n        return proposed_stake\n</code></pre>"},{"location":"strategy_migration/#confirm_trade_entry","title":"<code>confirm_trade_entry</code>","text":"<p>New string argument <code>side</code> - which can be either <code>\"long\"</code> or <code>\"short\"</code>.</p> <pre><code>class AwesomeStrategy(IStrategy):\n    def confirm_trade_entry(self, pair: str, order_type: str, amount: float, rate: float,\n                            time_in_force: str, current_time: datetime, entry_tag: Optional[str], \n                            **kwargs) -&gt; bool:\n      return True\n</code></pre> <p>After: </p> <pre><code>class AwesomeStrategy(IStrategy):\n    def confirm_trade_entry(self, pair: str, order_type: str, amount: float, rate: float,\n                            time_in_force: str, current_time: datetime, entry_tag: Optional[str], \n                            side: str, **kwargs) -&gt; bool:\n      return True\n</code></pre>"},{"location":"strategy_migration/#confirm_trade_exit","title":"<code>confirm_trade_exit</code>","text":"<p>Changed argument <code>sell_reason</code> to <code>exit_reason</code>. For compatibility, <code>sell_reason</code> will still be provided for a limited time.</p> <pre><code>class AwesomeStrategy(IStrategy):\n    def confirm_trade_exit(self, pair: str, trade: Trade, order_type: str, amount: float,\n                           rate: float, time_in_force: str, sell_reason: str,\n                           current_time: datetime, **kwargs) -&gt; bool:\n    return True\n</code></pre> <p>After:</p> <pre><code>class AwesomeStrategy(IStrategy):\n    def confirm_trade_exit(self, pair: str, trade: Trade, order_type: str, amount: float,\n                           rate: float, time_in_force: str, exit_reason: str,\n                           current_time: datetime, **kwargs) -&gt; bool:\n    return True\n</code></pre>"},{"location":"strategy_migration/#custom_entry_price","title":"<code>custom_entry_price</code>","text":"<p>New string argument <code>side</code> - which can be either <code>\"long\"</code> or <code>\"short\"</code>.</p> <pre><code>class AwesomeStrategy(IStrategy):\n    def custom_entry_price(self, pair: str, current_time: datetime, proposed_rate: float,\n                           entry_tag: Optional[str], **kwargs) -&gt; float:\n      return proposed_rate\n</code></pre> <p>After:</p> <pre><code>class AwesomeStrategy(IStrategy):\n    def custom_entry_price(self, pair: str, trade: Optional[Trade], current_time: datetime, proposed_rate: float,\n                           entry_tag: Optional[str], side: str, **kwargs) -&gt; float:\n      return proposed_rate\n</code></pre>"},{"location":"strategy_migration/#adjust-trade-position-changes","title":"Adjust trade position changes","text":"<p>While adjust-trade-position itself did not change, you should no longer use <code>trade.nr_of_successful_buys</code> - and instead use <code>trade.nr_of_successful_entries</code>, which will also include short entries.</p>"},{"location":"strategy_migration/#helper-methods","title":"Helper methods","text":"<p>Added argument \"is_short\" to <code>stoploss_from_open</code> and <code>stoploss_from_absolute</code>. This should be given the value of <code>trade.is_short</code>.</p> <pre><code>    def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime,\n                        current_rate: float, current_profit: float, **kwargs) -&gt; float:\n        # once the profit has risen above 10%, keep the stoploss at 7% above the open price\n        if current_profit &gt; 0.10:\n            return stoploss_from_open(0.07, current_profit)\n\n        return stoploss_from_absolute(current_rate - (candle['atr'] * 2), current_rate)\n\n        return 1\n</code></pre> <p>After:</p> <pre><code>    def custom_stoploss(self, pair: str, trade: 'Trade', current_time: datetime,\n                        current_rate: float, current_profit: float, after_fill: bool, \n                        **kwargs) -&gt; Optional[float]:\n        # once the profit has risen above 10%, keep the stoploss at 7% above the open price\n        if current_profit &gt; 0.10:\n            return stoploss_from_open(0.07, current_profit, is_short=trade.is_short)\n\n        return stoploss_from_absolute(current_rate - (candle['atr'] * 2), current_rate, is_short=trade.is_short, leverage=trade.leverage)\n</code></pre>"},{"location":"strategy_migration/#strategyconfiguration-settings","title":"Strategy/Configuration settings","text":""},{"location":"strategy_migration/#order_time_in_force","title":"<code>order_time_in_force</code>","text":"<p><code>order_time_in_force</code> attributes changed from <code>\"buy\"</code> to <code>\"entry\"</code> and <code>\"sell\"</code> to <code>\"exit\"</code>.</p> <pre><code>    order_time_in_force: Dict = {\n        \"buy\": \"gtc\",\n        \"sell\": \"gtc\",\n    }\n</code></pre> <p>After:</p> <pre><code>    order_time_in_force: Dict = {\n        \"entry\": \"GTC\",\n        \"exit\": \"GTC\",\n    }\n</code></pre>"},{"location":"strategy_migration/#order_types","title":"<code>order_types</code>","text":"<p><code>order_types</code> have changed all wordings from <code>buy</code> to <code>entry</code> - and <code>sell</code> to <code>exit</code>. And two words are joined with <code>_</code>. </p> <pre><code>    order_types = {\n        \"buy\": \"limit\",\n        \"sell\": \"limit\",\n        \"emergencysell\": \"market\",\n        \"forcesell\": \"market\",\n        \"forcebuy\": \"market\",\n        \"stoploss\": \"market\",\n        \"stoploss_on_exchange\": false,\n        \"stoploss_on_exchange_interval\": 60\n    }\n</code></pre> <p>After:</p> <pre><code>    order_types = {\n        \"entry\": \"limit\",\n        \"exit\": \"limit\",\n        \"emergency_exit\": \"market\",\n        \"force_exit\": \"market\",\n        \"force_entry\": \"market\",\n        \"stoploss\": \"market\",\n        \"stoploss_on_exchange\": false,\n        \"stoploss_on_exchange_interval\": 60\n    }\n</code></pre>"},{"location":"strategy_migration/#strategy-level-settings","title":"Strategy level settings","text":"<ul> <li><code>use_sell_signal</code> -&gt; <code>use_exit_signal</code></li> <li><code>sell_profit_only</code> -&gt; <code>exit_profit_only</code></li> <li><code>sell_profit_offset</code> -&gt; <code>exit_profit_offset</code></li> <li><code>ignore_roi_if_buy_signal</code> -&gt; <code>ignore_roi_if_entry_signal</code></li> </ul> <pre><code>    # These values can be overridden in the config.\n    use_sell_signal = True\n    sell_profit_only = True\n    sell_profit_offset: 0.01\n    ignore_roi_if_buy_signal = False\n</code></pre> <p>After:</p> <pre><code>    # These values can be overridden in the config.\n    use_exit_signal = True\n    exit_profit_only = True\n    exit_profit_offset: 0.01\n    ignore_roi_if_entry_signal = False\n</code></pre>"},{"location":"strategy_migration/#unfilledtimeout","title":"<code>unfilledtimeout</code>","text":"<p><code>unfilledtimeout</code> have changed all wordings from <code>buy</code> to <code>entry</code> - and <code>sell</code> to <code>exit</code>.</p> <pre><code>unfilledtimeout = {\n        \"buy\": 10,\n        \"sell\": 10,\n        \"exit_timeout_count\": 0,\n        \"unit\": \"minutes\"\n    }\n</code></pre> <p>After:</p> <pre><code>unfilledtimeout = {\n        \"entry\": 10,\n        \"exit\": 10,\n        \"exit_timeout_count\": 0,\n        \"unit\": \"minutes\"\n    }\n</code></pre>"},{"location":"strategy_migration/#order-pricing","title":"<code>order pricing</code>","text":"<p>Order pricing changed in 2 ways. <code>bid_strategy</code> was renamed to <code>entry_pricing</code> and <code>ask_strategy</code> was renamed to <code>exit_pricing</code>. The attributes <code>ask_last_balance</code> -&gt; <code>price_last_balance</code> and <code>bid_last_balance</code> -&gt; <code>price_last_balance</code> were renamed as well. Also, price-side can now be defined as <code>ask</code>, <code>bid</code>, <code>same</code> or <code>other</code>. Please refer to the pricing documentation for more information.</p> <pre><code>{\n    \"bid_strategy\": {\n        \"price_side\": \"bid\",\n        \"use_order_book\": true,\n        \"order_book_top\": 1,\n        \"ask_last_balance\": 0.0,\n        \"check_depth_of_market\": {\n            \"enabled\": false,\n            \"bids_to_ask_delta\": 1\n        }\n    },\n    \"ask_strategy\":{\n        \"price_side\": \"ask\",\n        \"use_order_book\": true,\n        \"order_book_top\": 1,\n        \"bid_last_balance\": 0.0\n        \"ignore_buying_expired_candle_after\": 120\n    }\n}\n</code></pre> <p>after:</p> <pre><code>{\n    \"entry_pricing\": {\n        \"price_side\": \"same\",\n        \"use_order_book\": true,\n        \"order_book_top\": 1,\n        \"price_last_balance\": 0.0,\n        \"check_depth_of_market\": {\n            \"enabled\": false,\n            \"bids_to_ask_delta\": 1\n        }\n    },\n    \"exit_pricing\":{\n        \"price_side\": \"same\",\n        \"use_order_book\": true,\n        \"order_book_top\": 1,\n        \"price_last_balance\": 0.0\n    },\n    \"ignore_buying_expired_candle_after\": 120\n}\n</code></pre>"},{"location":"strategy_migration/#freqai-strategy","title":"FreqAI strategy","text":"<p>The <code>populate_any_indicators()</code> method has been split into <code>feature_engineering_expand_all()</code>, <code>feature_engineering_expand_basic()</code>, <code>feature_engineering_standard()</code> and<code>set_freqai_targets()</code>.</p> <p>For each new function, the pair (and timeframe where necessary) will be automatically added to the column. As such, the definition of features becomes much simpler with the new logic.</p> <p>For a full explanation of each method, please go to the corresponding freqAI documentation page</p> <pre><code>def populate_any_indicators(\n        self, pair, df, tf, informative=None, set_generalized_indicators=False\n    ):\n\n        if informative is None:\n            informative = self.dp.get_pair_dataframe(pair, tf)\n\n        # first loop is automatically duplicating indicators for time periods\n        for t in self.freqai_info[\"feature_parameters\"][\"indicator_periods_candles\"]:\n\n            t = int(t)\n            informative[f\"%-{pair}rsi-period_{t}\"] = ta.RSI(informative, timeperiod=t)\n            informative[f\"%-{pair}mfi-period_{t}\"] = ta.MFI(informative, timeperiod=t)\n            informative[f\"%-{pair}adx-period_{t}\"] = ta.ADX(informative, timeperiod=t)\n            informative[f\"%-{pair}sma-period_{t}\"] = ta.SMA(informative, timeperiod=t)\n            informative[f\"%-{pair}ema-period_{t}\"] = ta.EMA(informative, timeperiod=t)\n\n            bollinger = qtpylib.bollinger_bands(\n                qtpylib.typical_price(informative), window=t, stds=2.2\n            )\n            informative[f\"{pair}bb_lowerband-period_{t}\"] = bollinger[\"lower\"]\n            informative[f\"{pair}bb_middleband-period_{t}\"] = bollinger[\"mid\"]\n            informative[f\"{pair}bb_upperband-period_{t}\"] = bollinger[\"upper\"]\n\n            informative[f\"%-{pair}bb_width-period_{t}\"] = (\n                informative[f\"{pair}bb_upperband-period_{t}\"]\n                - informative[f\"{pair}bb_lowerband-period_{t}\"]\n            ) / informative[f\"{pair}bb_middleband-period_{t}\"]\n            informative[f\"%-{pair}close-bb_lower-period_{t}\"] = (\n                informative[\"close\"] / informative[f\"{pair}bb_lowerband-period_{t}\"]\n            )\n\n            informative[f\"%-{pair}roc-period_{t}\"] = ta.ROC(informative, timeperiod=t)\n\n            informative[f\"%-{pair}relative_volume-period_{t}\"] = (\n                informative[\"volume\"] / informative[\"volume\"].rolling(t).mean()\n            ) # (1)\n\n        informative[f\"%-{pair}pct-change\"] = informative[\"close\"].pct_change()\n        informative[f\"%-{pair}raw_volume\"] = informative[\"volume\"]\n        informative[f\"%-{pair}raw_price\"] = informative[\"close\"]\n        # (2)\n\n        indicators = [col for col in informative if col.startswith(\"%\")]\n        # This loop duplicates and shifts all indicators to add a sense of recency to data\n        for n in range(self.freqai_info[\"feature_parameters\"][\"include_shifted_candles\"] + 1):\n            if n == 0:\n                continue\n            informative_shift = informative[indicators].shift(n)\n            informative_shift = informative_shift.add_suffix(\"_shift-\" + str(n))\n            informative = pd.concat((informative, informative_shift), axis=1)\n\n        df = merge_informative_pair(df, informative, self.config[\"timeframe\"], tf, ffill=True)\n        skip_columns = [\n            (s + \"_\" + tf) for s in [\"date\", \"open\", \"high\", \"low\", \"close\", \"volume\"]\n        ]\n        df = df.drop(columns=skip_columns)\n\n        # Add generalized indicators here (because in live, it will call this\n        # function to populate indicators during training). Notice how we ensure not to\n        # add them multiple times\n        if set_generalized_indicators:\n            df[\"%-day_of_week\"] = (df[\"date\"].dt.dayofweek + 1) / 7\n            df[\"%-hour_of_day\"] = (df[\"date\"].dt.hour + 1) / 25\n            # (3)\n\n            # user adds targets here by prepending them with &amp;- (see convention below)\n            df[\"&amp;-s_close\"] = (\n                df[\"close\"]\n                .shift(-self.freqai_info[\"feature_parameters\"][\"label_period_candles\"])\n                .rolling(self.freqai_info[\"feature_parameters\"][\"label_period_candles\"])\n                .mean()\n                / df[\"close\"]\n                - 1\n            )  # (4)\n\n        return df\n</code></pre> <ol> <li>Features - Move to <code>feature_engineering_expand_all</code></li> <li>Basic features, not expanded across <code>indicator_periods_candles</code> - move to<code>feature_engineering_expand_basic()</code>.</li> <li>Standard features which should not be expanded - move to <code>feature_engineering_standard()</code>.</li> <li>Targets - Move this part to <code>set_freqai_targets()</code>.</li> </ol>"},{"location":"strategy_migration/#freqai-feature-engineering-expand-all","title":"freqai - feature engineering expand all","text":"<p>Features will now expand automatically. As such, the expansion loops, as well as the <code>{pair}</code> / <code>{timeframe}</code> parts will need to be removed.</p> <pre><code>    def feature_engineering_expand_all(self, dataframe, period, **kwargs) -&gt; DataFrame::\n        \"\"\"\n        *Only functional with FreqAI enabled strategies*\n        This function will automatically expand the defined features on the config defined\n        `indicator_periods_candles`, `include_timeframes`, `include_shifted_candles`, and\n        `include_corr_pairs`. In other words, a single feature defined in this function\n        will automatically expand to a total of\n        `indicator_periods_candles` * `include_timeframes` * `include_shifted_candles` *\n        `include_corr_pairs` numbers of features added to the model.\n\n        All features must be prepended with `%` to be recognized by FreqAI internals.\n\n        More details on how these config defined parameters accelerate feature engineering\n        in the documentation at:\n\n        https://www.freqtrade.io/en/latest/freqai-parameter-table/#feature-parameters\n\n        https://www.freqtrade.io/en/latest/freqai-feature-engineering/#defining-the-features\n\n        :param df: strategy dataframe which will receive the features\n        :param period: period of the indicator - usage example:\n        dataframe[\"%-ema-period\"] = ta.EMA(dataframe, timeperiod=period)\n        \"\"\"\n\n        dataframe[\"%-rsi-period\"] = ta.RSI(dataframe, timeperiod=period)\n        dataframe[\"%-mfi-period\"] = ta.MFI(dataframe, timeperiod=period)\n        dataframe[\"%-adx-period\"] = ta.ADX(dataframe, timeperiod=period)\n        dataframe[\"%-sma-period\"] = ta.SMA(dataframe, timeperiod=period)\n        dataframe[\"%-ema-period\"] = ta.EMA(dataframe, timeperiod=period)\n\n        bollinger = qtpylib.bollinger_bands(\n            qtpylib.typical_price(dataframe), window=period, stds=2.2\n        )\n        dataframe[\"bb_lowerband-period\"] = bollinger[\"lower\"]\n        dataframe[\"bb_middleband-period\"] = bollinger[\"mid\"]\n        dataframe[\"bb_upperband-period\"] = bollinger[\"upper\"]\n\n        dataframe[\"%-bb_width-period\"] = (\n            dataframe[\"bb_upperband-period\"]\n            - dataframe[\"bb_lowerband-period\"]\n        ) / dataframe[\"bb_middleband-period\"]\n        dataframe[\"%-close-bb_lower-period\"] = (\n            dataframe[\"close\"] / dataframe[\"bb_lowerband-period\"]\n        )\n\n        dataframe[\"%-roc-period\"] = ta.ROC(dataframe, timeperiod=period)\n\n        dataframe[\"%-relative_volume-period\"] = (\n            dataframe[\"volume\"] / dataframe[\"volume\"].rolling(period).mean()\n        )\n\n        return dataframe\n</code></pre>"},{"location":"strategy_migration/#freqai-feature-engineering-basic","title":"Freqai - feature engineering basic","text":"<p>Basic features. Make sure to remove the <code>{pair}</code> part from your features.</p> <pre><code>    def feature_engineering_expand_basic(self, dataframe: DataFrame, **kwargs) -&gt; DataFrame::\n        \"\"\"\n        *Only functional with FreqAI enabled strategies*\n        This function will automatically expand the defined features on the config defined\n        `include_timeframes`, `include_shifted_candles`, and `include_corr_pairs`.\n        In other words, a single feature defined in this function\n        will automatically expand to a total of\n        `include_timeframes` * `include_shifted_candles` * `include_corr_pairs`\n        numbers of features added to the model.\n\n        Features defined here will *not* be automatically duplicated on user defined\n        `indicator_periods_candles`\n\n        All features must be prepended with `%` to be recognized by FreqAI internals.\n\n        More details on how these config defined parameters accelerate feature engineering\n        in the documentation at:\n\n        https://www.freqtrade.io/en/latest/freqai-parameter-table/#feature-parameters\n\n        https://www.freqtrade.io/en/latest/freqai-feature-engineering/#defining-the-features\n\n        :param df: strategy dataframe which will receive the features\n        dataframe[\"%-pct-change\"] = dataframe[\"close\"].pct_change()\n        dataframe[\"%-ema-200\"] = ta.EMA(dataframe, timeperiod=200)\n        \"\"\"\n        dataframe[\"%-pct-change\"] = dataframe[\"close\"].pct_change()\n        dataframe[\"%-raw_volume\"] = dataframe[\"volume\"]\n        dataframe[\"%-raw_price\"] = dataframe[\"close\"]\n        return dataframe\n</code></pre>"},{"location":"strategy_migration/#freqai-feature-engineering-standard","title":"FreqAI - feature engineering standard","text":"<pre><code>    def feature_engineering_standard(self, dataframe: DataFrame, **kwargs) -&gt; DataFrame:\n        \"\"\"\n        *Only functional with FreqAI enabled strategies*\n        This optional function will be called once with the dataframe of the base timeframe.\n        This is the final function to be called, which means that the dataframe entering this\n        function will contain all the features and columns created by all other\n        freqai_feature_engineering_* functions.\n\n        This function is a good place to do custom exotic feature extractions (e.g. tsfresh).\n        This function is a good place for any feature that should not be auto-expanded upon\n        (e.g. day of the week).\n\n        All features must be prepended with `%` to be recognized by FreqAI internals.\n\n        More details about feature engineering available:\n\n        https://www.freqtrade.io/en/latest/freqai-feature-engineering\n\n        :param df: strategy dataframe which will receive the features\n        usage example: dataframe[\"%-day_of_week\"] = (dataframe[\"date\"].dt.dayofweek + 1) / 7\n        \"\"\"\n        dataframe[\"%-day_of_week\"] = dataframe[\"date\"].dt.dayofweek\n        dataframe[\"%-hour_of_day\"] = dataframe[\"date\"].dt.hour\n        return dataframe\n</code></pre>"},{"location":"strategy_migration/#freqai-set-targets","title":"FreqAI - set Targets","text":"<p>Targets now get their own, dedicated method.</p> <pre><code>    def set_freqai_targets(self, dataframe: DataFrame, **kwargs) -&gt; DataFrame:\n        \"\"\"\n        *Only functional with FreqAI enabled strategies*\n        Required function to set the targets for the model.\n        All targets must be prepended with `&amp;` to be recognized by the FreqAI internals.\n\n        More details about feature engineering available:\n\n        https://www.freqtrade.io/en/latest/freqai-feature-engineering\n\n        :param df: strategy dataframe which will receive the targets\n        usage example: dataframe[\"&amp;-target\"] = dataframe[\"close\"].shift(-1) / dataframe[\"close\"]\n        \"\"\"\n        dataframe[\"&amp;-s_close\"] = (\n            dataframe[\"close\"]\n            .shift(-self.freqai_info[\"feature_parameters\"][\"label_period_candles\"])\n            .rolling(self.freqai_info[\"feature_parameters\"][\"label_period_candles\"])\n            .mean()\n            / dataframe[\"close\"]\n            - 1\n            )\n\n        return dataframe\n</code></pre>"},{"location":"strategy_migration/#freqai-new-data-pipeline","title":"FreqAI - New data Pipeline","text":"<p>If you have created your own custom <code>IFreqaiModel</code> with a custom <code>train()</code>/<code>predict()</code> function, and you still rely on <code>data_cleaning_train/predict()</code>, then you will need to migrate to the new pipeline. If your model does not rely on <code>data_cleaning_train/predict()</code>, then you do not need to worry about this migration. That means that this migration guide is relevant for a very small percentage of power-users. If you stumbled upon this guide by mistake, feel free to inquire in depth about your problem in the Freqtrade discord server.</p> <p>The conversion involves first removing <code>data_cleaning_train/predict()</code> and replacing them with a <code>define_data_pipeline()</code> and <code>define_label_pipeline()</code> function to your <code>IFreqaiModel</code> class:</p> <pre><code>class MyCoolFreqaiModel(BaseRegressionModel):\n    \"\"\"\n    Some cool custom IFreqaiModel you made before Freqtrade version 2023.6\n    \"\"\"\n    def train(\n        self, unfiltered_df: DataFrame, pair: str, dk: FreqaiDataKitchen, **kwargs\n    ) -&gt; Any:\n\n        # ... your custom stuff\n\n        # Remove these lines\n        # data_dictionary = dk.make_train_test_datasets(features_filtered, labels_filtered)\n        # self.data_cleaning_train(dk)\n        # data_dictionary = dk.normalize_data(data_dictionary)\n        # (1)\n\n        # Add these lines. Now we control the pipeline fit/transform ourselves\n        dd = dk.make_train_test_datasets(features_filtered, labels_filtered)\n        dk.feature_pipeline = self.define_data_pipeline(threads=dk.thread_count)\n        dk.label_pipeline = self.define_label_pipeline(threads=dk.thread_count)\n\n        (dd[\"train_features\"],\n         dd[\"train_labels\"],\n         dd[\"train_weights\"]) = dk.feature_pipeline.fit_transform(dd[\"train_features\"],\n                                                                  dd[\"train_labels\"],\n                                                                  dd[\"train_weights\"])\n\n        (dd[\"test_features\"],\n         dd[\"test_labels\"],\n         dd[\"test_weights\"]) = dk.feature_pipeline.transform(dd[\"test_features\"],\n                                                             dd[\"test_labels\"],\n                                                             dd[\"test_weights\"])\n\n        dd[\"train_labels\"], _, _ = dk.label_pipeline.fit_transform(dd[\"train_labels\"])\n        dd[\"test_labels\"], _, _ = dk.label_pipeline.transform(dd[\"test_labels\"])\n\n        # ... your custom code\n\n        return model\n\n    def predict(\n        self, unfiltered_df: DataFrame, dk: FreqaiDataKitchen, **kwargs\n    ) -&gt; Tuple[DataFrame, npt.NDArray[np.int_]]:\n\n        # ... your custom stuff\n\n        # Remove these lines:\n        # self.data_cleaning_predict(dk)\n        # (2)\n\n        # Add these lines:\n        dk.data_dictionary[\"prediction_features\"], outliers, _ = dk.feature_pipeline.transform(\n            dk.data_dictionary[\"prediction_features\"], outlier_check=True)\n\n        # Remove this line\n        # pred_df = dk.denormalize_labels_from_metadata(pred_df)\n        # (3)\n\n        # Replace with these lines\n        pred_df, _, _ = dk.label_pipeline.inverse_transform(pred_df)\n        if self.freqai_info.get(\"DI_threshold\", 0) &gt; 0:\n            dk.DI_values = dk.feature_pipeline[\"di\"].di_values\n        else:\n            dk.DI_values = np.zeros(outliers.shape[0])\n        dk.do_predict = outliers\n\n        # ... your custom code\n        return (pred_df, dk.do_predict)\n</code></pre> <ol> <li>Data normalization and cleaning is now homogenized with the new pipeline definition. This is created in the new <code>define_data_pipeline()</code> and <code>define_label_pipeline()</code> functions. The <code>data_cleaning_train()</code> and <code>data_cleaning_predict()</code> functions are no longer used. You can override <code>define_data_pipeline()</code> to create your own custom pipeline if you wish.</li> <li>Data normalization and cleaning is now homogenized with the new pipeline definition. This is created in the new <code>define_data_pipeline()</code> and <code>define_label_pipeline()</code> functions. The <code>data_cleaning_train()</code> and <code>data_cleaning_predict()</code> functions are no longer used. You can override <code>define_data_pipeline()</code> to create your own custom pipeline if you wish.</li> <li>Data denormalization is done with the new pipeline. Replace this with the lines below.</li> </ol>"},{"location":"telegram-usage/","title":"Telegram usage","text":""},{"location":"telegram-usage/#setup-your-telegram-bot","title":"Setup your Telegram bot","text":"<p>Below we explain how to create your Telegram Bot, and how to get your Telegram user id.</p>"},{"location":"telegram-usage/#1-create-your-telegram-bot","title":"1. Create your Telegram bot","text":"<p>Start a chat with the Telegram BotFather</p> <p>Send the message <code>/newbot</code>.</p> <p>BotFather response:</p> <p>Alright, a new bot. How are we going to call it? Please choose a name for your bot.</p> <p>Choose the public name of your bot (e.x. <code>Freqtrade bot</code>)</p> <p>BotFather response:</p> <p>Good. Now let's choose a username for your bot. It must end in <code>bot</code>. Like this, for example: TetrisBot or tetris_bot.</p> <p>Choose the name id of your bot and send it to the BotFather (e.g. \"<code>My_own_freqtrade_bot</code>\")</p> <p>BotFather response:</p> <p>Done! Congratulations on your new bot. You will find it at <code>t.me/yourbots_name_bot</code>. You can now add a description, about section and profile picture for your bot, see /help for a list of commands. By the way, when you've finished creating your cool bot, ping our Bot Support if you want a better username for it. Just make sure the bot is fully operational before you do this.</p> <p>Use this token to access the HTTP API: <code>22222222:APITOKEN</code></p> <p>For a description of the Bot API, see this page: https://core.telegram.org/bots/api Father bot will return you the token (API key)</p> <p>Copy the API Token (<code>22222222:APITOKEN</code> in the above example) and keep use it for the config parameter <code>token</code>.</p> <p>Don't forget to start the conversation with your bot, by clicking <code>/START</code> button</p>"},{"location":"telegram-usage/#2-telegram-user_id","title":"2. Telegram user_id","text":""},{"location":"telegram-usage/#get-your-user-id","title":"Get your user id","text":"<p>Talk to the userinfobot</p> <p>Get your \"Id\", you will use it for the config parameter <code>chat_id</code>.</p>"},{"location":"telegram-usage/#use-group-id","title":"Use Group id","text":"<p>You can use bots in telegram groups by just adding them to the group. You can find the group id by first adding a RawDataBot to your group. The Group id is shown as id in the <code>\"chat\"</code> section, which the RawDataBot will send to you:</p> <pre><code>\"chat\":{\n   \"id\":-1001332619709\n}\n</code></pre> <p>For the Freqtrade configuration, you can then use the full value (including <code>-</code> if it's there) as string:</p> <pre><code>   \"chat_id\": \"-1001332619709\"\n</code></pre> <p>Using telegram groups</p> <p>When using telegram groups, you're giving every member of the telegram group access to your freqtrade bot and to all commands possible via telegram. Please make sure that you can trust everyone in the telegram group to avoid unpleasant surprises.</p>"},{"location":"telegram-usage/#control-telegram-noise","title":"Control telegram noise","text":"<p>Freqtrade provides means to control the verbosity of your telegram bot. Each setting has the following possible values:</p> <ul> <li><code>on</code> - Messages will be sent, and user will be notified.</li> <li><code>silent</code> - Message will be sent, Notification will be without sound / vibration.</li> <li><code>off</code> - Skip sending a message-type all together.</li> </ul> <p>Example configuration showing the different settings:</p> <pre><code>\"telegram\": {\n    \"enabled\": true,\n    \"token\": \"your_telegram_token\",\n    \"chat_id\": \"your_telegram_chat_id\",\n    \"allow_custom_messages\": true,\n    \"notification_settings\": {\n        \"status\": \"silent\",\n        \"warning\": \"on\",\n        \"startup\": \"off\",\n        \"entry\": \"silent\",\n        \"entry_fill\": \"on\",\n        \"entry_cancel\": \"silent\",\n        \"exit\": {\n            \"roi\": \"silent\",\n            \"emergency_exit\": \"on\",\n            \"force_exit\": \"on\",\n            \"exit_signal\": \"silent\",\n            \"trailing_stop_loss\": \"on\",\n            \"stop_loss\": \"on\",\n            \"stoploss_on_exchange\": \"on\",\n            \"custom_exit\": \"silent\",\n            \"partial_exit\": \"on\"\n        },\n        \"exit_cancel\": \"on\",\n        \"exit_fill\": \"off\",\n        \"protection_trigger\": \"off\",\n        \"protection_trigger_global\": \"on\",\n        \"strategy_msg\": \"off\",\n        \"show_candle\": \"off\"\n    },\n    \"reload\": true,\n    \"balance_dust_level\": 0.01\n},\n</code></pre> <p><code>entry</code> notifications are sent when the order is placed, while <code>entry_fill</code> notifications are sent when the order is filled on the exchange. <code>exit</code> notifications are sent when the order is placed, while <code>exit_fill</code> notifications are sent when the order is filled on the exchange. <code>*_fill</code> notifications are off by default and must be explicitly enabled. <code>protection_trigger</code> notifications are sent when a protection triggers and <code>protection_trigger_global</code> notifications trigger when global protections are triggered. <code>strategy_msg</code> - Receive notifications from the strategy, sent via <code>self.dp.send_msg()</code> from the strategy more details. <code>show_candle</code> - show candle values as part of entry/exit messages. Only possible values are <code>\"ohlc\"</code> or <code>\"off\"</code>.</p> <p><code>balance_dust_level</code> will define what the <code>/balance</code> command takes as \"dust\" - Currencies with a balance below this will be shown. <code>allow_custom_messages</code> completely disable strategy messages. <code>reload</code> allows you to disable reload-buttons on selected messages.</p>"},{"location":"telegram-usage/#create-a-custom-keyboard-command-shortcut-buttons","title":"Create a custom keyboard (command shortcut buttons)","text":"<p>Telegram allows us to create a custom keyboard with buttons for commands. The default custom keyboard looks like this.</p> <pre><code>[\n    [\"/daily\", \"/profit\", \"/balance\"], # row 1, 3 commands\n    [\"/status\", \"/status table\", \"/performance\"], # row 2, 3 commands\n    [\"/count\", \"/start\", \"/stop\", \"/help\"] # row 3, 4 commands\n]\n</code></pre>"},{"location":"telegram-usage/#usage","title":"Usage","text":"<p>You can create your own keyboard in <code>config.json</code>:</p> <pre><code>\"telegram\": {\n      \"enabled\": true,\n      \"token\": \"your_telegram_token\",\n      \"chat_id\": \"your_telegram_chat_id\",\n      \"keyboard\": [\n          [\"/daily\", \"/stats\", \"/balance\", \"/profit\"],\n          [\"/status table\", \"/performance\"],\n          [\"/reload_config\", \"/count\", \"/logs\"]\n      ]\n   },\n</code></pre> <p>Supported Commands</p> <p>Only the following commands are allowed. Command arguments are not supported!</p> <p><code>/start</code>, <code>/stop</code>, <code>/status</code>, <code>/status table</code>, <code>/trades</code>, <code>/profit</code>, <code>/performance</code>, <code>/daily</code>, <code>/stats</code>, <code>/count</code>, <code>/locks</code>, <code>/balance</code>, <code>/stopentry</code>, <code>/reload_config</code>, <code>/show_config</code>, <code>/logs</code>, <code>/whitelist</code>, <code>/blacklist</code>, <code>/edge</code>, <code>/help</code>, <code>/version</code>, <code>/marketdir</code></p>"},{"location":"telegram-usage/#telegram-commands","title":"Telegram commands","text":"<p>Per default, the Telegram bot shows predefined commands. Some commands are only available by sending them to the bot. The table below list the official commands. You can ask at any moment for help with <code>/help</code>.</p> Command Description System commands <code>/start</code> Starts the trader <code>/stop</code> Stops the trader <code>/stopbuy | /stopentry</code> Stops the trader from opening new trades. Gracefully closes open trades according to their rules. <code>/reload_config</code> Reloads the configuration file <code>/show_config</code> Shows part of the current configuration with relevant settings to operation <code>/logs [limit]</code> Show last log messages. <code>/help</code> Show help message <code>/version</code> Show version Status <code>/status</code> Lists all open trades <code>/status &lt;trade_id&gt;</code> Lists one or more specific trade. Separate multiple  with a blank space. <code>/status table</code> List all open trades in a table format. Pending buy orders are marked with an asterisk () Pending sell orders are marked with a double asterisk (*) <code>/order &lt;trade_id&gt;</code> Lists orders of one or more specific trade. Separate multiple  with a blank space. <code>/trades [limit]</code> List all recently closed trades in a table format. <code>/count</code> Displays number of trades used and available <code>/locks</code> Show currently locked pairs. <code>/unlock &lt;pair or lock_id&gt;</code> Remove the lock for this pair (or for this lock id). <code>/marketdir [long | short | even | none]</code> Updates the user managed variable that represents the current market direction. If no direction is provided, the currently set direction will be displayed. <code>/list_custom_data &lt;trade_id&gt; [key]</code> List custom_data for Trade ID &amp; Key combination. If no Key is supplied it will list all key-value pairs found for that Trade ID. Modify Trade states <code>/forceexit &lt;trade_id&gt; | /fx &lt;tradeid&gt;</code> Instantly exits the given trade  (Ignoring <code>minimum_roi</code>). <code>/forceexit all | /fx all</code> Instantly exits all open trades (Ignoring <code>minimum_roi</code>). <code>/fx</code> alias for <code>/forceexit</code> <code>/forcelong &lt;pair&gt; [rate]</code> Instantly buys the given pair. Rate is optional and only applies to limit orders. (<code>force_entry_enable</code> must be set to True) <code>/forceshort &lt;pair&gt; [rate]</code> Instantly shorts the given pair. Rate is optional and only applies to limit orders. This will only work on non-spot markets. (<code>force_entry_enable</code> must be set to True) <code>/delete &lt;trade_id&gt;</code> Delete a specific trade from the Database. Tries to close open orders. Requires manual handling of this trade on the exchange. <code>/reload_trade &lt;trade_id&gt;</code> Reload a trade from the Exchange. Only works in live, and can potentially help recover a trade that was manually sold on the exchange. <code>/cancel_open_order &lt;trade_id&gt; | /coo &lt;trade_id&gt;</code> Cancel an open order for a trade. Metrics <code>/profit [&lt;n&gt;]</code> Display a summary of your profit/loss from close trades and some stats about your performance, over the last n days (all trades by default) <code>/performance</code> Show performance of each finished trade grouped by pair <code>/balance</code> Show bot managed balance per currency <code>/balance full</code> Show account balance per currency <code>/daily &lt;n&gt;</code> Shows profit or loss per day, over the last n days (n defaults to 7) <code>/weekly &lt;n&gt;</code> Shows profit or loss per week, over the last n weeks (n defaults to 8) <code>/monthly &lt;n&gt;</code> Shows profit or loss per month, over the last n months (n defaults to 6) <code>/stats</code> Shows Wins / losses by Exit reason as well as Avg. holding durations for buys and sells <code>/exits</code> Shows Wins / losses by Exit reason as well as Avg. holding durations for buys and sells <code>/entries</code> Shows Wins / losses by Exit reason as well as Avg. holding durations for buys and sells <code>/whitelist [sorted] [baseonly]</code> Show the current whitelist. Optionally display in alphabetical order and/or with just the base currency of each pairing. <code>/blacklist [pair]</code> Show the current blacklist, or adds a pair to the blacklist. <code>/edge</code> Show validated pairs by Edge if it is enabled."},{"location":"telegram-usage/#telegram-commands-in-action","title":"Telegram commands in action","text":"<p>Below, example of Telegram message you will receive for each command.</p>"},{"location":"telegram-usage/#start","title":"/start","text":"<p>Status: <code>running</code></p>"},{"location":"telegram-usage/#stop","title":"/stop","text":"<p><code>Stopping trader ...</code> Status: <code>stopped</code></p>"},{"location":"telegram-usage/#stopbuy","title":"/stopbuy","text":"<p>status: <code>Setting max_open_trades to 0. Run /reload_config to reset.</code></p> <p>Prevents the bot from opening new trades by temporarily setting \"max_open_trades\" to 0. Open trades will be handled via their regular rules (ROI / Sell-signal, stoploss, ...).</p> <p>After this, give the bot time to close off open trades (can be checked via <code>/status table</code>). Once all positions are sold, run <code>/stop</code> to completely stop the bot.</p> <p><code>/reload_config</code> resets \"max_open_trades\" to the value set in the configuration and resets this command.</p> <p>Warning</p> <p>The stop-buy signal is ONLY active while the bot is running, and is not persisted anyway, so restarting the bot will cause this to reset.</p>"},{"location":"telegram-usage/#status","title":"/status","text":"<p>For each open trade, the bot will send you the following message. Enter Tag is configurable via Strategy.</p> <p>Trade ID: <code>123</code> <code>(since 1 days ago)</code> Current Pair: CVC/BTC Direction: Long Leverage: 1.0 Amount: <code>26.64180098</code> Enter Tag: Awesome Long Signal Open Rate: <code>0.00007489</code> Current Rate: <code>0.00007489</code> Unrealized Profit: <code>12.95%</code> Stoploss: <code>0.00007389 (-0.02%)</code></p>"},{"location":"telegram-usage/#status-table","title":"/status table","text":"<p>Return the status of all open trades in a table format.</p> <pre><code>ID L/S    Pair     Since   Profit\n----    --------  -------  --------\n  67 L   SC/BTC    1 d      13.33%\n 123 S   CVC/BTC   1 h      12.95%\n</code></pre>"},{"location":"telegram-usage/#count","title":"/count","text":"<p>Return the number of trades used and available.</p> <pre><code>current    max\n---------  -----\n     2     10\n</code></pre>"},{"location":"telegram-usage/#profit","title":"/profit","text":"<p>Return a summary of your profit/loss and performance.</p> <p>ROI: Close trades   \u2219 <code>0.00485701 BTC (2.2%) (15.2 \u03a3%)</code>   \u2219 <code>62.968 USD</code> ROI: All trades   \u2219 <code>0.00255280 BTC (1.5%) (6.43 \u03a3%)</code>   \u2219 <code>33.095 EUR</code></p> <p>Total Trade Count: <code>138</code> Bot started: <code>2022-07-11 18:40:44</code> First Trade opened: <code>3 days ago</code> Latest Trade opened: <code>2 minutes ago</code> Avg. Duration: <code>2:33:45</code> Best Performing: <code>PAY/BTC: 50.23%</code> Trading volume: <code>0.5 BTC</code> Profit factor: <code>1.04</code> Win / Loss: <code>102 / 36</code> Winrate: <code>73.91%</code> Expectancy (Ratio): <code>4.87 (1.66)</code> Max Drawdown: <code>9.23% (0.01255 BTC)</code></p> <p>The relative profit of <code>1.2%</code> is the average profit per trade. The relative profit of <code>15.2 \u03a3%</code> is be based on the starting capital - so in this case, the starting capital was <code>0.00485701 * 1.152 = 0.00738 BTC</code>. Starting capital is either taken from the <code>available_capital</code> setting, or calculated by using current wallet size - profits. Profit Factor is calculated as gross profits / gross losses - and should serve as an overall metric for the strategy. Expectancy corresponds to the average return per currency unit at risk, i.e. the winrate and the risk-reward ratio (the average gain of winning trades compared to the average loss of losing trades). Expectancy Ratio is expected profit or loss of a subsequent trade based on the performance of all past trades. Max drawdown corresponds to the backtesting metric <code>Absolute Drawdown (Account)</code> - calculated as <code>(Absolute Drawdown) / (DrawdownHigh + startingBalance)</code>. Bot started date will refer to the date the bot was first started. For older bots, this will default to the first trade's open date.</p>"},{"location":"telegram-usage/#forceexit","title":"/forceexit   <p>BINANCE: Exiting BTC/LTC with limit <code>0.01650000 (profit: ~-4.07%, -0.00008168)</code></p>   <p>Tip</p> <p>You can get a list of all open trades by calling <code>/forceexit</code> without parameter, which will show a list of buttons to simply exit a trade. This command has an alias in <code>/fx</code> - which has the same capabilities, but is faster to type in \"emergency\" situations.</p>","text":""},{"location":"telegram-usage/#forcelong-rate-forceshort-rate","title":"/forcelong  [rate] | /forceshort  [rate] <p><code>/forcebuy &lt;pair&gt; [rate]</code> is also supported for longs but should be considered deprecated.</p>  <p>BINANCE: Long ETH/BTC with limit <code>0.03400000</code> (<code>1.000000 ETH</code>, <code>225.290 USD</code>)</p>  <p>Omitting the pair will open a query asking for the pair to trade (based on the current whitelist). Trades created through <code>/forcelong</code> will have the buy-tag of <code>force_entry</code>.</p> <p></p> <p>Note that for this to work, <code>force_entry_enable</code> needs to be set to true.</p> <p>More details</p>","text":""},{"location":"telegram-usage/#performance","title":"/performance <p>Return the performance of each crypto-currency the bot has sold.</p>  <p>Performance: 1. <code>RCN/BTC 0.003 BTC (57.77%) (1)</code> 2. <code>PAY/BTC 0.0012 BTC (56.91%) (1)</code> 3. <code>VIB/BTC 0.0011 BTC (47.07%) (1)</code> 4. <code>SALT/BTC 0.0010 BTC (30.24%) (1)</code> 5. <code>STORJ/BTC 0.0009 BTC (27.24%) (1)</code> ...</p>","text":""},{"location":"telegram-usage/#balance","title":"/balance <p>Return the balance of all crypto-currency your have on the exchange.</p>  <p>Currency: BTC Available: 3.05890234 Balance: 3.05890234 Pending: 0.0</p> <p>Currency: CVC Available: 86.64180098 Balance: 86.64180098 Pending: 0.0</p>","text":""},{"location":"telegram-usage/#daily","title":"/daily  <p>Per default <code>/daily</code> will return the 7 last days. The example below if for <code>/daily 3</code>:</p>  <p>Daily Profit over the last 3 days: <pre><code>Day (count)     USDT          USD         Profit %\n--------------  ------------  ----------  ----------\n2022-06-11 (1)  -0.746 USDT   -0.75 USD   -0.08%\n2022-06-10 (0)  0 USDT        0.00 USD    0.00%\n2022-06-09 (5)  20 USDT       20.10 USD   5.00%\n</code></pre></p>","text":""},{"location":"telegram-usage/#weekly","title":"/weekly  <p>Per default <code>/weekly</code> will return the 8 last weeks, including the current week. Each week starts from Monday. The example below if for <code>/weekly 3</code>:</p>  <p>Weekly Profit over the last 3 weeks (starting from Monday): <pre><code>Monday (count)  Profit BTC      Profit USD   Profit %\n-------------  --------------  ------------    ----------\n2018-01-03 (5)  0.00224175 BTC  29,142 USD   4.98%\n2017-12-27 (1)  0.00033131 BTC   4,307 USD   0.00%\n2017-12-20 (4)  0.00269130 BTC  34.986 USD   5.12%\n</code></pre></p>","text":""},{"location":"telegram-usage/#monthly","title":"/monthly  <p>Per default <code>/monthly</code> will return the 6 last months, including the current month. The example below if for <code>/monthly 3</code>:</p>  <p>Monthly Profit over the last 3 months: <pre><code>Month (count)  Profit BTC      Profit USD    Profit %\n-------------  --------------  ------------    ----------\n2018-01 (20)    0.00224175 BTC  29,142 USD  4.98%\n2017-12 (5)    0.00033131 BTC   4,307 USD   0.00%\n2017-11 (10)    0.00269130 BTC  34.986 USD  5.10%\n</code></pre></p>","text":""},{"location":"telegram-usage/#whitelist","title":"/whitelist <p>Shows the current whitelist</p>  <p>Using whitelist <code>StaticPairList</code> with 22 pairs <code>IOTA/BTC, NEO/BTC, TRX/BTC, VET/BTC, ADA/BTC, ETC/BTC, NCASH/BTC, DASH/BTC, XRP/BTC, XVG/BTC, EOS/BTC, LTC/BTC, OMG/BTC, BTG/BTC, LSK/BTC, ZEC/BTC, HOT/BTC, IOTX/BTC, XMR/BTC, AST/BTC, XLM/BTC, NANO/BTC</code></p>","text":""},{"location":"telegram-usage/#blacklist-pair","title":"/blacklist [pair] <p>Shows the current blacklist. If Pair is set, then this pair will be added to the pairlist. Also supports multiple pairs, separated by a space. Use <code>/reload_config</code> to reset the blacklist.</p>  <p>Using blacklist <code>StaticPairList</code> with 2 pairs <code>DODGE/BTC</code>, <code>HOT/BTC</code>.</p>","text":""},{"location":"telegram-usage/#edge","title":"/edge <p>Shows pairs validated by Edge along with their corresponding win-rate, expectancy and stoploss values.</p>  <p>Edge only validated following pairs: <pre><code>Pair        Winrate    Expectancy    Stoploss\n--------  ---------  ------------  ----------\nDOCK/ETH   0.522727      0.881821       -0.03\nPHX/ETH    0.677419      0.560488       -0.03\nHOT/ETH    0.733333      0.490492       -0.03\nHC/ETH     0.588235      0.280988       -0.02\nARDR/ETH   0.366667      0.143059       -0.01\n</code></pre></p>","text":""},{"location":"telegram-usage/#version","title":"/version  <p>Version: <code>0.14.3</code></p>","text":""},{"location":"telegram-usage/#marketdir","title":"/marketdir <p>If a market direction is provided the command updates the user managed variable that represents the current market direction. This variable is not set to any valid market direction on bot startup and must be set by the user. The example below is for <code>/marketdir long</code>:</p> <pre><code>Successfully updated marketdirection from none to long.\n</code></pre> <p>If no market direction is provided the command outputs the currently set market directions. The example below is for <code>/marketdir</code>:</p> <pre><code>Currently set marketdirection: even\n</code></pre> <p>You can use the market direction in your strategy via <code>self.market_direction</code>.</p>  <p>Bot restarts</p> <p>Please note that the market direction is not persisted, and will be reset after a bot restart/reload.</p>   <p>Backtesting</p> <p>As this value/variable is intended to be changed manually in dry/live trading. Strategies using <code>market_direction</code> will probably not produce reliable, reproducible results (changes to this variable will not be reflected for backtesting). Use at your own risk.</p>","text":""},{"location":"trade-object/","title":"Trade Object","text":""},{"location":"trade-object/#trade","title":"Trade","text":"<p>A position freqtrade enters is stored in a <code>Trade</code> object - which is persisted to the database. It's a core concept of freqtrade - and something you'll come across in many sections of the documentation, which will most likely point you to this location.</p> <p>It will be passed to the strategy in many strategy callbacks. The object passed to the strategy cannot be modified directly. Indirect modifications may occur based on callback results.</p>"},{"location":"trade-object/#trade-available-attributes","title":"Trade - Available attributes","text":"<p>The following attributes / properties are available for each individual trade - and can be used with <code>trade.&lt;property&gt;</code> (e.g. <code>trade.pair</code>).</p> Attribute DataType Description <code>pair</code> string Pair of this trade. <code>is_open</code> boolean Is the trade currently open, or has it been concluded. <code>open_rate</code> float Rate this trade was entered at (Avg. entry rate in case of trade-adjustments). <code>close_rate</code> float Close rate - only set when is_open = False. <code>stake_amount</code> float Amount in Stake (or Quote) currency. <code>amount</code> float Amount in Asset / Base currency that is currently owned. <code>open_date</code> datetime Timestamp when trade was opened use <code>open_date_utc</code> instead <code>open_date_utc</code> datetime Timestamp when trade was opened - in UTC. <code>close_date</code> datetime Timestamp when trade was closed use <code>close_date_utc</code> instead <code>close_date_utc</code> datetime Timestamp when trade was closed - in UTC. <code>close_profit</code> float Relative profit at the time of trade closure. <code>0.01</code> == 1% <code>close_profit_abs</code> float Absolute profit (in stake currency) at the time of trade closure. <code>leverage</code> float Leverage used for this trade - defaults to 1.0 in spot markets. <code>enter_tag</code> string Tag provided on entry via the <code>enter_tag</code> column in the dataframe. <code>is_short</code> boolean True for short trades, False otherwise. <code>orders</code> Order[] List of order objects attached to this trade (includes both filled and cancelled orders). <code>date_last_filled_utc</code> datetime Time of the last filled order. <code>entry_side</code> \"buy\" / \"sell\" Order Side the trade was entered. <code>exit_side</code> \"buy\" / \"sell\" Order Side that will result in a trade exit / position reduction. <code>trade_direction</code> \"long\" / \"short\" Trade direction in text - long or short. <code>nr_of_successful_entries</code> int Number of successful (filled) entry orders. <code>nr_of_successful_exits</code> int Number of successful (filled) exit orders."},{"location":"trade-object/#class-methods","title":"Class methods","text":"<p>The following are class methods - which return generic information, and usually result in an explicit query against the database. They can be used as <code>Trade.&lt;method&gt;</code> - e.g. <code>open_trades = Trade.get_open_trade_count()</code></p> <p>Backtesting/hyperopt</p> <p>Most methods will work in both backtesting / hyperopt and live/dry modes. During backtesting, it's limited to usage in strategy callbacks. Usage in <code>populate_*()</code> methods is not supported and will result in wrong results.</p>"},{"location":"trade-object/#get_trades_proxy","title":"get_trades_proxy","text":"<p>When your strategy needs some information on existing (open or close) trades - it's best to use <code>Trade.get_trades_proxy()</code>.</p> <p>Usage:</p> <pre><code>from freqtrade.persistence import Trade\nfrom datetime import timedelta\n\n# ...\ntrade_hist = Trade.get_trades_proxy(pair='ETH/USDT', is_open=False, open_date=current_date - timedelta(days=2))\n</code></pre> <p><code>get_trades_proxy()</code> supports the following keyword arguments. All arguments are optional - calling <code>get_trades_proxy()</code> without arguments will return a list of all trades in the database.</p> <ul> <li><code>pair</code> e.g. <code>pair='ETH/USDT'</code></li> <li><code>is_open</code> e.g. <code>is_open=False</code></li> <li><code>open_date</code> e.g. <code>open_date=current_date - timedelta(days=2)</code></li> <li><code>close_date</code> e.g. <code>close_date=current_date - timedelta(days=5)</code></li> </ul>"},{"location":"trade-object/#get_open_trade_count","title":"get_open_trade_count","text":"<p>Get the number of currently open trades</p> <pre><code>from freqtrade.persistence import Trade\n# ...\nopen_trades = Trade.get_open_trade_count()\n</code></pre>"},{"location":"trade-object/#get_total_closed_profit","title":"get_total_closed_profit","text":"<p>Retrieve the total profit the bot has generated so far. Aggregates <code>close_profit_abs</code> for all closed trades.</p> <pre><code>from freqtrade.persistence import Trade\n\n# ...\nprofit = Trade.get_total_closed_profit()\n</code></pre>"},{"location":"trade-object/#total_open_trades_stakes","title":"total_open_trades_stakes","text":"<p>Retrieve the total stake_amount that's currently in trades.</p> <pre><code>from freqtrade.persistence import Trade\n\n# ...\nprofit = Trade.total_open_trades_stakes()\n</code></pre>"},{"location":"trade-object/#get_overall_performance","title":"get_overall_performance","text":"<p>Retrieve the overall performance - similar to the <code>/performance</code> telegram command.</p> <pre><code>from freqtrade.persistence import Trade\n\n# ...\nif self.config['runmode'].value in ('live', 'dry_run'):\n    performance = Trade.get_overall_performance()\n</code></pre> <p>Sample return value: ETH/BTC had 5 trades, with a total profit of 1.5% (ratio of 0.015).</p> <pre><code>{\"pair\": \"ETH/BTC\", \"profit\": 0.015, \"count\": 5}\n</code></pre>"},{"location":"trade-object/#order-object","title":"Order Object","text":"<p>An <code>Order</code> object represents an order on the exchange (or a simulated order in dry-run mode). An <code>Order</code> object will always be tied to it's corresponding <code>Trade</code>, and only really makes sense in the context of a trade.</p>"},{"location":"trade-object/#order-available-attributes","title":"Order - Available attributes","text":"<p>an Order object is typically attached to a trade. Most properties here can be None as they are dependent on the exchange response.</p> Attribute DataType Description <code>trade</code> Trade Trade object this order is attached to <code>ft_pair</code> string Pair this order is for <code>ft_is_open</code> boolean is the order filled? <code>order_type</code> string Order type as defined on the exchange - usually market, limit or stoploss <code>status</code> string Status as defined by ccxt. Usually open, closed, expired or canceled <code>side</code> string Buy or Sell <code>price</code> float Price the order was placed at <code>average</code> float Average price the order filled at <code>amount</code> float Amount in base currency <code>filled</code> float Filled amount (in base currency) <code>remaining</code> float Remaining amount <code>cost</code> float Cost of the order - usually average * filled (Exchange dependent on futures, may contain the cost with or without leverage and may be in contracts.) <code>stake_amount</code> float Stake amount used for this order. Added in 2023.7. <code>order_date</code> datetime Order creation date use <code>order_date_utc</code> instead <code>order_date_utc</code> datetime Order creation date (in UTC) <code>order_fill_date</code> datetime Order fill date use <code>order_fill_utc</code> instead <code>order_fill_date_utc</code> datetime Order fill date"},{"location":"updating/","title":"How to update","text":"<p>To update your freqtrade installation, please use one of the below methods, corresponding to your installation method.</p> <p>Tracking changes</p> <p>Breaking changes / changed behavior will be documented in the changelog that is posted alongside every release. For the develop branch, please follow PR's to avoid being surprised by changes.</p>"},{"location":"updating/#docker","title":"Docker","text":"<p>Legacy installations using the <code>master</code> image</p> <p>We're switching from master to stable for the release Images - please adjust your docker-file and replace <code>freqtradeorg/freqtrade:master</code> with <code>freqtradeorg/freqtrade:stable</code></p> <pre><code>docker compose pull\ndocker compose up -d\n</code></pre>"},{"location":"updating/#installation-via-setup-script","title":"Installation via setup script","text":"<pre><code>./setup.sh --update\n</code></pre> <p>Note</p> <p>Make sure to run this command with your virtual environment disabled!</p>"},{"location":"updating/#plain-native-installation","title":"Plain native installation","text":"<p>Please ensure that you're also updating dependencies - otherwise things might break without you noticing.</p> <pre><code>git pull\npip install -U -r requirements.txt\npip install -e .\n\n# Ensure freqUI is at the latest version\nfreqtrade install-ui \n</code></pre>"},{"location":"updating/#problems-updating","title":"Problems updating","text":"<p>Update-problems usually come missing dependencies (you didn't follow the above instructions) - or from updated dependencies, which fail to install (for example TA-lib). Please refer to the corresponding installation sections (common problems linked below)</p> <p>Common problems and their solutions:</p> <ul> <li>ta-lib update on windows</li> </ul>"},{"location":"utils/","title":"Utility Subcommands","text":"<p>Besides the Live-Trade and Dry-Run run modes, the <code>backtesting</code>, <code>edge</code> and <code>hyperopt</code> optimization subcommands, and the <code>download-data</code> subcommand which prepares historical data, the bot contains a number of utility subcommands. They are described in this section.</p>"},{"location":"utils/#create-userdir","title":"Create userdir","text":"<p>Creates the directory structure to hold your files for freqtrade. Will also create strategy and hyperopt examples for you to get started. Can be used multiple times - using <code>--reset</code> will reset the sample strategy and hyperopt files to their default state. </p> <pre><code>usage: freqtrade create-userdir [-h] [--userdir PATH] [--reset]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n  --reset               Reset sample files to their original state.\n</code></pre> <p>Warning</p> <p>Using <code>--reset</code> may result in loss of data, since this will overwrite all sample files without asking again.</p> <pre><code>\u251c\u2500\u2500 backtest_results\n\u251c\u2500\u2500 data\n\u251c\u2500\u2500 hyperopt_results\n\u251c\u2500\u2500 hyperopts\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 sample_hyperopt_loss.py\n\u251c\u2500\u2500 notebooks\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 strategy_analysis_example.ipynb\n\u251c\u2500\u2500 plot\n\u2514\u2500\u2500 strategies\n    \u2514\u2500\u2500 sample_strategy.py\n</code></pre>"},{"location":"utils/#create-new-config","title":"Create new config","text":"<p>Creates a new configuration file, asking some questions which are important selections for a configuration.</p> <pre><code>usage: freqtrade new-config [-h] [-c PATH]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default: `config.json`). Multiple --config options may be used. Can be set to `-`\n                        to read config from stdin.\n</code></pre> <p>Warning</p> <p>Only vital questions are asked. Freqtrade offers a lot more configuration possibilities, which are listed in the Configuration documentation</p>"},{"location":"utils/#create-config-examples","title":"Create config examples","text":"<pre><code>$ freqtrade new-config --config user_data/config_binance.json\n\n? Do you want to enable Dry-run (simulated trades)?  Yes\n? Please insert your stake currency: BTC\n? Please insert your stake amount: 0.05\n? Please insert max_open_trades (Integer or -1 for unlimited open trades): 3\n? Please insert your desired timeframe (e.g. 5m): 5m\n? Please insert your display Currency (for reporting): USD\n? Select exchange  binance\n? Do you want to enable Telegram?  No\n</code></pre>"},{"location":"utils/#show-config","title":"Show config","text":"<p>Show configuration file (with sensitive values redacted by default). Especially useful with split configuration files or environment variables, where this command will show the merged configuration.</p> <p></p> <pre><code>usage: freqtrade show-config [-h] [--userdir PATH] [-c PATH]\n                             [--show-sensitive]\n\noptions:\n  -h, --help            show this help message and exit\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  --show-sensitive      Show secrets in the output.\n</code></pre> <pre><code>Your combined configuration is:\n{\n  \"exit_pricing\": {\n    \"price_side\": \"other\",\n    \"use_order_book\": true,\n    \"order_book_top\": 1\n  },\n  \"stake_currency\": \"USDT\",\n  \"exchange\": {\n    \"name\": \"binance\",\n    \"key\": \"REDACTED\",\n    \"secret\": \"REDACTED\",\n    \"ccxt_config\": {},\n    \"ccxt_async_config\": {},\n  }\n  // ...\n}\n</code></pre> <p>Sharing information provided by this command</p> <p>We try to remove all known sensitive information from the default output (without <code>--show-sensitive</code>).  Yet, please do double-check for sensitive values in your output to make sure you're not accidentally exposing some private info.</p>"},{"location":"utils/#create-new-strategy","title":"Create new strategy","text":"<p>Creates a new strategy from a template similar to SampleStrategy. The file will be named inline with your class name, and will not overwrite existing files.</p> <p>Results will be located in <code>user_data/strategies/&lt;strategyclassname&gt;.py</code>.</p> <pre><code>usage: freqtrade new-strategy [-h] [--userdir PATH] [-s NAME]\n                              [--template {full,minimal,advanced}]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n  -s NAME, --strategy NAME\n                        Specify strategy class name which will be used by the\n                        bot.\n  --template {full,minimal,advanced}\n                        Use a template which is either `minimal`, `full`\n                        (containing multiple sample indicators) or `advanced`.\n                        Default: `full`.\n</code></pre>"},{"location":"utils/#sample-usage-of-new-strategy","title":"Sample usage of new-strategy","text":"<pre><code>freqtrade new-strategy --strategy AwesomeStrategy\n</code></pre> <p>With custom user directory</p> <pre><code>freqtrade new-strategy --userdir ~/.freqtrade/ --strategy AwesomeStrategy\n</code></pre> <p>Using the advanced template (populates all optional functions and methods)</p> <pre><code>freqtrade new-strategy --strategy AwesomeStrategy --template advanced\n</code></pre>"},{"location":"utils/#list-strategies","title":"List Strategies","text":"<p>Use the <code>list-strategies</code> subcommand to see all strategies in one particular directory.</p> <p>This subcommand is useful for finding problems in your environment with loading strategies: modules with strategies that contain errors and failed to load are printed in red (LOAD FAILED), while strategies with duplicate names are printed in yellow (DUPLICATE NAME).</p> <pre><code>usage: freqtrade list-strategies [-h] [-v] [--logfile FILE] [-V] [-c PATH]\n                                 [-d PATH] [--userdir PATH]\n                                 [--strategy-path PATH] [-1] [--no-color]\n                                 [--recursive-strategy-search]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --strategy-path PATH  Specify additional strategy lookup path.\n  -1, --one-column      Print output in one column.\n  --no-color            Disable colorization of hyperopt results. May be\n                        useful if you are redirecting output to a file.\n  --recursive-strategy-search\n                        Recursively search for a strategy in the strategies\n                        folder.\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n</code></pre> <p>Warning</p> <p>Using these commands will try to load all python files from a directory. This can be a security risk if untrusted files reside in this directory, since all module-level code is executed.</p> <p>Example: Search default strategies directories (within the default userdir).</p> <pre><code>freqtrade list-strategies\n</code></pre> <p>Example: Search strategies  directory within the userdir.</p> <pre><code>freqtrade list-strategies --userdir ~/.freqtrade/\n</code></pre> <p>Example: Search dedicated strategy path.</p> <pre><code>freqtrade list-strategies --strategy-path ~/.freqtrade/strategies/\n</code></pre>"},{"location":"utils/#list-freqai-models","title":"List freqAI models","text":"<p>Use the <code>list-freqaimodels</code> subcommand to see all freqAI models available.</p> <p>This subcommand is useful for finding problems in your environment with loading freqAI models: modules with models that contain errors and failed to load are printed in red (LOAD FAILED), while models with duplicate names are printed in yellow (DUPLICATE NAME).</p> <pre><code>usage: freqtrade list-freqaimodels [-h] [-v] [--logfile FILE] [-V] [-c PATH]\n                                   [-d PATH] [--userdir PATH]\n                                   [--freqaimodel-path PATH] [-1] [--no-color]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --freqaimodel-path PATH\n                        Specify additional lookup path for freqaimodels.\n  -1, --one-column      Print output in one column.\n  --no-color            Disable colorization of hyperopt results. May be\n                        useful if you are redirecting output to a file.\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH, --data-dir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n</code></pre>"},{"location":"utils/#list-exchanges","title":"List Exchanges","text":"<p>Use the <code>list-exchanges</code> subcommand to see the exchanges available for the bot.</p> <pre><code>usage: freqtrade list-exchanges [-h] [-1] [-a]\n\noptional arguments:\n  -h, --help        show this help message and exit\n  -1, --one-column  Print output in one column.\n  -a, --all         Print all exchanges known to the ccxt library.\n</code></pre> <p>Example: see exchanges available for the bot:</p> <pre><code>$ freqtrade list-exchanges\nExchanges available for Freqtrade:\nExchange name       Supported    Markets                 Reason\n------------------  -----------  ----------------------  ------------------------------------------------------------------------\nbinance             Official     spot, isolated futures\nbitmart             Official     spot\nbybit                            spot, isolated futures\ngate                Official     spot, isolated futures\nhtx                 Official     spot\nhuobi                            spot\nkraken              Official     spot\nokx                 Official     spot, isolated futures\n</code></pre> <p>Output reduced for clarity - supported and available exchanges may change over time.</p> <p>missing opt exchanges</p> <p>Values with \"missing opt:\" might need special configuration (e.g. using orderbook if <code>fetchTickers</code> is missing) - but should in theory work (although we cannot guarantee they will).</p> <p>Example: see all exchanges supported by the ccxt library (including 'bad' ones, i.e. those that are known to not work with Freqtrade)</p> <pre><code>$ freqtrade list-exchanges -a\nAll exchanges supported by the ccxt library:\nExchange name       Valid    Supported    Markets                 Reason\n------------------  -------  -----------  ----------------------  ---------------------------------------------------------------------------------\nbinance             True     Official     spot, isolated futures\nbitflyer            False                 spot                    missing: fetchOrder. missing opt: fetchTickers.\nbitmart             True     Official     spot\nbybit               True                  spot, isolated futures\ngate                True     Official     spot, isolated futures\nhtx                 True     Official     spot\nkraken              True     Official     spot\nokx                 True     Official     spot, isolated futures\n</code></pre> <p>Reduced output - supported and available exchanges may change over time.</p>"},{"location":"utils/#list-timeframes","title":"List Timeframes","text":"<p>Use the <code>list-timeframes</code> subcommand to see the list of timeframes available for the exchange.</p> <pre><code>usage: freqtrade list-timeframes [-h] [-v] [--logfile FILE] [-V] [-c PATH]\n                                 [-d PATH] [--userdir PATH]\n                                 [--exchange EXCHANGE] [-1]\n\noptions:\n  -h, --help            show this help message and exit\n  --exchange EXCHANGE   Exchange name. Only valid if no config is provided.\n  -1, --one-column      Print output in one column.\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE, --log-file FILE\n                        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH, --data-dir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n</code></pre> <ul> <li>Example: see the timeframes for the 'binance' exchange, set in the configuration file:</li> </ul> <pre><code>$ freqtrade list-timeframes -c config_binance.json\n...\nTimeframes available for the exchange `binance`: 1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w, 1M\n</code></pre> <ul> <li>Example: enumerate exchanges available for Freqtrade and print timeframes supported by each of them: <pre><code>$ for i in `freqtrade list-exchanges -1`; do freqtrade list-timeframes --exchange $i; done\n</code></pre></li> </ul>"},{"location":"utils/#list-pairslist-markets","title":"List pairs/list markets","text":"<p>The <code>list-pairs</code> and <code>list-markets</code> subcommands allow to see the pairs/markets available on exchange.</p> <p>Pairs are markets with the '/' character between the base currency part and the quote currency part in the market symbol. For example, in the 'ETH/BTC' pair 'ETH' is the base currency, while 'BTC' is the quote currency.</p> <p>For pairs traded by Freqtrade the pair quote currency is defined by the value of the <code>stake_currency</code> configuration setting.</p> <p>You can print info about any pair/market with these subcommands - and you can filter output by quote-currency using <code>--quote BTC</code>, or by base-currency using <code>--base ETH</code> options correspondingly.</p> <p>These subcommands have same usage and same set of available options:</p> <pre><code>usage: freqtrade list-markets [-h] [-v] [--logfile FILE] [-V] [-c PATH]\n                              [-d PATH] [--userdir PATH] [--exchange EXCHANGE]\n                              [--print-list] [--print-json] [-1] [--print-csv]\n                              [--base BASE_CURRENCY [BASE_CURRENCY ...]]\n                              [--quote QUOTE_CURRENCY [QUOTE_CURRENCY ...]]\n                              [-a] [--trading-mode {spot,margin,futures}]\nusage: freqtrade list-pairs [-h] [-v] [--logfile FILE] [-V] [-c PATH]\n                            [-d PATH] [--userdir PATH] [--exchange EXCHANGE]\n                            [--print-list] [--print-json] [-1] [--print-csv]\n                            [--base BASE_CURRENCY [BASE_CURRENCY ...]]\n                            [--quote QUOTE_CURRENCY [QUOTE_CURRENCY ...]] [-a]\n                            [--trading-mode {spot,margin,futures}]\noptions:\n  -h, --help            show this help message and exit\n  --exchange EXCHANGE   Exchange name. Only valid if no config is provided.\n  --print-list          Print list of pairs or market symbols. By default data\n                        is printed in the tabular format.\n  --print-json          Print list of pairs or market symbols in JSON format.\n  -1, --one-column      Print output in one column.\n  --print-csv           Print exchange pair or market data in the csv format.\n  --base BASE_CURRENCY [BASE_CURRENCY ...]\n                        Specify base currency(-ies). Space-separated list.\n  --quote QUOTE_CURRENCY [QUOTE_CURRENCY ...]\n                        Specify quote currency(-ies). Space-separated list.\n  -a, --all             Print all pairs or market symbols. By default only\n                        active ones are shown.\n  --trading-mode {spot,margin,futures}, --tradingmode {spot,margin,futures}\n                        Select Trading mode\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE, --log-file FILE\n                        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH, --data-dir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n</code></pre> <p>By default, only active pairs/markets are shown. Active pairs/markets are those that can currently be traded on the exchange. The see the list of all pairs/markets (not only the active ones), use the <code>-a</code>/<code>-all</code> option.</p> <p>Pairs/markets are sorted by its symbol string in the printed output.</p>"},{"location":"utils/#examples","title":"Examples","text":"<ul> <li>Print the list of active pairs with quote currency USD on exchange, specified in the default configuration file (i.e. pairs on the \"Binance\" exchange) in JSON format:</li> </ul> <pre><code>$ freqtrade list-pairs --quote USD --print-json\n</code></pre> <ul> <li>Print the list of all pairs on the exchange, specified in the <code>config_binance.json</code> configuration file (i.e. on the \"Binance\" exchange) with base currencies BTC or ETH and quote currencies USDT or USD, as the human-readable list with summary:</li> </ul> <pre><code>$ freqtrade list-pairs -c config_binance.json --all --base BTC ETH --quote USDT USD --print-list\n</code></pre> <ul> <li>Print all markets on exchange \"Kraken\", in the tabular format:</li> </ul> <pre><code>$ freqtrade list-markets --exchange kraken --all\n</code></pre>"},{"location":"utils/#test-pairlist","title":"Test pairlist","text":"<p>Use the <code>test-pairlist</code> subcommand to test the configuration of dynamic pairlists.</p> <p>Requires a configuration with specified <code>pairlists</code> attribute. Can be used to generate static pairlists to be used during backtesting / hyperopt.</p> <pre><code>usage: freqtrade test-pairlist [-h] [--userdir PATH] [-v] [-c PATH]\n                               [--quote QUOTE_CURRENCY [QUOTE_CURRENCY ...]]\n                               [-1] [--print-json] [--exchange EXCHANGE]\n\noptions:\n  -h, --help            show this help message and exit\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  --quote QUOTE_CURRENCY [QUOTE_CURRENCY ...]\n                        Specify quote currency(-ies). Space-separated list.\n  -1, --one-column      Print output in one column.\n  --print-json          Print list of pairs or market symbols in JSON format.\n  --exchange EXCHANGE   Exchange name. Only valid if no config is provided.\n</code></pre>"},{"location":"utils/#examples_1","title":"Examples","text":"<p>Show whitelist when using a dynamic pairlist.</p> <pre><code>freqtrade test-pairlist --config config.json --quote USDT BTC\n</code></pre>"},{"location":"utils/#convert-database","title":"Convert database","text":"<p><code>freqtrade convert-db</code> can be used to convert your database from one system to another (sqlite -&gt; postgres, postgres -&gt; other postgres), migrating all trades, orders and Pairlocks.</p> <p>Please refer to the SQL cheatsheet to learn about requirements for different database systems.</p> <pre><code>usage: freqtrade convert-db [-h] [--db-url PATH] [--db-url-from PATH]\n\noptional arguments:\n  -h, --help          show this help message and exit\n  --db-url PATH       Override trades database URL, this is useful in custom\n                      deployments (default: `sqlite:///tradesv3.sqlite` for\n                      Live Run mode, `sqlite:///tradesv3.dryrun.sqlite` for\n                      Dry Run).\n  --db-url-from PATH  Source db url to use when migrating a database.\n</code></pre> <p>Warning</p> <p>Please ensure to only use this on an empty target database. Freqtrade will perform a regular migration, but may fail if entries already existed.</p>"},{"location":"utils/#webserver-mode","title":"Webserver mode","text":"<p>Experimental</p> <p>Webserver mode is an experimental mode to increase backesting and strategy development productivity. There may still be bugs - so if you happen to stumble across these, please report them as github issues, thanks.</p> <p>Run freqtrade in webserver mode. Freqtrade will start the webserver and allow FreqUI to start and control backtesting processes. This has the advantage that data will not be reloaded between backtesting runs (as long as timeframe and timerange remain identical). FreqUI will also show the backtesting results.</p> <pre><code>usage: freqtrade webserver [-h] [-v] [--logfile FILE] [-V] [-c PATH] [-d PATH]\n                           [--userdir PATH]\n\noptional arguments:\n  -h, --help            show this help message and exit\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n</code></pre>"},{"location":"utils/#webserver-mode-docker","title":"Webserver mode - docker","text":"<p>You can also use webserver mode via docker. Starting a one-off container requires the configuration of the port explicitly, as ports are not exposed by default. You can use <code>docker compose run --rm -p 127.0.0.1:8080:8080 freqtrade webserver</code> to start a one-off container that'll be removed once you stop it. This assumes that port 8080 is still available and no other bot is running on that port.</p> <p>Alternatively, you can reconfigure the docker-compose file to have the command updated:</p> <pre><code>    command: &gt;\n      webserver\n      --config /freqtrade/user_data/config.json\n</code></pre> <p>You can now use <code>docker compose up</code> to start the webserver. This assumes that the configuration has a webserver enabled and configured for docker (listening port = <code>0.0.0.0</code>).</p> <p>Tip</p> <p>Don't forget to reset the command back to the trade command if you want to start a live or dry-run bot. </p>"},{"location":"utils/#show-previous-backtest-results","title":"Show previous Backtest results","text":"<p>Allows you to show previous backtest results. Adding <code>--show-pair-list</code> outputs a sorted pair list you can easily copy/paste into your configuration (omitting bad pairs).</p> Strategy overfitting <p>Only using winning pairs can lead to an overfitted strategy, which will not work well on future data. Make sure to extensively test your strategy in dry-run before risking real money.</p> <pre><code>usage: freqtrade backtesting-show [-h] [-v] [--logfile FILE] [-V] [-c PATH]\n                                  [-d PATH] [--userdir PATH]\n                                  [--export-filename PATH] [--show-pair-list]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --export-filename PATH\n                        Save backtest results to the file with this filename.\n                        Requires `--export` to be set as well. Example:\n                        `--export-filename=user_data/backtest_results/backtest\n                        _today.json`\n  --show-pair-list      Show backtesting pairlist sorted by profit.\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n</code></pre>"},{"location":"utils/#detailed-backtest-analysis","title":"Detailed backtest analysis","text":"<p>Advanced backtest result analysis.</p> <p>More details in the Backtesting analysis Section.</p> <pre><code>usage: freqtrade backtesting-analysis [-h] [-v] [--logfile FILE] [-V]\n                                      [-c PATH] [-d PATH] [--userdir PATH]\n                                      [--export-filename PATH]\n                                      [--analysis-groups {0,1,2,3,4} [{0,1,2,3,4} ...]]\n                                      [--enter-reason-list ENTER_REASON_LIST [ENTER_REASON_LIST ...]]\n                                      [--exit-reason-list EXIT_REASON_LIST [EXIT_REASON_LIST ...]]\n                                      [--indicator-list INDICATOR_LIST [INDICATOR_LIST ...]]\n                                      [--timerange YYYYMMDD-[YYYYMMDD]]\n                                      [--rejected]\n                                      [--analysis-to-csv]\n                                      [--analysis-csv-path PATH]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --export-filename PATH, --backtest-filename PATH\n                        Use this filename for backtest results.Requires\n                        `--export` to be set as well. Example: `--export-filen\n                        ame=user_data/backtest_results/backtest_today.json`\n  --analysis-groups {0,1,2,3,4} [{0,1,2,3,4} ...]\n                        grouping output - 0: simple wins/losses by enter tag,\n                        1: by enter_tag, 2: by enter_tag and exit_tag, 3: by\n                        pair and enter_tag, 4: by pair, enter_ and exit_tag\n                        (this can get quite large)\n  --enter-reason-list ENTER_REASON_LIST [ENTER_REASON_LIST ...]\n                        Space separated list of entry signals to analyse.\n                        Default: all. e.g. 'entry_tag_a entry_tag_b'\n  --exit-reason-list EXIT_REASON_LIST [EXIT_REASON_LIST ...]\n                        Space separated list of exit signals to analyse.\n                        Default: all. e.g.\n                        'exit_tag_a roi stop_loss trailing_stop_loss'\n  --indicator-list INDICATOR_LIST [INDICATOR_LIST ...]\n                        Space separated list of indicators to analyse. e.g.\n                        'close rsi bb_lowerband profit_abs'\n  --timerange YYYYMMDD-[YYYYMMDD]\n                        Timerange to filter trades for analysis, \n                        start inclusive, end exclusive. e.g.\n                        20220101-20220201\n  --rejected\n                        Print out rejected trades table\n  --analysis-to-csv\n                        Write out tables to individual CSVs, by default to \n                        'user_data/backtest_results' unless '--analysis-csv-path' is given.\n  --analysis-csv-path [PATH]\n                        Optional path where individual CSVs will be written. If not used,\n                        CSVs will be written to 'user_data/backtest_results'.\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n</code></pre>"},{"location":"utils/#list-hyperopt-results","title":"List Hyperopt results","text":"<p>You can list the hyperoptimization epochs the Hyperopt module evaluated previously with the <code>hyperopt-list</code> sub-command.</p> <pre><code>usage: freqtrade hyperopt-list [-h] [-v] [--logfile FILE] [-V] [-c PATH]\n                               [-d PATH] [--userdir PATH] [--best]\n                               [--profitable] [--min-trades INT]\n                               [--max-trades INT] [--min-avg-time FLOAT]\n                               [--max-avg-time FLOAT] [--min-avg-profit FLOAT]\n                               [--max-avg-profit FLOAT]\n                               [--min-total-profit FLOAT]\n                               [--max-total-profit FLOAT]\n                               [--min-objective FLOAT] [--max-objective FLOAT]\n                               [--no-color] [--print-json] [--no-details]\n                               [--hyperopt-filename PATH] [--export-csv FILE]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --best                Select only best epochs.\n  --profitable          Select only profitable epochs.\n  --min-trades INT      Select epochs with more than INT trades.\n  --max-trades INT      Select epochs with less than INT trades.\n  --min-avg-time FLOAT  Select epochs above average time.\n  --max-avg-time FLOAT  Select epochs below average time.\n  --min-avg-profit FLOAT\n                        Select epochs above average profit.\n  --max-avg-profit FLOAT\n                        Select epochs below average profit.\n  --min-total-profit FLOAT\n                        Select epochs above total profit.\n  --max-total-profit FLOAT\n                        Select epochs below total profit.\n  --min-objective FLOAT\n                        Select epochs above objective.\n  --max-objective FLOAT\n                        Select epochs below objective.\n  --no-color            Disable colorization of hyperopt results. May be\n                        useful if you are redirecting output to a file.\n  --print-json          Print output in JSON format.\n  --no-details          Do not print best epoch details.\n  --hyperopt-filename FILENAME\n                        Hyperopt result filename.Example: `--hyperopt-\n                        filename=hyperopt_results_2020-09-27_16-20-48.pickle`\n  --export-csv FILE     Export to CSV-File. This will disable table print.\n                        Example: --export-csv hyperopt.csv\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n</code></pre> <p>Note</p> <p><code>hyperopt-list</code> will automatically use the latest available hyperopt results file. You can override this using the <code>--hyperopt-filename</code> argument, and specify another, available filename (without path!).</p>"},{"location":"utils/#examples_2","title":"Examples","text":"<p>List all results, print details of the best result at the end: <pre><code>freqtrade hyperopt-list\n</code></pre></p> <p>List only epochs with positive profit. Do not print the details of the best epoch, so that the list can be iterated in a script: <pre><code>freqtrade hyperopt-list --profitable --no-details\n</code></pre></p>"},{"location":"utils/#show-details-of-hyperopt-results","title":"Show details of Hyperopt results","text":"<p>You can show the details of any hyperoptimization epoch previously evaluated by the Hyperopt module with the <code>hyperopt-show</code> subcommand.</p> <pre><code>usage: freqtrade hyperopt-show [-h] [-v] [--logfile FILE] [-V] [-c PATH]\n                               [-d PATH] [--userdir PATH] [--best]\n                               [--profitable] [-n INT] [--print-json]\n                               [--hyperopt-filename FILENAME] [--no-header]\n                               [--disable-param-export]\n                               [--breakdown {day,week,month} [{day,week,month} ...]]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --best                Select only best epochs.\n  --profitable          Select only profitable epochs.\n  -n INT, --index INT   Specify the index of the epoch to print details for.\n  --print-json          Print output in JSON format.\n  --hyperopt-filename FILENAME\n                        Hyperopt result filename.Example: `--hyperopt-\n                        filename=hyperopt_results_2020-09-27_16-20-48.pickle`\n  --no-header           Do not print epoch details header.\n  --disable-param-export\n                        Disable automatic hyperopt parameter export.\n  --breakdown {day,week,month} [{day,week,month} ...]\n                        Show backtesting breakdown per [day, week, month].\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n</code></pre> <p>Note</p> <p><code>hyperopt-show</code> will automatically use the latest available hyperopt results file. You can override this using the <code>--hyperopt-filename</code> argument, and specify another, available filename (without path!).</p>"},{"location":"utils/#examples_3","title":"Examples","text":"<p>Print details for the epoch 168 (the number of the epoch is shown by the <code>hyperopt-list</code> subcommand or by Hyperopt itself during hyperoptimization run):</p> <pre><code>freqtrade hyperopt-show -n 168\n</code></pre> <p>Prints JSON data with details for the last best epoch (i.e., the best of all epochs):</p> <pre><code>freqtrade hyperopt-show --best -n -1 --print-json --no-header\n</code></pre>"},{"location":"utils/#show-trades","title":"Show trades","text":"<p>Print selected (or all) trades from database to screen.</p> <pre><code>usage: freqtrade show-trades [-h] [-v] [--logfile FILE] [-V] [-c PATH]\n                             [-d PATH] [--userdir PATH] [--db-url PATH]\n                             [--trade-ids TRADE_IDS [TRADE_IDS ...]]\n                             [--print-json]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --db-url PATH         Override trades database URL, this is useful in custom\n                        deployments (default: `sqlite:///tradesv3.sqlite` for\n                        Live Run mode, `sqlite:///tradesv3.dryrun.sqlite` for\n                        Dry Run).\n  --trade-ids TRADE_IDS [TRADE_IDS ...]\n                        Specify the list of trade ids.\n  --print-json          Print output in JSON format.\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n</code></pre>"},{"location":"utils/#examples_4","title":"Examples","text":"<p>Print trades with id 2 and 3 as json</p> <pre><code>freqtrade show-trades --db-url sqlite:///tradesv3.sqlite --trade-ids 2 3 --print-json\n</code></pre>"},{"location":"utils/#strategy-updater","title":"Strategy-Updater","text":"<p>Updates listed strategies or all strategies within the strategies folder to be v3 compliant. If the command runs without --strategy-list then all strategies inside the strategies folder will be converted. Your original strategy will remain available in the <code>user_data/strategies_orig_updater/</code> directory.</p> <p>Conversion results</p> <p>Strategy updater will work on a \"best effort\" approach. Please do your due diligence and verify the results of the conversion. We also recommend to run a python formatter (e.g. <code>black</code>) to format results in a sane manner.</p> <pre><code>usage: freqtrade strategy-updater [-h] [-v] [--logfile FILE] [-V] [-c PATH]\n                                  [-d PATH] [--userdir PATH]\n                                  [--strategy-list STRATEGY_LIST [STRATEGY_LIST ...]]\n\noptions:\n  -h, --help            show this help message and exit\n  --strategy-list STRATEGY_LIST [STRATEGY_LIST ...]\n                        Provide a space-separated list of strategies to\n                        be converted.\n\nCommon arguments:\n  -v, --verbose         Verbose mode (-vv for more, -vvv to get all messages).\n  --logfile FILE, --log-file FILE\n                        Log to the file specified. Special values are:\n                        'syslog', 'journald'. See the documentation for more\n                        details.\n  -V, --version         show program's version number and exit\n  -c PATH, --config PATH\n                        Specify configuration file (default:\n                        `userdir/config.json` or `config.json` whichever\n                        exists). Multiple --config options may be used. Can be\n                        set to `-` to read config from stdin.\n  -d PATH, --datadir PATH, --data-dir PATH\n                        Path to directory with historical backtesting data.\n  --userdir PATH, --user-data-dir PATH\n                        Path to userdata directory.\n</code></pre>"},{"location":"webhook-config/","title":"Webhook usage","text":""},{"location":"webhook-config/#configuration","title":"Configuration","text":"<p>Enable webhooks by adding a webhook-section to your configuration file, and setting <code>webhook.enabled</code> to <code>true</code>.</p> <p>Sample configuration (tested using IFTTT).</p> <pre><code>  \"webhook\": {\n        \"enabled\": true,\n        \"url\": \"https://maker.ifttt.com/trigger/&lt;YOUREVENT&gt;/with/key/&lt;YOURKEY&gt;/\",\n        \"entry\": {\n            \"value1\": \"Buying {pair}\",\n            \"value2\": \"limit {limit:8f}\",\n            \"value3\": \"{stake_amount:8f} {stake_currency}\"\n        },\n        \"entry_cancel\": {\n            \"value1\": \"Cancelling Open Buy Order for {pair}\",\n            \"value2\": \"limit {limit:8f}\",\n            \"value3\": \"{stake_amount:8f} {stake_currency}\"\n        },\n         \"entry_fill\": {\n            \"value1\": \"Buy Order for {pair} filled\",\n            \"value2\": \"at {open_rate:8f}\",\n            \"value3\": \"\"\n        },\n        \"exit\": {\n            \"value1\": \"Exiting {pair}\",\n            \"value2\": \"limit {limit:8f}\",\n            \"value3\": \"profit: {profit_amount:8f} {stake_currency} ({profit_ratio})\"\n        },\n        \"exit_cancel\": {\n            \"value1\": \"Cancelling Open Exit Order for {pair}\",\n            \"value2\": \"limit {limit:8f}\",\n            \"value3\": \"profit: {profit_amount:8f} {stake_currency} ({profit_ratio})\"\n        },\n        \"exit_fill\": {\n            \"value1\": \"Exit Order for {pair} filled\",\n            \"value2\": \"at {close_rate:8f}.\",\n            \"value3\": \"\"\n        },\n        \"status\": {\n            \"value1\": \"Status: {status}\",\n            \"value2\": \"\",\n            \"value3\": \"\"\n        }\n    },\n</code></pre> <p>The url in <code>webhook.url</code> should point to the correct url for your webhook. If you're using IFTTT (as shown in the sample above) please insert your event and key to the url.</p> <p>You can set the POST body format to Form-Encoded (default), JSON-Encoded, or raw data. Use <code>\"format\": \"form\"</code>, <code>\"format\": \"json\"</code>, or <code>\"format\": \"raw\"</code> respectively. Example configuration for Mattermost Cloud integration:</p> <pre><code>  \"webhook\": {\n        \"enabled\": true,\n        \"url\": \"https://&lt;YOURSUBDOMAIN&gt;.cloud.mattermost.com/hooks/&lt;YOURHOOK&gt;\",\n        \"format\": \"json\",\n        \"status\": {\n            \"text\": \"Status: {status}\"\n        }\n    },\n</code></pre> <p>The result would be a POST request with e.g. <code>{\"text\":\"Status: running\"}</code> body and <code>Content-Type: application/json</code> header which results <code>Status: running</code> message in the Mattermost channel.</p> <p>When using the Form-Encoded or JSON-Encoded configuration you can configure any number of payload values, and both the key and value will be output in the POST request. However, when using the raw data format you can only configure one value and it must be named <code>\"data\"</code>. In this instance the data key will not be output in the POST request, only the value. For example:</p> <pre><code>  \"webhook\": {\n        \"enabled\": true,\n        \"url\": \"https://&lt;YOURHOOKURL&gt;\",\n        \"format\": \"raw\",\n        \"webhookstatus\": {\n            \"data\": \"Status: {status}\"\n        }\n    },\n</code></pre> <p>The result would be a POST request with e.g. <code>Status: running</code> body and <code>Content-Type: text/plain</code> header.</p>"},{"location":"webhook-config/#additional-configurations","title":"Additional configurations","text":"<p>The <code>webhook.retries</code> parameter can be set for the maximum number of retries the webhook request should attempt if it is unsuccessful (i.e. HTTP response status is not 200). By default this is set to <code>0</code> which is disabled. An additional <code>webhook.retry_delay</code> parameter can be set to specify the time in seconds between retry attempts. By default this is set to <code>0.1</code> (i.e. 100ms). Note that increasing the number of retries or retry delay may slow down the trader if there are connectivity issues with the webhook. You can also specify <code>webhook.timeout</code> - which defines how long the bot will wait until it assumes the other host as unresponsive (defaults to 10s).</p> <p>Example configuration for retries:</p> <pre><code>  \"webhook\": {\n        \"enabled\": true,\n        \"url\": \"https://&lt;YOURHOOKURL&gt;\",\n        \"timeout\": 10,\n        \"retries\": 3,\n        \"retry_delay\": 0.2,\n        \"status\": {\n            \"status\": \"Status: {status}\"\n        }\n    },\n</code></pre> <p>Custom messages can be sent to Webhook endpoints via the <code>self.dp.send_msg()</code> function from within the strategy. To enable this, set the <code>allow_custom_messages</code> option to <code>true</code>:</p> <pre><code>  \"webhook\": {\n        \"enabled\": true,\n        \"url\": \"https://&lt;YOURHOOKURL&gt;\",\n        \"allow_custom_messages\": true,\n        \"strategy_msg\": {\n            \"status\": \"StrategyMessage: {msg}\"\n        }\n    },\n</code></pre> <p>Different payloads can be configured for different events. Not all fields are necessary, but you should configure at least one of the dicts, otherwise the webhook will never be called.</p>"},{"location":"webhook-config/#webhook-message-types","title":"Webhook Message types","text":""},{"location":"webhook-config/#entry","title":"Entry","text":"<p>The fields in <code>webhook.entry</code> are filled when the bot executes a long/short. Parameters are filled using string.format. Possible parameters are:</p> <ul> <li><code>trade_id</code></li> <li><code>exchange</code></li> <li><code>pair</code></li> <li><code>direction</code></li> <li><code>leverage</code></li> <li><code>limit</code> # Deprecated - should no longer be used.</li> <li><code>open_rate</code></li> <li><code>amount</code></li> <li><code>open_date</code></li> <li><code>stake_amount</code></li> <li><code>stake_currency</code></li> <li><code>base_currency</code></li> <li><code>quote_currency</code></li> <li><code>fiat_currency</code></li> <li><code>order_type</code></li> <li><code>current_rate</code></li> <li><code>enter_tag</code></li> </ul>"},{"location":"webhook-config/#entry-cancel","title":"Entry cancel","text":"<p>The fields in <code>webhook.entry_cancel</code> are filled when the bot cancels a long/short order. Parameters are filled using string.format. Possible parameters are:</p> <ul> <li><code>trade_id</code></li> <li><code>exchange</code></li> <li><code>pair</code></li> <li><code>direction</code></li> <li><code>leverage</code></li> <li><code>limit</code></li> <li><code>amount</code></li> <li><code>open_date</code></li> <li><code>stake_amount</code></li> <li><code>stake_currency</code></li> <li><code>base_currency</code></li> <li><code>quote_currency</code></li> <li><code>fiat_currency</code></li> <li><code>order_type</code></li> <li><code>current_rate</code></li> <li><code>enter_tag</code></li> </ul>"},{"location":"webhook-config/#entry-fill","title":"Entry fill","text":"<p>The fields in <code>webhook.entry_fill</code> are filled when the bot filled a long/short order. Parameters are filled using string.format. Possible parameters are:</p> <ul> <li><code>trade_id</code></li> <li><code>exchange</code></li> <li><code>pair</code></li> <li><code>direction</code></li> <li><code>leverage</code></li> <li><code>open_rate</code></li> <li><code>amount</code></li> <li><code>open_date</code></li> <li><code>stake_amount</code></li> <li><code>stake_currency</code></li> <li><code>base_currency</code></li> <li><code>quote_currency</code></li> <li><code>fiat_currency</code></li> <li><code>order_type</code></li> <li><code>current_rate</code></li> <li><code>enter_tag</code></li> </ul>"},{"location":"webhook-config/#exit","title":"Exit","text":"<p>The fields in <code>webhook.exit</code> are filled when the bot exits a trade. Parameters are filled using string.format. Possible parameters are:</p> <ul> <li><code>trade_id</code></li> <li><code>exchange</code></li> <li><code>pair</code></li> <li><code>direction</code></li> <li><code>leverage</code></li> <li><code>gain</code></li> <li><code>limit</code></li> <li><code>amount</code></li> <li><code>open_rate</code></li> <li><code>profit_amount</code></li> <li><code>profit_ratio</code></li> <li><code>stake_currency</code></li> <li><code>base_currency</code></li> <li><code>quote_currency</code></li> <li><code>fiat_currency</code></li> <li><code>exit_reason</code></li> <li><code>order_type</code></li> <li><code>open_date</code></li> <li><code>close_date</code></li> </ul>"},{"location":"webhook-config/#exit-fill","title":"Exit fill","text":"<p>The fields in <code>webhook.exit_fill</code> are filled when the bot fills a exit order (closes a Trade). Parameters are filled using string.format. Possible parameters are:</p> <ul> <li><code>trade_id</code></li> <li><code>exchange</code></li> <li><code>pair</code></li> <li><code>direction</code></li> <li><code>leverage</code></li> <li><code>gain</code></li> <li><code>close_rate</code></li> <li><code>amount</code></li> <li><code>open_rate</code></li> <li><code>current_rate</code></li> <li><code>profit_amount</code></li> <li><code>profit_ratio</code></li> <li><code>stake_currency</code></li> <li><code>base_currency</code></li> <li><code>quote_currency</code></li> <li><code>fiat_currency</code></li> <li><code>exit_reason</code></li> <li><code>order_type</code></li> <li><code>open_date</code></li> <li><code>close_date</code></li> </ul>"},{"location":"webhook-config/#exit-cancel","title":"Exit cancel","text":"<p>The fields in <code>webhook.exit_cancel</code> are filled when the bot cancels a exit order. Parameters are filled using string.format. Possible parameters are:</p> <ul> <li><code>trade_id</code></li> <li><code>exchange</code></li> <li><code>pair</code></li> <li><code>direction</code></li> <li><code>leverage</code></li> <li><code>gain</code></li> <li><code>limit</code></li> <li><code>amount</code></li> <li><code>open_rate</code></li> <li><code>current_rate</code></li> <li><code>profit_amount</code></li> <li><code>profit_ratio</code></li> <li><code>stake_currency</code></li> <li><code>base_currency</code></li> <li><code>quote_currency</code></li> <li><code>fiat_currency</code></li> <li><code>exit_reason</code></li> <li><code>order_type</code></li> <li><code>open_date</code></li> <li><code>close_date</code></li> </ul>"},{"location":"webhook-config/#status","title":"Status","text":"<p>The fields in <code>webhook.status</code> are used for regular status messages (Started / Stopped / ...). Parameters are filled using string.format.</p> <p>The only possible value here is <code>{status}</code>.</p>"},{"location":"webhook-config/#discord","title":"Discord","text":"<p>A special form of webhooks is available for discord. You can configure this as follows:</p> <pre><code>\"discord\": {\n    \"enabled\": true,\n    \"webhook_url\": \"https://discord.com/api/webhooks/&lt;Your webhook URL ...&gt;\",\n    \"exit_fill\": [\n        {\"Trade ID\": \"{trade_id}\"},\n        {\"Exchange\": \"{exchange}\"},\n        {\"Pair\": \"{pair}\"},\n        {\"Direction\": \"{direction}\"},\n        {\"Open rate\": \"{open_rate}\"},\n        {\"Close rate\": \"{close_rate}\"},\n        {\"Amount\": \"{amount}\"},\n        {\"Open date\": \"{open_date:%Y-%m-%d %H:%M:%S}\"},\n        {\"Close date\": \"{close_date:%Y-%m-%d %H:%M:%S}\"},\n        {\"Profit\": \"{profit_amount} {stake_currency}\"},\n        {\"Profitability\": \"{profit_ratio:.2%}\"},\n        {\"Enter tag\": \"{enter_tag}\"},\n        {\"Exit Reason\": \"{exit_reason}\"},\n        {\"Strategy\": \"{strategy}\"},\n        {\"Timeframe\": \"{timeframe}\"},\n    ],\n    \"entry_fill\": [\n        {\"Trade ID\": \"{trade_id}\"},\n        {\"Exchange\": \"{exchange}\"},\n        {\"Pair\": \"{pair}\"},\n        {\"Direction\": \"{direction}\"},\n        {\"Open rate\": \"{open_rate}\"},\n        {\"Amount\": \"{amount}\"},\n        {\"Open date\": \"{open_date:%Y-%m-%d %H:%M:%S}\"},\n        {\"Enter tag\": \"{enter_tag}\"},\n        {\"Strategy\": \"{strategy} {timeframe}\"},\n    ]\n}\n</code></pre> <p>The above represents the default (<code>exit_fill</code> and <code>entry_fill</code> are optional and will default to the above configuration) - modifications are obviously possible. To disable either of the two default values (<code>entry_fill</code> / <code>exit_fill</code>), you can assign them an empty array (<code>exit_fill: []</code>).</p> <p>Available fields correspond to the fields for webhooks and are documented in the corresponding webhook sections.</p> <p>The notifications will look as follows by default.</p> <p></p> <p>Custom messages can be sent from a strategy to Discord endpoints via the dataprovider.send_msg() function. To enable this, set the <code>allow_custom_messages</code> option to <code>true</code>:</p> <pre><code>  \"discord\": {\n        \"enabled\": true,\n        \"webhook_url\": \"https://discord.com/api/webhooks/&lt;Your webhook URL ...&gt;\",\n        \"allow_custom_messages\": true,\n    },\n</code></pre>"},{"location":"windows_installation/","title":"Windows installation","text":"<p>We strongly recommend that Windows users use Docker as this will work much easier and smoother (also more secure).</p> <p>If that is not possible, try using the Windows Linux subsystem (WSL) - for which the Ubuntu instructions should work. Otherwise, please follow the instructions below.</p> <p>All instructions assume that python 3.9+ is installed and available.</p>"},{"location":"windows_installation/#clone-the-git-repository","title":"Clone the git repository","text":"<p>First of all clone the repository by running:</p> <pre><code>git clone https://github.com/freqtrade/freqtrade.git\n</code></pre> <p>Now, choose your installation method, either automatically via script (recommended) or manually following the corresponding instructions.</p>"},{"location":"windows_installation/#install-freqtrade-automatically","title":"Install freqtrade automatically","text":""},{"location":"windows_installation/#run-the-installation-script","title":"Run the installation script","text":"<p>The script will ask you a few questions to determine which parts should be installed.</p> <pre><code>Set-ExecutionPolicy -ExecutionPolicy Bypass\ncd freqtrade\n. .\\setup.ps1\n</code></pre>"},{"location":"windows_installation/#install-freqtrade-manually","title":"Install freqtrade manually","text":"<p>64bit Python version</p> <p>Please make sure to use 64bit Windows and 64bit Python to avoid problems with backtesting or hyperopt due to the memory constraints 32bit applications have under Windows. 32bit python versions are no longer supported under Windows.</p> <p>Hint</p> <p>Using the Anaconda Distribution under Windows can greatly help with installation problems. Check out the Anaconda installation section in the documentation for more information.</p>"},{"location":"windows_installation/#install-ta-lib","title":"Install ta-lib","text":"<p>Install ta-lib according to the ta-lib documentation.</p> <p>As compiling from source on windows has heavy dependencies (requires a partial visual studio installation), Freqtrade provides these dependencies (in the binary wheel format) for the latest 3 Python versions (3.9, 3.10, 3.11 and 3.12) and for 64bit Windows. These Wheels are also used by CI running on windows, and are therefore tested together with freqtrade.</p> <p>Other versions must be downloaded from the above link.</p> <pre><code>cd \\path\\freqtrade\npython -m venv .venv\n.venv\\Scripts\\activate.ps1\n# optionally install ta-lib from wheel\n# Eventually adjust the below filename to match the downloaded wheel\npip install --find-links build_helpers\\ TA-Lib -U\npip install -r requirements.txt\npip install -e .\nfreqtrade\n</code></pre> <p>Use Powershell</p> <p>The above installation script assumes you're using powershell on a 64bit windows. Commands for the legacy CMD windows console may differ.</p>"},{"location":"windows_installation/#error-during-installation-on-windows","title":"Error during installation on Windows","text":"<pre><code>error: Microsoft Visual C++ 14.0 is required. Get it with \"Microsoft Visual C++ Build Tools\": http://landinghub.visualstudio.com/visual-cpp-build-tools\n</code></pre> <p>Unfortunately, many packages requiring compilation don't provide a pre-built wheel. It is therefore mandatory to have a C/C++ compiler installed and available for your python environment to use.</p> <p>You can download the Visual C++ build tools from here and install \"Desktop development with C++\" in it's default configuration. Unfortunately, this is a heavy download / dependency so you might want to consider WSL2 or docker compose first.</p> <p></p>"},{"location":"includes/cors/","title":"Cors","text":""},{"location":"includes/cors/#cors","title":"CORS","text":"<p>This whole section is only necessary in cross-origin cases (where you multiple bot API's running on <code>localhost:8081</code>, <code>localhost:8082</code>, ...), and want to combine them into one FreqUI instance.</p> Technical explanation <p>All web-based front-ends are subject to CORS - Cross-Origin Resource Sharing. Since most of the requests to the Freqtrade API must be authenticated, a proper CORS policy is key to avoid security problems. Also, the standard disallows <code>*</code> CORS policies for requests with credentials, so this setting must be set appropriately.</p> <p>Users can allow access from different origin URL's to the bot API via the <code>CORS_origins</code> configuration setting. It consists of a list of allowed URL's that are allowed to consume resources from the bot's API.</p> <p>Assuming your application is deployed as <code>https://frequi.freqtrade.io/home/</code> - this would mean that the following configuration becomes necessary:</p> <pre><code>{\n    //...\n    \"jwt_secret_key\": \"somethingrandom\",\n    \"CORS_origins\": [\"https://frequi.freqtrade.io\"],\n    //...\n}\n</code></pre> <p>In the following (pretty common) case, FreqUI is accessible on <code>http://localhost:8080/trade</code> (this is what you see in your navbar when navigating to freqUI). </p> <p>The correct configuration for this case is <code>http://localhost:8080</code> - the main part of the URL including the port.</p> <pre><code>{\n    //...\n    \"jwt_secret_key\": \"somethingrandom\",\n    \"CORS_origins\": [\"http://localhost:8080\"],\n    //...\n}\n</code></pre> <p>trailing Slash</p> <p>The trailing slash is not allowed in the <code>CORS_origins</code> configuration (e.g. <code>\"http://localhots:8080/\"</code>). Such a configuration will not take effect, and the cors errors will remain.</p> <p>Note</p> <p>We strongly recommend to also set <code>jwt_secret_key</code> to something random and known only to yourself to avoid unauthorized access to your bot.</p>"},{"location":"includes/pairlists/","title":"Pairlists","text":""},{"location":"includes/pairlists/#pairlists-and-pairlist-handlers","title":"Pairlists and Pairlist Handlers","text":"<p>Pairlist Handlers define the list of pairs (pairlist) that the bot should trade. They are configured in the <code>pairlists</code> section of the configuration settings.</p> <p>In your configuration, you can use Static Pairlist (defined by the <code>StaticPairList</code> Pairlist Handler) and Dynamic Pairlist (defined by the <code>VolumePairList</code> Pairlist Handler).</p> <p>Additionally, <code>AgeFilter</code>, <code>PrecisionFilter</code>, <code>PriceFilter</code>, <code>ShuffleFilter</code>, <code>SpreadFilter</code> and <code>VolatilityFilter</code> act as Pairlist Filters, removing certain pairs and/or moving their positions in the pairlist.</p> <p>If multiple Pairlist Handlers are used, they are chained and a combination of all Pairlist Handlers forms the resulting pairlist the bot uses for trading and backtesting. Pairlist Handlers are executed in the sequence they are configured. You can define either <code>StaticPairList</code>, <code>VolumePairList</code>, <code>ProducerPairList</code>, <code>RemotePairList</code> or <code>MarketCapPairList</code> as the starting Pairlist Handler.</p> <p>Inactive markets are always removed from the resulting pairlist. Explicitly blacklisted pairs (those in the <code>pair_blacklist</code> configuration setting) are also always removed from the resulting pairlist.</p>"},{"location":"includes/pairlists/#pair-blacklist","title":"Pair blacklist","text":"<p>The pair blacklist (configured via <code>exchange.pair_blacklist</code> in the configuration) disallows certain pairs from trading. This can be as simple as excluding <code>DOGE/BTC</code> - which will remove exactly this pair.</p> <p>The pair-blacklist does also support wildcards (in regex-style) - so <code>BNB/.*</code> will exclude ALL pairs that start with BNB. You may also use something like <code>.*DOWN/BTC</code> or <code>.*UP/BTC</code> to exclude leveraged tokens (check Pair naming conventions for your exchange!)</p>"},{"location":"includes/pairlists/#available-pairlist-handlers","title":"Available Pairlist Handlers","text":"<ul> <li><code>StaticPairList</code> (default, if not configured differently)</li> <li><code>VolumePairList</code></li> <li><code>ProducerPairList</code></li> <li><code>RemotePairList</code></li> <li><code>MarketCapPairList</code></li> <li><code>AgeFilter</code></li> <li><code>FullTradesFilter</code></li> <li><code>OffsetFilter</code></li> <li><code>PerformanceFilter</code></li> <li><code>PrecisionFilter</code></li> <li><code>PriceFilter</code></li> <li><code>ShuffleFilter</code></li> <li><code>SpreadFilter</code></li> <li><code>RangeStabilityFilter</code></li> <li><code>VolatilityFilter</code></li> </ul> <p>Testing pairlists</p> <p>Pairlist configurations can be quite tricky to get right. Best use the <code>test-pairlist</code> utility sub-command to test your configuration quickly.</p>"},{"location":"includes/pairlists/#static-pair-list","title":"Static Pair List","text":"<p>By default, the <code>StaticPairList</code> method is used, which uses a statically defined pair whitelist from the configuration. The pairlist also supports wildcards (in regex-style) - so <code>.*/BTC</code> will include all pairs with BTC as a stake.</p> <p>It uses configuration from <code>exchange.pair_whitelist</code> and <code>exchange.pair_blacklist</code>.</p> <pre><code>\"pairlists\": [\n    {\"method\": \"StaticPairList\"}\n],\n</code></pre> <p>By default, only currently enabled pairs are allowed. To skip pair validation against active markets, set <code>\"allow_inactive\": true</code> within the <code>StaticPairList</code> configuration. This can be useful for backtesting expired pairs (like quarterly spot-markets). This option must be configured along with <code>exchange.skip_pair_validation</code> in the exchange configuration.</p> <p>When used in a \"follow-up\" position (e.g. after VolumePairlist), all pairs in <code>'pair_whitelist'</code> will be added to the end of the pairlist.</p>"},{"location":"includes/pairlists/#volume-pair-list","title":"Volume Pair List","text":"<p><code>VolumePairList</code> employs sorting/filtering of pairs by their trading volume. It selects <code>number_assets</code> top pairs with sorting based on the <code>sort_key</code> (which can only be <code>quoteVolume</code>).</p> <p>When used in the chain of Pairlist Handlers in a non-leading position (after StaticPairList and other Pairlist Filters), <code>VolumePairList</code> considers outputs of previous Pairlist Handlers, adding its sorting/selection of the pairs by the trading volume.</p> <p>When used in the leading position of the chain of Pairlist Handlers, the <code>pair_whitelist</code> configuration setting is ignored. Instead, <code>VolumePairList</code> selects the top assets from all available markets with matching stake-currency on the exchange.</p> <p>The <code>refresh_period</code> setting allows to define the period (in seconds), at which the pairlist will be refreshed. Defaults to 1800s (30 minutes). The pairlist cache (<code>refresh_period</code>) on <code>VolumePairList</code> is only applicable to generating pairlists. Filtering instances (not the first position in the list) will not apply any cache (beyond caching candles for the duration of the candle in advanced mode) and will always use up-to-date data.</p> <p><code>VolumePairList</code> is per default based on the ticker data from exchange, as reported by the ccxt library:</p> <ul> <li>The <code>quoteVolume</code> is the amount of quote (stake) currency traded (bought or sold) in last 24 hours.</li> </ul> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"VolumePairList\",\n        \"number_assets\": 20,\n        \"sort_key\": \"quoteVolume\",\n        \"min_value\": 0,\n        \"max_value\": 8000000,\n        \"refresh_period\": 1800\n    }\n],\n</code></pre> <p>You can define a minimum volume with <code>min_value</code> - which will filter out pairs with a volume lower than the specified value in the specified timerange. In addition to that, you can also define a maximum volume with <code>max_value</code> - which will filter out pairs with a volume higher than the specified value in the specified timerange.</p>"},{"location":"includes/pairlists/#volumepairlist-advanced-mode","title":"VolumePairList Advanced mode","text":"<p><code>VolumePairList</code> can also operate in an advanced mode to build volume over a given timerange of specified candle size. It utilizes exchange historical candle data, builds a typical price (calculated by (open+high+low)/3) and multiplies the typical price with every candle's volume. The sum is the <code>quoteVolume</code> over the given range. This allows different scenarios, for a  more smoothened volume, when using longer ranges with larger candle sizes, or the opposite when using a short range with small candles.</p> <p>For convenience <code>lookback_days</code> can be specified, which will imply that 1d candles will be used for the lookback. In the example below the pairlist would be created based on the last 7 days:</p> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"VolumePairList\",\n        \"number_assets\": 20,\n        \"sort_key\": \"quoteVolume\",\n        \"min_value\": 0,\n        \"refresh_period\": 86400,\n        \"lookback_days\": 7\n    }\n],\n</code></pre> <p>Range look back and refresh period</p> <p>When used in conjunction with <code>lookback_days</code> and <code>lookback_timeframe</code> the <code>refresh_period</code> can not be smaller than the candle size in seconds. As this will result in unnecessary requests to the exchanges API.</p> <p>Performance implications when using lookback range</p> <p>If used in first position in combination with lookback, the computation of the range based volume can be time and resource consuming, as it downloads candles for all tradable pairs. Hence it's highly advised to use the standard approach with <code>VolumeFilter</code> to narrow the pairlist down for further range volume calculation.</p> Unsupported exchanges <p>On some exchanges (like Gemini), regular VolumePairList does not work as the api does not natively provide 24h volume. This can be worked around by using candle data to build the volume. To roughly simulate 24h volume, you can use the following configuration. Please note that These pairlists will only refresh once per day.</p> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"VolumePairList\",\n        \"number_assets\": 20,\n        \"sort_key\": \"quoteVolume\",\n        \"min_value\": 0,\n        \"refresh_period\": 86400,\n        \"lookback_days\": 1\n    }\n],\n</code></pre> <p>More sophisticated approach can be used, by using <code>lookback_timeframe</code> for candle size and <code>lookback_period</code> which specifies the amount of candles. This example will build the volume pairs based on a rolling period of 3 days of 1h candles:</p> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"VolumePairList\",\n        \"number_assets\": 20,\n        \"sort_key\": \"quoteVolume\",\n        \"min_value\": 0,\n        \"refresh_period\": 3600,\n        \"lookback_timeframe\": \"1h\",\n        \"lookback_period\": 72\n    }\n],\n</code></pre> <p>Note</p> <p><code>VolumePairList</code> does not support backtesting mode.</p>"},{"location":"includes/pairlists/#producerpairlist","title":"ProducerPairList","text":"<p>With <code>ProducerPairList</code>, you can reuse the pairlist from a Producer without explicitly defining the pairlist on each consumer.</p> <p>Consumer mode is required for this pairlist to work.</p> <p>The pairlist will perform a check on active pairs against the current exchange configuration to avoid attempting to trade on invalid markets.</p> <p>You can limit the length of the pairlist with the optional parameter <code>number_assets</code>. Using <code>\"number_assets\"=0</code> or omitting this key will result in the reuse of all producer pairs valid for the current setup.</p> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"ProducerPairList\",\n        \"number_assets\": 5,\n        \"producer_name\": \"default\",\n    }\n],\n</code></pre> <p>Combining pairlists</p> <p>This pairlist can be combined with all other pairlists and filters for further pairlist reduction, and can also act as an \"additional\" pairlist, on top of already defined pairs. <code>ProducerPairList</code> can also be used multiple times in sequence, combining the pairs from multiple producers. Obviously in complex such configurations, the Producer may not provide data for all pairs, so the strategy must be fit for this.</p>"},{"location":"includes/pairlists/#remotepairlist","title":"RemotePairList","text":"<p>It allows the user to fetch a pairlist from a remote server or a locally stored json file within the freqtrade directory, enabling dynamic updates and customization of the trading pairlist.</p> <p>The RemotePairList is defined in the pairlists section of the configuration settings. It uses the following configuration options:</p> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"RemotePairList\",\n        \"mode\": \"whitelist\",\n        \"processing_mode\": \"filter\",\n        \"pairlist_url\": \"https://example.com/pairlist\",\n        \"number_assets\": 10,\n        \"refresh_period\": 1800,\n        \"keep_pairlist_on_failure\": true,\n        \"read_timeout\": 60,\n        \"bearer_token\": \"my-bearer-token\",\n        \"save_to_file\": \"user_data/filename.json\" \n    }\n]\n</code></pre> <p>The optional <code>mode</code> option specifies if the pairlist should be used as a <code>blacklist</code> or as a <code>whitelist</code>. The default value is \"whitelist\".</p> <p>The optional <code>processing_mode</code> option in the RemotePairList configuration determines how the retrieved pairlist is processed. It can have two values: \"filter\" or \"append\". The default value is \"filter\".</p> <p>In \"filter\" mode, the retrieved pairlist is used as a filter. Only the pairs present in both the original pairlist and the retrieved pairlist are included in the final pairlist. Other pairs are filtered out.</p> <p>In \"append\" mode, the retrieved pairlist is added to the original pairlist. All pairs from both lists are included in the final pairlist without any filtering.</p> <p>The <code>pairlist_url</code> option specifies the URL of the remote server where the pairlist is located, or the path to a local file (if file:/// is prepended). This allows the user to use either a remote server or a local file as the source for the pairlist.</p> <p>The <code>save_to_file</code> option, when provided with a valid filename, saves the processed pairlist to that file in JSON format. This option is optional, and by default, the pairlist is not saved to a file.</p> Multi bot with shared pairlist example <p><code>save_to_file</code> can be used to save the pairlist to a file with Bot1:</p> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"RemotePairList\",\n        \"mode\": \"whitelist\",\n        \"pairlist_url\": \"https://example.com/pairlist\",\n        \"number_assets\": 10,\n        \"refresh_period\": 1800,\n        \"keep_pairlist_on_failure\": true,\n        \"read_timeout\": 60,\n        \"save_to_file\": \"user_data/filename.json\" \n    }\n]\n</code></pre> <p>This saved pairlist file can be loaded by Bot2, or any additional bot with this configuration:</p> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"RemotePairList\",\n        \"mode\": \"whitelist\",\n        \"pairlist_url\": \"file:///user_data/filename.json\",\n        \"number_assets\": 10,\n        \"refresh_period\": 10,\n        \"keep_pairlist_on_failure\": true,\n    }\n]\n</code></pre> <p>The user is responsible for providing a server or local file that returns a JSON object with the following structure:</p> <pre><code>{\n    \"pairs\": [\"XRP/USDT\", \"ETH/USDT\", \"LTC/USDT\"],\n    \"refresh_period\": 1800\n}\n</code></pre> <p>The <code>pairs</code> property should contain a list of strings with the trading pairs to be used by the bot. The <code>refresh_period</code> property is optional and specifies the number of seconds that the pairlist should be cached before being refreshed.</p> <p>The optional <code>keep_pairlist_on_failure</code> specifies whether the previous received pairlist should be used if the remote server is not reachable or returns an error. The default value is true.</p> <p>The optional <code>read_timeout</code> specifies the maximum amount of time (in seconds) to wait for a response from the remote source, The default value is 60.</p> <p>The optional <code>bearer_token</code> will be included in the requests Authorization Header.</p> <p>Note</p> <p>In case of a server error the last received pairlist will be kept if <code>keep_pairlist_on_failure</code> is set to true, when set to false a empty pairlist is returned.</p>"},{"location":"includes/pairlists/#marketcappairlist","title":"MarketCapPairList","text":"<p><code>MarketCapPairList</code> employs sorting/filtering of pairs by their marketcap rank based of CoinGecko. It will only recognize coins up to the coin placed at rank 250. The returned pairlist will be sorted based of their marketcap ranks.</p> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"MarketCapPairList\",\n        \"number_assets\": 20,\n        \"max_rank\": 50,\n        \"refresh_period\": 86400\n    }\n]\n</code></pre> <p><code>number_assets</code> defines the maximum number of pairs returned by the pairlist. <code>max_rank</code> will determine the maximum rank used in creating/filtering the pairlist. It's expected that some coins within the top <code>max_rank</code> marketcap will not be included in the resulting pairlist since not all pairs will have active trading pairs in your preferred market/stake/exchange combination.</p> <p><code>refresh_period</code> setting defines the period (in seconds) at which the marketcap rank data will be refreshed. Defaults to 86,400s (1 day). The pairlist cache (<code>refresh_period</code>) is applicable on both generating pairlists (first position in the list) and filtering instances (not the first position in the list).</p>"},{"location":"includes/pairlists/#agefilter","title":"AgeFilter","text":"<p>Removes pairs that have been listed on the exchange for less than <code>min_days_listed</code> days (defaults to <code>10</code>) or more than <code>max_days_listed</code> days (defaults <code>None</code> mean infinity).</p> <p>When pairs are first listed on an exchange they can suffer huge price drops and volatility in the first few days while the pair goes through its price-discovery period. Bots can often be caught out buying before the pair has finished dropping in price.</p> <p>This filter allows freqtrade to ignore pairs until they have been listed for at least <code>min_days_listed</code> days and listed before <code>max_days_listed</code>.</p>"},{"location":"includes/pairlists/#fulltradesfilter","title":"FullTradesFilter","text":"<p>Shrink whitelist to consist only in-trade pairs when the trade slots are full (when <code>max_open_trades</code> isn't being set to <code>-1</code> in the config).</p> <p>When the trade slots are full, there is no need to calculate indicators of the rest of the pairs (except informative pairs) since no new trade can be opened. By shrinking the whitelist to just the in-trade pairs, you can improve calculation speeds and reduce CPU usage. When a trade slot is free (either a trade is closed or <code>max_open_trades</code> value in config is increased), then the whitelist will return to normal state.</p> <p>When multiple pairlist filters are being used, it's recommended to put this filter at second position directly below the primary pairlist, so when the trade slots are full, the bot doesn't have to download data for the rest of the filters.</p> <p>Backtesting</p> <p><code>FullTradesFilter</code> does not support backtesting mode.</p>"},{"location":"includes/pairlists/#offsetfilter","title":"OffsetFilter","text":"<p>Offsets an incoming pairlist by a given <code>offset</code> value.</p> <p>As an example it can be used in conjunction with <code>VolumeFilter</code> to remove the top X volume pairs. Or to split a larger pairlist on two bot instances.</p> <p>Example to remove the first 10 pairs from the pairlist, and takes the next 20 (taking items 10-30 of the initial list):</p> <pre><code>\"pairlists\": [\n    // ...\n    {\n        \"method\": \"OffsetFilter\",\n        \"offset\": 10,\n        \"number_assets\": 20\n    }\n],\n</code></pre> <p>Warning</p> <p>When <code>OffsetFilter</code> is used to split a larger pairlist among multiple bots in combination with <code>VolumeFilter</code>  it can not be guaranteed that pairs won't overlap due to slightly different refresh intervals for the <code>VolumeFilter</code>.</p> <p>Note</p> <p>An offset larger than the total length of the incoming pairlist will result in an empty pairlist.</p>"},{"location":"includes/pairlists/#performancefilter","title":"PerformanceFilter","text":"<p>Sorts pairs by past trade performance, as follows:</p> <ol> <li>Positive performance.</li> <li>No closed trades yet.</li> <li>Negative performance.</li> </ol> <p>Trade count is used as a tie breaker.</p> <p>You can use the <code>minutes</code> parameter to only consider performance of the past X minutes (rolling window). Not defining this parameter (or setting it to 0) will use all-time performance.</p> <p>The optional <code>min_profit</code> (as ratio -&gt; a setting of <code>0.01</code> corresponds to 1%) parameter defines the minimum profit a pair must have to be considered. Pairs below this level will be filtered out. Using this parameter without <code>minutes</code> is highly discouraged, as it can lead to an empty pairlist without a way to recover.</p> <pre><code>\"pairlists\": [\n    // ...\n    {\n        \"method\": \"PerformanceFilter\",\n        \"minutes\": 1440,  // rolling 24h\n        \"min_profit\": 0.01  // minimal profit 1%\n    }\n],\n</code></pre> <p>As this Filter uses past performance of the bot, it'll have some startup-period - and should only be used after the bot has a few 100 trades in the database.</p> <p>Backtesting</p> <p><code>PerformanceFilter</code> does not support backtesting mode.</p>"},{"location":"includes/pairlists/#precisionfilter","title":"PrecisionFilter","text":"<p>Filters low-value coins which would not allow setting stoplosses.</p> <p>Namely, pairs are blacklisted if a variance of one percent or more in the stop price would be caused by precision rounding on the exchange, i.e. <code>rounded(stop_price) &lt;= rounded(stop_price * 0.99)</code>. The idea is to avoid coins with a value VERY close to their lower trading boundary, not allowing setting of proper stoploss.</p> <p>PrecisionFilter is pointless for futures trading</p> <p>The above does not apply to shorts. And for longs, in theory the trade will be liquidated first.</p> <p>Backtesting</p> <p><code>PrecisionFilter</code> does not support backtesting mode using multiple strategies.</p>"},{"location":"includes/pairlists/#pricefilter","title":"PriceFilter","text":"<p>The <code>PriceFilter</code> allows filtering of pairs by price. Currently the following price filters are supported:</p> <ul> <li><code>min_price</code></li> <li><code>max_price</code></li> <li><code>max_value</code></li> <li><code>low_price_ratio</code></li> </ul> <p>The <code>min_price</code> setting removes pairs where the price is below the specified price. This is useful if you wish to avoid trading very low-priced pairs. This option is disabled by default, and will only apply if set to &gt; 0.</p> <p>The <code>max_price</code> setting removes pairs where the price is above the specified price. This is useful if you wish to trade only low-priced pairs. This option is disabled by default, and will only apply if set to &gt; 0.</p> <p>The <code>max_value</code> setting removes pairs where the minimum value change is above a specified value. This is useful when an exchange has unbalanced limits. For example, if step-size = 1 (so you can only buy 1, or 2, or 3, but not 1.1 Coins) - and the price is pretty high (like 20$) as the coin has risen sharply since the last limit adaption. As a result of the above, you can only buy for 20$, or 40$ - but not for 25$. On exchanges that deduct fees from the receiving currency (e.g. binance) - this can result in high value coins / amounts that are unsellable as the amount is slightly below the limit.</p> <p>The <code>low_price_ratio</code> setting removes pairs where a raise of 1 price unit (pip) is above the <code>low_price_ratio</code> ratio. This option is disabled by default, and will only apply if set to &gt; 0.</p> <p>For <code>PriceFilter</code> at least one of its <code>min_price</code>, <code>max_price</code> or <code>low_price_ratio</code> settings must be applied.</p> <p>Calculation example:</p> <p>Min price precision for SHITCOIN/BTC is 8 decimals. If its price is 0.00000011 - one price step above would be 0.00000012, which is ~9% higher than the previous price value. You may filter out this pair by using PriceFilter with <code>low_price_ratio</code> set to 0.09 (9%) or with <code>min_price</code> set to 0.00000011, correspondingly.</p> <p>Low priced pairs</p> <p>Low priced pairs with high \"1 pip movements\" are dangerous since they are often illiquid and it may also be impossible to place the desired stoploss, which can often result in high losses since price needs to be rounded to the next tradable price - so instead of having a stoploss of -5%, you could end up with a stoploss of -9% simply due to price rounding.</p>"},{"location":"includes/pairlists/#shufflefilter","title":"ShuffleFilter","text":"<p>Shuffles (randomizes) pairs in the pairlist. It can be used for preventing the bot from trading some of the pairs more frequently then others when you want all pairs be treated with the same priority.</p> <p>By default, ShuffleFilter will shuffle pairs once per candle. To shuffle on every iteration, set <code>\"shuffle_frequency\"</code> to <code>\"iteration\"</code> instead of  the default of <code>\"candle\"</code>.</p> <pre><code>    {\n        \"method\": \"ShuffleFilter\", \n        \"shuffle_frequency\": \"candle\",\n        \"seed\": 42\n    }\n</code></pre> <p>Tip</p> <p>You may set the <code>seed</code> value for this Pairlist to obtain reproducible results, which can be useful for repeated backtesting sessions. If <code>seed</code> is not set, the pairs are shuffled in the non-repeatable random order. ShuffleFilter will automatically detect runmodes and apply the <code>seed</code> only for backtesting modes - if a <code>seed</code> value is set.</p>"},{"location":"includes/pairlists/#spreadfilter","title":"SpreadFilter","text":"<p>Removes pairs that have a difference between asks and bids above the specified ratio, <code>max_spread_ratio</code> (defaults to <code>0.005</code>).</p> <p>Example:</p> <p>If <code>DOGE/BTC</code> maximum bid is 0.00000026 and minimum ask is 0.00000027, the ratio is calculated as: <code>1 - bid/ask ~= 0.037</code> which is <code>&gt; 0.005</code> and this pair will be filtered out.</p>"},{"location":"includes/pairlists/#rangestabilityfilter","title":"RangeStabilityFilter","text":"<p>Removes pairs where the difference between lowest low and highest high over <code>lookback_days</code> days is below <code>min_rate_of_change</code> or above <code>max_rate_of_change</code>. Since this is a filter that requires additional data, the results are cached for <code>refresh_period</code>.</p> <p>In the below example: If the trading range over the last 10 days is &lt;1% or &gt;99%, remove the pair from the whitelist.</p> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"RangeStabilityFilter\",\n        \"lookback_days\": 10,\n        \"min_rate_of_change\": 0.01,\n        \"max_rate_of_change\": 0.99,\n        \"refresh_period\": 86400\n    }\n]\n</code></pre> <p>Adding <code>\"sort_direction\": \"asc\"</code> or <code>\"sort_direction\": \"desc\"</code> enables sorting for this pairlist.</p> <p>Tip</p> <p>This Filter can be used to automatically remove stable coin pairs, which have a very low trading range, and are therefore extremely difficult to trade with profit. Additionally, it can also be used to automatically remove pairs with extreme high/low variance over a given amount of time.</p>"},{"location":"includes/pairlists/#volatilityfilter","title":"VolatilityFilter","text":"<p>Volatility is the degree of historical variation of a pairs over time, it is measured by the standard deviation of logarithmic daily returns. Returns are assumed to be normally distributed, although actual distribution might be different. In a normal distribution, 68% of observations fall within one standard deviation and 95% of observations fall within two standard deviations. Assuming a volatility of 0.05 means that the expected returns for 20 out of 30 days is expected to be less than 5% (one standard deviation). Volatility is a positive ratio of the expected deviation of return and can be greater than 1.00. Please refer to the wikipedia definition of <code>volatility</code>.</p> <p>This filter removes pairs if the average volatility over a <code>lookback_days</code> days is below <code>min_volatility</code> or above <code>max_volatility</code>. Since this is a filter that requires additional data, the results are cached for <code>refresh_period</code>.</p> <p>This filter can be used to narrow down your pairs to a certain volatility or avoid very volatile pairs.</p> <p>In the below example: If the volatility over the last 10 days is not in the range of 0.05-0.50, remove the pair from the whitelist. The filter is applied every 24h.</p> <pre><code>\"pairlists\": [\n    {\n        \"method\": \"VolatilityFilter\",\n        \"lookback_days\": 10,\n        \"min_volatility\": 0.05,\n        \"max_volatility\": 0.50,\n        \"refresh_period\": 86400\n    }\n]\n</code></pre> <p>Adding <code>\"sort_direction\": \"asc\"</code> or <code>\"sort_direction\": \"desc\"</code> enables sorting mode for this pairlist.</p>"},{"location":"includes/pairlists/#full-example-of-pairlist-handlers","title":"Full example of Pairlist Handlers","text":"<p>The below example blacklists <code>BNB/BTC</code>, uses <code>VolumePairList</code> with <code>20</code> assets, sorting pairs by <code>quoteVolume</code> and applies <code>PrecisionFilter</code> and <code>PriceFilter</code>, filtering all assets where 1 price unit is &gt; 1%. Then the <code>SpreadFilter</code> and <code>VolatilityFilter</code> is applied and pairs are finally shuffled with the random seed set to some predefined value.</p> <pre><code>\"exchange\": {\n    \"pair_whitelist\": [],\n    \"pair_blacklist\": [\"BNB/BTC\"]\n},\n\"pairlists\": [\n    {\n        \"method\": \"VolumePairList\",\n        \"number_assets\": 20,\n        \"sort_key\": \"quoteVolume\"\n    },\n    {\"method\": \"AgeFilter\", \"min_days_listed\": 10},\n    {\"method\": \"PrecisionFilter\"},\n    {\"method\": \"PriceFilter\", \"low_price_ratio\": 0.01},\n    {\"method\": \"SpreadFilter\", \"max_spread_ratio\": 0.005},\n    {\n        \"method\": \"RangeStabilityFilter\",\n        \"lookback_days\": 10,\n        \"min_rate_of_change\": 0.01,\n        \"refresh_period\": 86400\n    },\n    {\n        \"method\": \"VolatilityFilter\",\n        \"lookback_days\": 10,\n        \"min_volatility\": 0.05,\n        \"max_volatility\": 0.50,\n        \"refresh_period\": 86400\n    },\n    {\"method\": \"ShuffleFilter\", \"seed\": 42}\n],\n</code></pre>"},{"location":"includes/pricing/","title":"Pricing","text":""},{"location":"includes/pricing/#prices-used-for-orders","title":"Prices used for orders","text":"<p>Prices for regular orders can be controlled via the parameter structures <code>entry_pricing</code> for trade entries and <code>exit_pricing</code> for trade exits. Prices are always retrieved right before an order is placed, either by querying the exchange tickers or by using the orderbook data.</p> <p>Note</p> <p>Orderbook data used by Freqtrade are the data retrieved from exchange by the ccxt's function <code>fetch_order_book()</code>, i.e. are usually data from the L2-aggregated orderbook, while the ticker data are the structures returned by the ccxt's <code>fetch_ticker()</code>/<code>fetch_tickers()</code> functions. Refer to the ccxt library documentation for more details.</p> <p>Using market orders</p> <p>Please read the section Market order pricing section when using market orders.</p>"},{"location":"includes/pricing/#entry-price","title":"Entry price","text":""},{"location":"includes/pricing/#enter-price-side","title":"Enter price side","text":"<p>The configuration setting <code>entry_pricing.price_side</code> defines the side of the orderbook the bot looks for when buying.</p> <p>The following displays an orderbook.</p> <pre><code>...\n103\n102\n101  # ask\n-------------Current spread\n99   # bid\n98\n97\n...\n</code></pre> <p>If <code>entry_pricing.price_side</code> is set to <code>\"bid\"</code>, then the bot will use 99 as entry price. In line with that, if <code>entry_pricing.price_side</code> is set to <code>\"ask\"</code>, then the bot will use 101 as entry price.</p> <p>Depending on the order direction (long/short), this will lead to different results. Therefore we recommend to use <code>\"same\"</code> or <code>\"other\"</code> for this configuration instead. This would result in the following pricing matrix:</p> direction Order setting price crosses spread long buy ask 101 yes long buy bid 99 no long buy same 99 no long buy other 101 yes short sell ask 101 no short sell bid 99 yes short sell same 101 no short sell other 99 yes <p>Using the other side of the orderbook often guarantees quicker filled orders, but the bot can also end up paying more than what would have been necessary. Taker fees instead of maker fees will most likely apply even when using limit buy orders. Also, prices at the \"other\" side of the spread are higher than prices at the \"bid\" side in the orderbook, so the order behaves similar to a market order (however with a maximum price).</p>"},{"location":"includes/pricing/#entry-price-with-orderbook-enabled","title":"Entry price with Orderbook enabled","text":"<p>When entering a trade with the orderbook enabled (<code>entry_pricing.use_order_book=True</code>), Freqtrade fetches the <code>entry_pricing.order_book_top</code> entries from the orderbook and uses the entry specified as <code>entry_pricing.order_book_top</code> on the configured side (<code>entry_pricing.price_side</code>) of the orderbook. 1 specifies the topmost entry in the orderbook, while 2 would use the 2<sup>nd</sup> entry in the orderbook, and so on.</p>"},{"location":"includes/pricing/#entry-price-without-orderbook-enabled","title":"Entry price without Orderbook enabled","text":"<p>The following section uses <code>side</code> as the configured <code>entry_pricing.price_side</code> (defaults to <code>\"same\"</code>).</p> <p>When not using orderbook (<code>entry_pricing.use_order_book=False</code>), Freqtrade uses the best <code>side</code> price from the ticker if it's below the <code>last</code> traded price from the ticker. Otherwise (when the <code>side</code> price is above the <code>last</code> price), it calculates a rate between <code>side</code> and <code>last</code> price based on <code>entry_pricing.price_last_balance</code>.</p> <p>The <code>entry_pricing.price_last_balance</code> configuration parameter controls this. A value of <code>0.0</code> will use <code>side</code> price, while <code>1.0</code> will use the <code>last</code> price and values between those interpolate between ask and last price.</p>"},{"location":"includes/pricing/#check-depth-of-market","title":"Check depth of market","text":"<p>When check depth of market is enabled (<code>entry_pricing.check_depth_of_market.enabled=True</code>), the entry signals are filtered based on the orderbook depth (sum of all amounts) for each orderbook side.</p> <p>Orderbook <code>bid</code> (buy) side depth is then divided by the orderbook <code>ask</code> (sell) side depth and the resulting delta is compared to the value of the <code>entry_pricing.check_depth_of_market.bids_to_ask_delta</code> parameter. The entry order is only executed if the orderbook delta is greater than or equal to the configured delta value.</p> <p>Note</p> <p>A delta value below 1 means that <code>ask</code> (sell) orderbook side depth is greater than the depth of the <code>bid</code> (buy) orderbook side, while a value greater than 1 means opposite (depth of the buy side is higher than the depth of the sell side).</p>"},{"location":"includes/pricing/#exit-price","title":"Exit price","text":""},{"location":"includes/pricing/#exit-price-side","title":"Exit price side","text":"<p>The configuration setting <code>exit_pricing.price_side</code> defines the side of the spread the bot looks for when exiting a trade.</p> <p>The following displays an orderbook:</p> <pre><code>...\n103\n102\n101  # ask\n-------------Current spread\n99   # bid\n98\n97\n...\n</code></pre> <p>If <code>exit_pricing.price_side</code> is set to <code>\"ask\"</code>, then the bot will use 101 as exiting price. In line with that, if <code>exit_pricing.price_side</code> is set to <code>\"bid\"</code>, then the bot will use 99 as exiting price.</p> <p>Depending on the order direction (long/short), this will lead to different results. Therefore we recommend to use <code>\"same\"</code> or <code>\"other\"</code> for this configuration instead. This would result in the following pricing matrix:</p> Direction Order setting price crosses spread long sell ask 101 no long sell bid 99 yes long sell same 101 no long sell other 99 yes short buy ask 101 yes short buy bid 99 no short buy same 99 no short buy other 101 yes"},{"location":"includes/pricing/#exit-price-with-orderbook-enabled","title":"Exit price with Orderbook enabled","text":"<p>When exiting with the orderbook enabled (<code>exit_pricing.use_order_book=True</code>), Freqtrade fetches the <code>exit_pricing.order_book_top</code> entries in the orderbook and uses the entry specified as <code>exit_pricing.order_book_top</code> from the configured side (<code>exit_pricing.price_side</code>) as trade exit price.</p> <p>1 specifies the topmost entry in the orderbook, while 2 would use the 2<sup>nd</sup> entry in the orderbook, and so on.</p>"},{"location":"includes/pricing/#exit-price-without-orderbook-enabled","title":"Exit price without Orderbook enabled","text":"<p>The following section uses <code>side</code> as the configured <code>exit_pricing.price_side</code> (defaults to <code>\"ask\"</code>).</p> <p>When not using orderbook (<code>exit_pricing.use_order_book=False</code>), Freqtrade uses the best <code>side</code> price from the ticker if it's above the <code>last</code> traded price from the ticker. Otherwise (when the <code>side</code> price is below the <code>last</code> price), it calculates a rate between <code>side</code> and <code>last</code> price based on <code>exit_pricing.price_last_balance</code>.</p> <p>The <code>exit_pricing.price_last_balance</code> configuration parameter controls this. A value of <code>0.0</code> will use <code>side</code> price, while <code>1.0</code> will use the last price and values between those interpolate between <code>side</code> and last price.</p>"},{"location":"includes/pricing/#market-order-pricing","title":"Market order pricing","text":"<p>When using market orders, prices should be configured to use the \"correct\" side of the orderbook to allow realistic pricing detection. Assuming both entry and exits are using market orders, a configuration similar to the following must be used</p> <pre><code>  \"order_types\": {\n    \"entry\": \"market\",\n    \"exit\": \"market\"\n    // ...\n  },\n  \"entry_pricing\": {\n    \"price_side\": \"other\",\n    // ...\n  },\n  \"exit_pricing\":{\n    \"price_side\": \"other\",\n    // ...\n  },\n</code></pre> <p>Obviously, if only one side is using limit orders, different pricing combinations can be used.</p>"},{"location":"includes/protections/","title":"Protections","text":""},{"location":"includes/protections/#protections","title":"Protections","text":"<p>Beta feature</p> <p>This feature is still in it's testing phase. Should you notice something you think is wrong please let us know via Discord or via Github Issue.</p> <p>Protections will protect your strategy from unexpected events and market conditions by temporarily stop trading for either one pair, or for all pairs. All protection end times are rounded up to the next candle to avoid sudden, unexpected intra-candle buys.</p> <p>Note</p> <p>Not all Protections will work for all strategies, and parameters will need to be tuned for your strategy to improve performance.  </p> <p>Tip</p> <p>Each Protection can be configured multiple times with different parameters, to allow different levels of protection (short-term / long-term).</p> <p>Backtesting</p> <p>Protections are supported by backtesting and hyperopt, but must be explicitly enabled by using the <code>--enable-protections</code> flag.</p> <p>Setting protections from the configuration</p> <p>Setting protections from the configuration via <code>\"protections\": [],</code> key should be considered deprecated and will be removed in a future version. It is also no longer guaranteed that your protections apply to the strategy in cases where the strategy defines protections as property.</p>"},{"location":"includes/protections/#available-protections","title":"Available Protections","text":"<ul> <li><code>StoplossGuard</code> Stop trading if a certain amount of stoploss occurred within a certain time window.</li> <li><code>MaxDrawdown</code> Stop trading if max-drawdown is reached.</li> <li><code>LowProfitPairs</code> Lock pairs with low profits</li> <li><code>CooldownPeriod</code> Don't enter a trade right after selling a trade.</li> </ul>"},{"location":"includes/protections/#common-settings-to-all-protections","title":"Common settings to all Protections","text":"Parameter Description <code>method</code> Protection name to use.  Datatype: String, selected from available Protections <code>stop_duration_candles</code> For how many candles should the lock be set?  Datatype: Positive integer (in candles) <code>stop_duration</code> how many minutes should protections be locked. Cannot be used together with <code>stop_duration_candles</code>.  Datatype: Float (in minutes) <code>lookback_period_candles</code> Only trades that completed within the last <code>lookback_period_candles</code> candles will be considered. This setting may be ignored by some Protections.  Datatype: Positive integer (in candles). <code>lookback_period</code> Only trades that completed after <code>current_time - lookback_period</code> will be considered. Cannot be used together with <code>lookback_period_candles</code>. This setting may be ignored by some Protections.  Datatype:  Float (in minutes) <code>trade_limit</code> Number of trades required at minimum (not used by all Protections).  Datatype: Positive integer <p>Durations</p> <p>Durations (<code>stop_duration*</code> and <code>lookback_period*</code> can be defined in either minutes or candles). For more flexibility when testing different timeframes, all below examples will use the \"candle\" definition.</p>"},{"location":"includes/protections/#stoploss-guard","title":"Stoploss Guard","text":"<p><code>StoplossGuard</code> selects all trades within <code>lookback_period</code> in minutes (or in candles when using <code>lookback_period_candles</code>). If <code>trade_limit</code> or more trades resulted in stoploss, trading will stop for <code>stop_duration</code> in minutes (or in candles when using <code>stop_duration_candles</code>).</p> <p>This applies across all pairs, unless <code>only_per_pair</code> is set to true, which will then only look at one pair at a time.</p> <p>Similarly, this protection will by default look at all trades (long and short). For futures bots, setting <code>only_per_side</code> will make the bot only consider one side, and will then only lock this one side, allowing for example shorts to continue after a series of long stoplosses.</p> <p><code>required_profit</code> will determine the required relative profit (or loss) for stoplosses to consider. This should normally not be set and defaults to 0.0 - which means all losing stoplosses will be triggering a block.</p> <p>The below example stops trading for all pairs for 4 candles after the last trade if the bot hit stoploss 4 times within the last 24 candles.</p> <pre><code>@property\ndef protections(self):\n    return [\n        {\n            \"method\": \"StoplossGuard\",\n            \"lookback_period_candles\": 24,\n            \"trade_limit\": 4,\n            \"stop_duration_candles\": 4,\n            \"required_profit\": 0.0,\n            \"only_per_pair\": False,\n            \"only_per_side\": False\n        }\n    ]\n</code></pre> <p>Note</p> <p><code>StoplossGuard</code> considers all trades with the results <code>\"stop_loss\"</code>, <code>\"stoploss_on_exchange\"</code> and <code>\"trailing_stop_loss\"</code> if the resulting profit was negative. <code>trade_limit</code> and <code>lookback_period</code> will need to be tuned for your strategy.</p>"},{"location":"includes/protections/#maxdrawdown","title":"MaxDrawdown","text":"<p><code>MaxDrawdown</code> uses all trades within <code>lookback_period</code> in minutes (or in candles when using <code>lookback_period_candles</code>) to determine the maximum drawdown. If the drawdown is below <code>max_allowed_drawdown</code>, trading will stop for <code>stop_duration</code> in minutes (or in candles when using <code>stop_duration_candles</code>) after the last trade - assuming that the bot needs some time to let markets recover.</p> <p>The below sample stops trading for 12 candles if max-drawdown is &gt; 20% considering all pairs - with a minimum of <code>trade_limit</code> trades - within the last 48 candles. If desired, <code>lookback_period</code> and/or <code>stop_duration</code> can be used.</p> <pre><code>@property\ndef protections(self):\n    return  [\n        {\n            \"method\": \"MaxDrawdown\",\n            \"lookback_period_candles\": 48,\n            \"trade_limit\": 20,\n            \"stop_duration_candles\": 12,\n            \"max_allowed_drawdown\": 0.2\n        },\n    ]\n</code></pre>"},{"location":"includes/protections/#low-profit-pairs","title":"Low Profit Pairs","text":"<p><code>LowProfitPairs</code> uses all trades for a pair within <code>lookback_period</code> in minutes (or in candles when using <code>lookback_period_candles</code>) to determine the overall profit ratio. If that ratio is below <code>required_profit</code>, that pair will be locked for <code>stop_duration</code> in minutes (or in candles when using <code>stop_duration_candles</code>).</p> <p>For futures bots, setting <code>only_per_side</code> will make the bot only consider one side, and will then only lock this one side, allowing for example shorts to continue after a series of long losses.</p> <p>The below example will stop trading a pair for 60 minutes if the pair does not have a required profit of 2% (and a minimum of 2 trades) within the last 6 candles.</p> <pre><code>@property\ndef protections(self):\n    return [\n        {\n            \"method\": \"LowProfitPairs\",\n            \"lookback_period_candles\": 6,\n            \"trade_limit\": 2,\n            \"stop_duration\": 60,\n            \"required_profit\": 0.02,\n            \"only_per_pair\": False,\n        }\n    ]\n</code></pre>"},{"location":"includes/protections/#cooldown-period","title":"Cooldown Period","text":"<p><code>CooldownPeriod</code> locks a pair for <code>stop_duration</code> in minutes (or in candles when using <code>stop_duration_candles</code>) after selling, avoiding a re-entry for this pair for <code>stop_duration</code> minutes.</p> <p>The below example will stop trading a pair for 2 candles after closing a trade, allowing this pair to \"cool down\".</p> <pre><code>@property\ndef protections(self):\n    return  [\n        {\n            \"method\": \"CooldownPeriod\",\n            \"stop_duration_candles\": 2\n        }\n    ]\n</code></pre> <p>Note</p> <p>This Protection applies only at pair-level, and will never lock all pairs globally. This Protection does not consider <code>lookback_period</code> as it only looks at the latest trade.</p>"},{"location":"includes/protections/#full-example-of-protections","title":"Full example of Protections","text":"<p>All protections can be combined at will, also with different parameters, creating a increasing wall for under-performing pairs. All protections are evaluated in the sequence they are defined.</p> <p>The below example assumes a timeframe of 1 hour:</p> <ul> <li>Locks each pair after selling for an additional 5 candles (<code>CooldownPeriod</code>), giving other pairs a chance to get filled.</li> <li>Stops trading for 4 hours (<code>4 * 1h candles</code>) if the last 2 days (<code>48 * 1h candles</code>) had 20 trades, which caused a max-drawdown of more than 20%. (<code>MaxDrawdown</code>).</li> <li>Stops trading if more than 4 stoploss occur for all pairs within a 1 day (<code>24 * 1h candles</code>) limit (<code>StoplossGuard</code>).</li> <li>Locks all pairs that had 2 Trades within the last 6 hours (<code>6 * 1h candles</code>) with a combined profit ratio of below 0.02 (&lt;2%) (<code>LowProfitPairs</code>).</li> <li>Locks all pairs for 2 candles that had a profit of below 0.01 (&lt;1%) within the last 24h (<code>24 * 1h candles</code>), a minimum of 4 trades.</li> </ul> <pre><code>from freqtrade.strategy import IStrategy\n\nclass AwesomeStrategy(IStrategy)\n    timeframe = '1h'\n\n    @property\n    def protections(self):\n        return [\n            {\n                \"method\": \"CooldownPeriod\",\n                \"stop_duration_candles\": 5\n            },\n            {\n                \"method\": \"MaxDrawdown\",\n                \"lookback_period_candles\": 48,\n                \"trade_limit\": 20,\n                \"stop_duration_candles\": 4,\n                \"max_allowed_drawdown\": 0.2\n            },\n            {\n                \"method\": \"StoplossGuard\",\n                \"lookback_period_candles\": 24,\n                \"trade_limit\": 4,\n                \"stop_duration_candles\": 2,\n                \"only_per_pair\": False\n            },\n            {\n                \"method\": \"LowProfitPairs\",\n                \"lookback_period_candles\": 6,\n                \"trade_limit\": 2,\n                \"stop_duration_candles\": 60,\n                \"required_profit\": 0.02\n            },\n            {\n                \"method\": \"LowProfitPairs\",\n                \"lookback_period_candles\": 24,\n                \"trade_limit\": 4,\n                \"stop_duration_candles\": 2,\n                \"required_profit\": 0.01\n            }\n        ]\n    # ...\n</code></pre>"},{"location":"includes/release_template/","title":"Release template","text":""},{"location":"includes/release_template/#highlighted-changes","title":"Highlighted changes","text":"<ul> <li>...</li> </ul>"},{"location":"includes/release_template/#how-to-update","title":"How to update","text":"<p>As always, you can update your bot using one of the following commands:</p>"},{"location":"includes/release_template/#docker-compose","title":"docker-compose","text":"<pre><code>docker-compose pull\ndocker-compose up -d\n</code></pre>"},{"location":"includes/release_template/#installation-via-setup-script","title":"Installation via setup script","text":"<pre><code># Deactivate venv and run \n./setup.sh --update\n</code></pre>"},{"location":"includes/release_template/#plain-native-installation","title":"Plain native installation","text":"<pre><code>git pull\npip install -U -r requirements.txt\n</code></pre> Expand full changelog <pre><code>&lt;Paste your changelog here&gt;\n</code></pre>"},{"location":"includes/showcase/","title":"Showcase","text":"<p>This section will highlight a few projects from members of the community.</p> <p>Note</p> <p>The projects below are for the most part not maintained by the freqtrade , therefore use your own caution before using them.</p> <ul> <li>Example freqtrade strategies</li> <li>FrequentHippo - Grafana dashboard with dry/live runs and backtests (by hippocritical).</li> <li>Online pairlist generator (by Blood4rc).</li> <li>Freqtrade Backtesting Project (by Blood4rc).</li> <li>Freqtrade analysis notebook (by Froggleston).</li> <li>TUI for freqtrade (by Froggleston).</li> <li>Bot Academy (by stash86) - Blog about crypto bot projects.</li> </ul>"}]}